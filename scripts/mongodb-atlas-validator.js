// üîß MongoDB Atlas Connection Validator & Optimizer
// Generated by Custom Rules Engine
// Pattern: mongodb+srv://.*@.*\.mongodb\.net/.*

/**
 * Validates MongoDB Atlas connection string format
 * @param {string} connectionString - MongoDB Atlas connection string
 * @returns {object} Validation result with suggestions
 */
function validateMongoDBAtlasConnection(connectionString) {
    const result = {
        isValid: false,
        errors: [],
        warnings: [],
        suggestions: [],
        optimized: null
    };

    // Basic format validation
    const atlasPattern = /^mongodb\+srv:\/\/([^:]+):([^@]+)@([^\.]+)\.mongodb\.net\/([^?]+)(\?.*)?$/;
    const match = connectionString.match(atlasPattern);

    if (!match) {
        result.errors.push("Invalid MongoDB Atlas connection string format");
        result.suggestions.push("Use format: mongodb+srv://username:password@cluster.mongodb.net/database");
        return result;
    }

    const [, username, password, cluster, database, queryParams] = match;

    // Username validation
    if (username.length < 3) {
        result.warnings.push("Username should be at least 3 characters");
    }

    // Password validation (masked in output)
    if (password.length < 8) {
        result.warnings.push("Password should be at least 8 characters for security");
    }

    // Cluster validation
    if (!cluster.includes('-')) {
        result.warnings.push("Cluster name should contain hyphens (e.g., 'cluster0-xxxxx')");
    }

    // Database validation
    if (!database || database.length < 1) {
        result.errors.push("Database name is required");
    }

    // Query parameters optimization
    const params = new URLSearchParams(queryParams || '');
    const optimizations = [];

    // Check for recommended parameters
    if (!params.has('retryWrites')) {
        optimizations.push('retryWrites=true');
    }
    if (!params.has('w')) {
        optimizations.push('w=majority');
    }
    if (!params.has('appName')) {
        optimizations.push('appName=aigestion');
    }

    // Build optimized connection string
    if (optimizations.length > 0) {
        const separator = queryParams ? '&' : '?';
        const optimizedParams = queryParams + separator + optimizations.join('&');
        result.optimized = `mongodb+srv://${username}:${'*'.repeat(password.length)}@${cluster}.mongodb.net/${database}${optimizedParams}`;
        result.suggestions.push("Consider adding optimization parameters for better performance");
    }

    // Security recommendations
    result.suggestions.push("Use environment variables for connection strings");
    result.suggestions.push("Implement connection pooling for production");
    result.suggestions.push("Monitor connection metrics in Atlas dashboard");

    // Performance recommendations
    result.suggestions.push("Consider read preference for read-heavy applications");
    result.suggestions.push("Implement proper indexing strategy");
    result.suggestions.push("Use connection timeout settings");

    result.isValid = result.errors.length === 0;
    return result;
}

/**
 * Generates optimized MongoDB connection options
 * @param {string} connectionString - Base connection string
 * @returns {object} Connection options for Mongoose
 */
function generateOptimizedConnectionOptions(connectionString) {
    const validation = validateMongoDBAtlasConnection(connectionString);
    
    return {
        // Connection pooling
        maxPoolSize: 10,
        minPoolSize: 2,
        maxIdleTimeMS: 30000,
        
        // Timeouts
        serverSelectionTimeoutMS: 5000,
        socketTimeoutMS: 45000,
        connectTimeoutMS: 10000,
        
        // Retry settings
        retryWrites: true,
        retryReads: true,
        
        // Buffering
        bufferMaxEntries: 0,
        bufferCommands: false,
        
        // Performance
        useNewUrlParser: true,
        useUnifiedTopology: true,
        
        // Application identification
        appName: 'aigestion',
        
        // Validation
        validateResult: function(options) {
            return validation.isValid;
        }
    };
}

/**
 * Tests MongoDB Atlas connection
 * @param {string} connectionString - Connection string to test
 * @returns {Promise<object>} Test results
 */
async function testMongoDBAtlasConnection(connectionString) {
    const mongoose = require('mongoose');
    const validation = validateMongoDBAtlasConnection(connectionString);
    
    if (!validation.isValid) {
        return {
            success: false,
            errors: validation.errors,
            warnings: validation.warnings,
            suggestions: validation.suggestions
        };
    }

    const options = generateOptimizedConnectionOptions(connectionString);
    
    try {
        await mongoose.connect(connectionString, options);
        
        // Get connection info
        const admin = mongoose.connection.db.admin();
        const serverStatus = await admin.serverStatus();
        const dbStats = await mongoose.connection.db.stats();
        
        await mongoose.disconnect();
        
        return {
            success: true,
            connectionInfo: {
                host: mongoose.connection.host,
                port: mongoose.connection.port,
                database: mongoose.connection.name,
                version: serverStatus.version,
                uptime: serverStatus.uptime,
                collections: dbStats.collections,
                dataSize: dbStats.dataSize,
                indexSize: dbStats.indexSize
            },
            performance: {
                connections: serverStatus.connections,
                network: serverStatus.network,
                opcounters: serverStatus.opcounters
            },
            warnings: validation.warnings,
            suggestions: validation.suggestions
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            code: error.code,
            warnings: validation.warnings,
            suggestions: validation.suggestions
        };
    }
}

// Export functions
module.exports = {
    validateMongoDBAtlasConnection,
    generateOptimizedConnectionOptions,
    testMongoDBAtlasConnection
};

// CLI usage
if (require.main === module) {
    const connectionString = process.argv[2];
    
    if (!connectionString) {
        console.log('Usage: node mongodb-atlas-validator.js <connection-string>');
        process.exit(1);
    }
    
    console.log('üîß MongoDB Atlas Connection Validator');
    console.log('=====================================');
    
    const validation = validateMongoDBAtlasConnection(connectionString);
    
    console.log(`‚úÖ Valid: ${validation.isValid}`);
    
    if (validation.errors.length > 0) {
        console.log('\n‚ùå Errors:');
        validation.errors.forEach(error => console.log(`  - ${error}`));
    }
    
    if (validation.warnings.length > 0) {
        console.log('\n‚ö†Ô∏è  Warnings:');
        validation.warnings.forEach(warning => console.log(`  - ${warning}`));
    }
    
    if (validation.suggestions.length > 0) {
        console.log('\nüí° Suggestions:');
        validation.suggestions.forEach(suggestion => console.log(`  - ${suggestion}`));
    }
    
    if (validation.optimized) {
        console.log('\nüöÄ Optimized Connection String:');
        console.log(validation.optimized);
    }
    
    // Test connection
    console.log('\nüß™ Testing connection...');
    testMongoDBAtlasConnection(connectionString)
        .then(result => {
            if (result.success) {
                console.log('‚úÖ Connection test successful!');
                console.log(`üìä Database: ${result.connectionInfo.database}`);
                console.log(`üåê Host: ${result.connectionInfo.host}`);
                console.log(`üìà Collections: ${result.connectionInfo.collections}`);
            } else {
                console.log('‚ùå Connection test failed!');
                console.log(`Error: ${result.error}`);
            }
        })
        .catch(error => {
            console.log('‚ùå Test failed:', error.message);
        });
}
