import 'reflect-metadata';
import { Request, Response, NextFunction } from 'express';
import { MalwareScannerMiddleware } from '../../middleware/malware-scanner.middleware';
import { container, TYPES } from '../../config/inversify.config';
import { MalwareScannerService } from '../../services/malware-scanner.service';

// Mock dependencies
jest.mock('../../services/malware-scanner.service');
jest.mock('../../utils/logger');

describe('MalwareScannerMiddleware', () => {
  let middleware: MalwareScannerMiddleware;
  let mockScannerService: jest.Mocked<MalwareScannerService>;
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let nextFunction: NextFunction = jest.fn();

  beforeEach(() => {
    jest.resetAllMocks();

    // Setup Service Mock in Container
    mockScannerService = {
      scanFile: jest.fn(),
      getScanStats: jest.fn(),
      clearCache: jest.fn(),
    } as any;

    // Re-bind to ensure middleware uses the mock
    container.rebind<MalwareScannerService>(TYPES.MalwareScannerService).toConstantValue(mockScannerService);

    middleware = new MalwareScannerMiddleware();
    mockRequest = {
      files: [],
      file: undefined,
    };
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
    };
  });

  describe('scanFiles (Multiple)', () => {
    it('should call next() if no files are present', async () => {
      await middleware.scanFiles(mockRequest as Request, mockResponse as Response, nextFunction);
      expect(nextFunction).toHaveBeenCalled();
    });

    it('should block request if malware is detected in one of multiple files', async () => {
      mockRequest.files = [
        { filename: 'clean.png', path: 'uploads/clean.png', originalname: 'clean.png', size: 100, mimetype: 'image/png' } as any,
        { filename: 'virus.exe', path: 'uploads/virus.exe', originalname: 'virus.exe', size: 200, mimetype: 'application/x-msdownload' } as any,
      ];

      mockScannerService.scanFile.mockResolvedValueOnce({ isInfected: false, threats: [] } as any)
                               .mockResolvedValueOnce({ isInfected: true, threats: ['Test Virus'] } as any);

      await middleware.scanFiles(mockRequest as Request, mockResponse as Response, nextFunction);

      expect(mockResponse.status).toHaveBeenCalledWith(422);
      expect(mockResponse.json).toHaveBeenCalledWith(expect.objectContaining({
        error: 'Malware detected',
        message: expect.stringContaining('1 file(s) contained malware'),
      }));
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should attach results and call next() if all files are clean', async () => {
      mockRequest.files = [
        { filename: 'doc.pdf', path: 'uploads/doc.pdf', originalname: 'doc.pdf', size: 500, mimetype: 'application/pdf' } as any,
      ];

      mockScannerService.scanFile.mockResolvedValue({ isInfected: false, threats: [] } as any);

      await middleware.scanFiles(mockRequest as Request, mockResponse as Response, nextFunction);

      expect((mockRequest as any).fileScanResults).toHaveLength(1);
      expect(nextFunction).toHaveBeenCalled();
    });
  });

  describe('uploadSingle factory', () => {
    it('should return a middleware function', () => {
      const singleMiddleware = middleware.uploadSingle('file');
      expect(typeof singleMiddleware).toBe('function');
    });

    // Note: Testing the internal logic of uploadSingle (wrapping multer)
    // requires more complex setup (supertest or manual multer invocation)
    // but the logic follows scanFiles which is tested above.
  });
});
