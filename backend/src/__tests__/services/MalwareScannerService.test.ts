import 'reflect-metadata';
import { MalwareScannerService } from '../../services/malware-scanner.service';
import fs from 'fs/promises';
import { exec } from 'child_process';
import axios from 'axios';

// Mock dependencies
jest.mock('fs/promises');
jest.mock('child_process');
jest.mock('axios');
jest.mock('../../utils/logger');

describe('MalwareScannerService', () => {
    let scannerService: MalwareScannerService;
    const mockFilePath = 'test-file.txt';
    const mockFileContent = Buffer.from('test content');

    beforeEach(() => {
        jest.resetAllMocks();
        (fs.mkdir as jest.Mock).mockResolvedValue(undefined);
        scannerService = new MalwareScannerService();
    });

    describe('scanFile', () => {
        it('should correctly detect a clean file', async () => {
            (fs.stat as jest.Mock).mockResolvedValue({ size: 12 });
            (fs.readFile as jest.Mock).mockResolvedValue(mockFileContent);

            // Mock ClamAV clean
            (exec as any).mockImplementation((cmd: string, cb: any) => {
                if (cmd.includes('clamscan')) cb(null, { stdout: 'OK' });
                if (cmd.includes('yara')) cb(null, { stdout: '' });
            });

            const result = await scannerService.scanFile(mockFilePath);

            expect(result.isInfected).toBe(false);
            expect(result.threats).toHaveLength(0);
        });

        it('should detect malware via custom rules (eval pattern)', async () => {
            const infectedContent = Buffer.from('const x = eval("1+1");');
            (fs.stat as jest.Mock).mockResolvedValue({ size: 25 });
            (fs.readFile as jest.Mock).mockResolvedValue(infectedContent);

            // Mock engines clean
            (exec as any).mockImplementation((cmd: string, cb: any) => {
                cb(null, { stdout: '' });
            });

            const result = await scannerService.scanFile(mockFilePath);

            expect(result.isInfected).toBe(true);
            expect(result.threats).toContain('JavaScript/PHP eval function');
        });

        it('should detect malware via VirusTotal hash lookup', async () => {
            (fs.stat as jest.Mock).mockResolvedValue({ size: 100 });
            (fs.readFile as jest.Mock).mockResolvedValue(mockFileContent);

            // Force VT API Key
            process.env.VIRUSTOTAL_API_KEY = 'test-api-key';

            (axios.get as jest.Mock).mockResolvedValue({
                status: 200,
                data: {
                    data: {
                        attributes: {
                            last_analysis_stats: { malicious: 5 },
                            last_analysis_results: {
                                'Engine-1': { category: 'malicious', result: 'Trojan.Win32.Generic' }
                            }
                        }
                    }
                }
            });

            // Mock other engines clean
            (exec as any).mockImplementation((cmd: string, cb: any) => {
                cb(null, { stdout: '' });
            });

            const result = await scannerService.scanFile(mockFilePath);

            expect(result.isInfected).toBe(true);
            expect(result.threats[0]).toContain('VirusTotal');
            expect(result.threats).toContain('Trojan.Win32.Generic');
        });

        it('should quarantine an infected file', async () => {
            const infectedContent = Buffer.from('eval(atob("SGFja2Vk"));');
            (fs.stat as jest.Mock).mockResolvedValue({ size: 30 });
            (fs.readFile as jest.Mock).mockResolvedValue(infectedContent);
            (fs.copyFile as jest.Mock).mockResolvedValue(undefined);
            (fs.unlink as jest.Mock).mockResolvedValue(undefined);
            (fs.writeFile as jest.Mock).mockResolvedValue(undefined);

            await scannerService.scanFile(mockFilePath);

            expect(fs.copyFile).toHaveBeenCalled();
            expect(fs.unlink).toHaveBeenCalledWith(mockFilePath); // Original file removed
        });
    });

    describe('cleanupQuarantine', () => {
        it('should delete files older than retention period', async () => {
            const oldTime = Date.now() - (31 * 24 * 60 * 60 * 1000); // 31 days old
            (fs.readdir as jest.Mock).mockResolvedValue(['old-file.info', 'new-file.info']);
            (fs.stat as jest.Mock).mockImplementation((path: string) => {
                if (path.includes('old-file')) return Promise.resolve({ mtimeMs: oldTime });
                return Promise.resolve({ mtimeMs: Date.now() });
            });
            (fs.unlink as jest.Mock).mockResolvedValue(undefined);

            await scannerService.cleanupQuarantine(30);

            // Should unlink old-file and old-file.info
            expect(fs.unlink).toHaveBeenCalledTimes(2);
        });
    });
});
