import axios from 'axios';
import { exec } from 'child_process';
import crypto from 'crypto';
import fs from 'fs/promises';
import { injectable } from 'inversify';
import path from 'path';
import { promisify } from 'util';
import { logger } from '../utils/logger';
import { malwareScannerConfig } from '../config/malware-scanner.config';

const execAsync = promisify(exec);

interface ScanResult {
  file: string;
  hash: string;
  size: number;
  mimeType: string;
  isInfected: boolean;
  threats: string[];
  scanTime: number;
  engine: string;
  timestamp: Date;
}

interface QuarantineInfo {
  originalPath: string;
  quarantinePath: string;
  hash: string;
  threat: string;
  quarantinedAt: Date;
  userId?: string;
}

@injectable()
export class MalwareScannerService {
  private readonly quarantineDir = malwareScannerConfig.quarantineDir;
  private readonly scanCache = new Map<string, ScanResult>();
  private readonly cacheTimeout = malwareScannerConfig.cacheTimeout;

  private isClamAVAvailable = false;
  private isYARAAvailable = false;

  constructor() {
    this.initializeQuarantine();
    this.checkEngines();
  }

  private async checkEngines() {
    try {
      await execAsync('clamscan --version');
      this.isClamAVAvailable = true;
      logger.info('ClamAV engine detected and ready');
    } catch (error) {
      logger.warn('ClamAV engine not found, ClamAV scanning will be skipped');
    }

    try {
      await execAsync('yara --version');
      this.isYARAAvailable = true;
      logger.info('YARA engine detected and ready');
    } catch (error) {
      logger.warn('YARA engine not found, YARA scanning will be skipped');
    }
  }

  private async initializeQuarantine() {
    try {
      await fs.mkdir(this.quarantineDir, { recursive: true });
      logger.info('Malware scanner quarantine directory initialized');
    } catch (error) {
      logger.error('Failed to initialize quarantine directory:', error);
    }
  }

  public async scanFile(filePath: string, userId?: string): Promise<ScanResult> {
    const startTime = Date.now();

    try {
      // Check file exists
      const stats = await fs.stat(filePath);
      const fileBuffer = await fs.readFile(filePath);
      const hash = this.calculateHash(fileBuffer);

      // Check cache first
      const cached = this.scanCache.get(hash);
      if (cached && Date.now() - cached.timestamp.getTime() < this.cacheTimeout) {
        logger.info('Using cached scan result', { file: filePath, hash });
        return cached;
      }

      // Determine file type
      const mimeType = await this.detectMimeType(fileBuffer);

      // Scan with multiple engines
      const scanResults = await Promise.allSettled([
        this.scanWithClamAV(filePath),
        this.scanWithYARA(filePath),
        this.scanWithCustomRules(fileBuffer, mimeType),
        this.scanWithVirusTotal(hash),
      ]);

      // Aggregate results
      const threats: string[] = [];
      let isInfected = false;

      scanResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          if (result.value.isInfected) {
            isInfected = true;
            threats.push(...result.value.threats);
          }
          logger.debug(`Scan engine ${index} result:`, result.value);
        } else {
          logger.warn(`Scan engine ${index} failed:`, result.reason);
        }
      });

      const scanResult: ScanResult = {
        file: filePath,
        hash,
        size: stats.size,
        mimeType,
        isInfected,
        threats: [...new Set(threats)], // Remove duplicates
        scanTime: Date.now() - startTime,
        engine: 'multi-engine',
        timestamp: new Date(),
      };

      // Cache result
      this.scanCache.set(hash, scanResult);

      // Quarantine if infected
      if (isInfected) {
        await this.quarantineFile(filePath, scanResult, userId);
        logger.warn('Malware detected and quarantined', {
          file: filePath,
          hash,
          threats: scanResult.threats,
          userId,
        });
      } else {
        logger.info('File scan completed - clean', {
          file: filePath,
          hash,
          scanTime: scanResult.scanTime,
        });
      }

      return scanResult;
    } catch (error) {
      logger.error('Error scanning file:', { filePath, error });
      throw new Error(`Failed to scan file: ${error}`);
    }
  }

  private async scanWithClamAV(
    filePath: string,
  ): Promise<{ isInfected: boolean; threats: string[] }> {
    if (!this.isClamAVAvailable) {
      return { isInfected: false, threats: [] };
    }
    try {
      const { stdout } = await execAsync(`clamscan --no-summary "${filePath}"`);

      if (stdout.includes('FOUND')) {
        const threats = stdout
          .split('\n')
          .filter(line => line.includes('FOUND'))
          .map(line => line.split(':')[0].trim());

        return { isInfected: true, threats };
      }

      return { isInfected: false, threats: [] };
    } catch (error) {
      logger.warn('ClamAV scan failed:', error);
      return { isInfected: false, threats: [] };
    }
  }

  private async scanWithYARA(
    filePath: string,
  ): Promise<{ isInfected: boolean; threats: string[] }> {
    if (!this.isYARAAvailable) {
      return { isInfected: false, threats: [] };
    }
    try {
      const { stdout } = await execAsync(
        `yara ${malwareScannerConfig.yaraRulesPath} "${filePath}"`,
      );

      if (stdout.trim()) {
        const threats = stdout.split('\n').filter(line => line.trim());
        return { isInfected: true, threats };
      }

      return { isInfected: false, threats: [] };
    } catch (error) {
      logger.warn('YARA scan failed:', error);
      return { isInfected: false, threats: [] };
    }
  }

  private async scanWithCustomRules(
    buffer: Buffer,
    mimeType: string,
  ): Promise<{ isInfected: boolean; threats: string[] }> {
    const threats: string[] = [];

    // Check for suspicious patterns
    const suspiciousPatterns = [
      { pattern: /eval\s*\(/i, threat: 'JavaScript/PHP eval function' },
      { pattern: /<script[^>]*>/i, threat: 'Embedded script tag' },
      { pattern: /javascript:/i, threat: 'JavaScript protocol' },
      { pattern: /vbscript:/i, threat: 'VBScript protocol' },
      { pattern: /data:text\/html/i, threat: 'Data URI HTML' },
      { pattern: /PK\x03\x04/, threat: 'ZIP archive (potential payload)' },
      { pattern: /MZ\x90\x00/, threat: 'PE executable' },
      { pattern: /\x7fELF/, threat: 'ELF executable' },
      { pattern: /exec\s*\(/i, threat: 'System command execution' },
      { pattern: /passthru\s*\(/i, threat: 'PHP passthru' },
      { pattern: /shell_exec\s*\(/i, threat: 'PHP shell_exec' },
      { pattern: /system\s*\(/i, threat: 'System call' },
      { pattern: /base64_decode\s*\(/i, threat: 'Base64 decoding (potential obfuscation)' },
      { pattern: /unescape\s*\(|decodeURIComponent\s*\(/i, threat: 'JavaScript de-obfuscation' },
      { pattern: /document\.write\s*\(/i, threat: 'Suspicious DOM manipulation' },
      { pattern: /String\.fromCharCode/i, threat: 'JavaScript character code obfuscation' },
      // Advanced Heuristics
      { pattern: /Invoke-Expression|IEX/i, threat: 'PowerShell remote execution' },
      { pattern: /WScript\.Shell|WshShell/i, threat: 'Windows Script Host manipulation' },
      {
        pattern: /AutoOpen|AutoExec|Document_Open|Workbook_Open/i,
        threat: 'Office Macro Auto-execution',
      },
      { pattern: /vbaProject\.bin/i, threat: 'Embedded VBA Project' },
      { pattern: /python\s+-c|base64\s+-d\s*\|\s*sh/i, threat: 'In-place script execution' },
    ];

    const content = buffer.toString('binary');

    for (const { pattern, threat } of suspiciousPatterns) {
      if (pattern.test(content)) {
        threats.push(threat);
      }
    }

    // Check file extension vs MIME type mismatch
    const suspiciousExtensions = [
      '.exe',
      '.scr',
      '.bat',
      '.cmd',
      '.com',
      '.pif',
      '.vbs',
      '.js',
      '.jar',
    ];
    const hasSuspiciousExtension = suspiciousExtensions.some(ext =>
      content.toLowerCase().includes(ext),
    );

    if (hasSuspiciousExtension && !mimeType.startsWith('application/octet-stream')) {
      threats.push('Suspicious file extension');
    }

    // Check for encrypted/obfuscated content
    const entropy = this.calculateEntropy(buffer);
    if (entropy > 7.0) {
      threats.push('High entropy (possible encryption/obfuscation)');
    }

    // Check for large base64 strings (potential encoded payloads)
    const base64Matches = content.match(/[A-Za-z0-9+/]{100,}={0,2}/g);
    if (base64Matches && base64Matches.length > 0) {
      threats.push('Large base64 strings detected');
    }

    return {
      isInfected: threats.length > 0,
      threats,
    };
  }

  private async scanWithVirusTotal(
    hash: string,
  ): Promise<{ isInfected: boolean; threats: string[] }> {
    try {
      const apiKey = process.env.VIRUSTOTAL_API_KEY;
      if (!apiKey) {
        logger.debug('VirusTotal API key not found, skipping scan', { hash });
        return { isInfected: false, threats: [] };
      }

      const response = await axios.get(`https://www.virustotal.com/api/v3/files/${hash}`, {
        headers: {
          'x-apikey': apiKey,
        },
        validateStatus: (status: number) => status === 200 || status === 404,
      });

      if (response.status === 404) {
        logger.debug('File hash not found in VirusTotal database', { hash });
        return { isInfected: false, threats: [] };
      }

      const { data } = response.data;
      const lastAnalysisStats = data.attributes.last_analysis_stats;
      const maliciousCount = lastAnalysisStats.malicious || 0;
      const suspiciousCount = lastAnalysisStats.suspicious || 0;

      if (maliciousCount > 0 || suspiciousCount > 2) {
        const maliciousThreats = Object.values(
          data.attributes.last_analysis_results as Record<string, any>,
        )
          .filter(r => r.category === 'malicious')
          .map(r => r.result)
          .filter(Boolean);

        return {
          isInfected: true,
          threats: [
            `VirusTotal: ${maliciousCount} engines detected threats`,
            ...maliciousThreats.slice(0, 3),
          ],
        };
      }

      return { isInfected: false, threats: [] };
    } catch (error) {
      logger.warn('VirusTotal scan failed:', error);
      return { isInfected: false, threats: [] };
    }
  }

  private async quarantineFile(
    filePath: string,
    scanResult: ScanResult,
    userId?: string,
  ): Promise<void> {
    try {
      const fileName = path.basename(filePath);
      const quarantineFileName = `${Date.now()}_${fileName}`;
      const quarantinePath = path.join(this.quarantineDir, quarantineFileName);

      // Move file to quarantine
      await fs.copyFile(filePath, quarantinePath);
      await fs.unlink(filePath); // Remove original

      // Store quarantine info
      const quarantineInfo: QuarantineInfo = {
        originalPath: filePath,
        quarantinePath,
        hash: scanResult.hash,
        threat: scanResult.threats.join(', '),
        quarantinedAt: new Date(),
        userId,
      };

      const infoPath = `${quarantinePath}.info`;
      await fs.writeFile(infoPath, JSON.stringify(quarantineInfo, null, 2));

      logger.info('File quarantined successfully', {
        originalPath: filePath,
        quarantinePath,
        threats: scanResult.threats,
      });
    } catch (error) {
      logger.error('Failed to quarantine file:', { filePath, error });
      throw error;
    }
  }

  public async releaseFromQuarantine(quarantinePath: string, targetPath: string): Promise<void> {
    try {
      const infoPath = `${quarantinePath}.info`;
      const infoContent = await fs.readFile(infoPath, 'utf-8');
      const quarantineInfo: QuarantineInfo = JSON.parse(infoContent);

      // Move file back
      await fs.copyFile(quarantinePath, targetPath);
      await fs.unlink(quarantinePath);
      await fs.unlink(infoPath);

      logger.info('File released from quarantine', {
        quarantinePath,
        targetPath,
        originalHash: quarantineInfo.hash,
      });
    } catch (error) {
      logger.error('Failed to release file from quarantine:', { quarantinePath, error });
      throw error;
    }
  }

  public async getQuarantinedFiles(): Promise<QuarantineInfo[]> {
    try {
      const files = await fs.readdir(this.quarantineDir);
      const quarantineFiles: QuarantineInfo[] = [];

      for (const file of files) {
        if (file.endsWith('.info')) {
          const infoPath = path.join(this.quarantineDir, file);
          const infoContent = await fs.readFile(infoPath, 'utf-8');
          const quarantineInfo: QuarantineInfo = JSON.parse(infoContent);
          quarantineFiles.push(quarantineInfo);
        }
      }

      return quarantineFiles.sort((a, b) => b.quarantinedAt.getTime() - a.quarantinedAt.getTime());
    } catch (error) {
      logger.error('Failed to get quarantined files:', error);
      return [];
    }
  }

  public async deleteQuarantinedFile(quarantinePath: string): Promise<void> {
    try {
      const infoPath = `${quarantinePath}.info`;
      await fs.unlink(quarantinePath);
      await fs.unlink(infoPath);

      logger.info('Quarantined file deleted', { quarantinePath });
    } catch (error) {
      logger.error('Failed to delete quarantined file:', { quarantinePath, error });
      throw error;
    }
  }

  /**
   * Cleans up old files from the quarantine directory
   * @param days Number of days to retain files
   */
  public async cleanupQuarantine(
    days: number = malwareScannerConfig.quarantineRetentionDays,
  ): Promise<void> {
    try {
      const files = await fs.readdir(this.quarantineDir);
      const now = Date.now();
      const retentionMs = days * 24 * 60 * 60 * 1000;
      let count = 0;

      for (const file of files) {
        if (file.endsWith('.info')) {
          const infoPath = path.join(this.quarantineDir, file);
          const stats = await fs.stat(infoPath);

          if (now - stats.mtimeMs > retentionMs) {
            const quarantinePath = infoPath.replace('.info', '');
            await this.deleteQuarantinedFile(quarantinePath);
            count++;
          }
        }
      }

      if (count > 0) {
        logger.info(`Quarantine cleanup completed. Removed ${count} old entries.`);
      }
    } catch (error) {
      logger.error('Failed to cleanup quarantine:', error);
    }
  }

  private calculateHash(buffer: Buffer): string {
    return crypto.createHash('sha256').update(buffer).digest('hex');
  }

  private async detectMimeType(buffer: Buffer): Promise<string> {
    // Simple MIME type detection based on file signatures
    const signatures = [
      { pattern: /^\x89PNG\r\n\x1a\n/, mime: 'image/png' },
      { pattern: /^\xff\xd8\xff/, mime: 'image/jpeg' },
      { pattern: /^GIF87a/, mime: 'image/gif' },
      { pattern: /^GIF89a/, mime: 'image/gif' },
      { pattern: /^%PDF-/, mime: 'application/pdf' },
      { pattern: /^PK\x03\x04/, mime: 'application/zip' },
      { pattern: /^MZ\x90\x00/, mime: 'application/x-msdownload' },
      { pattern: /^\x7fELF/, mime: 'application/x-executable' },
    ];

    const content = buffer.toString('binary', 0, Math.min(buffer.length, 100));

    for (const { pattern, mime } of signatures) {
      if (pattern.test(content)) {
        return mime;
      }
    }

    // Default to octet-stream if no signature matches
    return 'application/octet-stream';
  }

  private calculateEntropy(buffer: Buffer): number {
    const frequency = new Map<number, number>();

    // Count byte frequencies
    for (const byte of buffer) {
      frequency.set(byte, (frequency.get(byte) || 0) + 1);
    }

    // Calculate Shannon entropy
    let entropy = 0;
    const length = buffer.length;

    for (const count of frequency.values()) {
      const probability = count / length;
      entropy -= probability * Math.log2(probability);
    }

    return entropy;
  }

  public getScanStats(): {
    totalScans: number;
    infectedFiles: number;
    quarantinedFiles: number;
    averageScanTime: number;
    topThreats: Array<{ threat: string; count: number }>;
  } {
    const scans = Array.from(this.scanCache.values());
    const totalScans = scans.length;
    const infectedFiles = scans.filter(s => s.isInfected).length;
    const averageScanTime =
      totalScans > 0 ? scans.reduce((sum, s) => sum + s.scanTime, 0) / totalScans : 0;

    // Count top threats
    const threatCounts = new Map<string, number>();
    scans.forEach(scan => {
      scan.threats.forEach(threat => {
        threatCounts.set(threat, (threatCounts.get(threat) || 0) + 1);
      });
    });

    const topThreats = Array.from(threatCounts.entries())
      .map(([threat, count]) => ({ threat, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    return {
      totalScans,
      infectedFiles,
      quarantinedFiles: scans.filter(s => s.isInfected).length,
      averageScanTime,
      topThreats,
    };
  }

  public clearCache(): void {
    this.scanCache.clear();
    logger.info('Malware scan cache cleared');
  }
}
