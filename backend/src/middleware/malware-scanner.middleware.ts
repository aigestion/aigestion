import { NextFunction, Request, Response } from 'express';
import multer from 'multer';
import path from 'path';
import { container, TYPES } from '../config/inversify.config';
import { MalwareScannerService } from '../services/malware-scanner.service';
import { logger } from '../utils/logger';
import { UserBehaviorService } from '../services/user-behavior.service';
import fs from 'fs/promises';
import { malwareScannerConfig } from '../config/malware-scanner.config';

// Interface for internal use instead of extending express Global Request
interface FileScanResult {
  originalname: string;
  filename: string;
  path: string;
  size: number;
  mimetype: string;
  scanResult: any;
  isClean: boolean;
}

/**
 * Middleware for scanning uploaded files for malware
 */
export class MalwareScannerMiddleware {
  private _scanner: MalwareScannerService | undefined;
  private uploadDir = malwareScannerConfig.uploadDir;

  private get scanner(): MalwareScannerService {
    return (this._scanner ??= container.get<MalwareScannerService>(TYPES.MalwareScannerService));
  }

  private get behaviorService(): UserBehaviorService {
    return container.get<UserBehaviorService>(UserBehaviorService);
  }

  constructor() {
    this.initializeUploadDir();
  }

  private async initializeUploadDir() {
    try {
      await fs.mkdir(this.uploadDir, { recursive: true });
      logger.info('Upload directory initialized');
    } catch (error) {
      logger.error('Failed to initialize upload directory:', error);
    }
  }

  /**
   * Multer configuration for file uploads
   */
  public getMulterConfig() {
    const storage = multer.diskStorage({
      destination: (req, file, cb) => {
        cb(null, this.uploadDir);
      },
      filename: (req, file, cb) => {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
        const ext = path.extname(file.originalname);
        cb(null, `${file.fieldname}-${uniqueSuffix}${ext}`);
      },
    });

    const fileFilter = (req: any, file: any, cb: any) => {
      // Check file size limit from config
      if (file.size > malwareScannerConfig.maxFileSize) {
        return cb(
          new Error(`File size exceeds ${malwareScannerConfig.maxFileSize / (1024 * 1024)}MB limit`)
        );
      }

      // Check allowed MIME types from config
      if (malwareScannerConfig.allowedMimeTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error(`File type ${file.mimetype} is not allowed`));
      }
    };

    return multer({
      storage,
      fileFilter,
      limits: {
        fileSize: malwareScannerConfig.maxFileSize,
        files: malwareScannerConfig.maxFiles,
      },
    });
  }

  /**
   * Middleware to scan uploaded files
   */
  public scanFiles = async (req: any, res: any, next: NextFunction) => {
    const files = req.files;
    if (!files || !Array.isArray(files) || files.length === 0) {
      return next();
    }

    const scanResults: FileScanResult[] = [];
    const userId = req.user?.id;

    try {
      // Scan each file
      for (const file of files) {
        logger.info('Scanning uploaded file', {
          filename: file.filename,
          originalname: file.originalname,
          size: file.size,
          mimetype: file.mimetype,
        });

        try {
          const scanResult = await this.scanner.scanFile(file.path, userId);

          const fileScanResult: FileScanResult = {
            originalname: file.originalname,
            filename: file.filename,
            path: file.path,
            size: file.size,
            mimetype: file.mimetype,
            scanResult,
            isClean: !scanResult.isInfected,
          };

          scanResults.push(fileScanResult);

          // If file is infected, remove it from uploads
          if (scanResult.isInfected) {
            // Track threat event
            if (userId) {
              await this.behaviorService.trackThreat(
                userId,
                file.originalname,
                scanResult.threats,
                this.getClientIP(req)
              );
            }

            try {
              await fs.unlink(file.path);
              logger.warn('Infected file removed from uploads', {
                filename: file.filename,
                threats: scanResult.threats,
              });
            } catch (unlinkErr) {
              logger.error('Failed to remove infected file:', unlinkErr);
            }
          }
        } catch (error) {
          logger.error('Error scanning file:', {
            filename: file.filename,
            error,
          });

          // Remove file if scan failed
          try {
            await fs.unlink(file.path);
          } catch (unlinkErr) {
            logger.error('Failed to remove file after scan error:', unlinkErr);
          }

          return res.status(500).json({
            success: false,
            error: 'File scan failed',
            details: error instanceof Error ? error.message : 'Unknown error',
          });
        }
      }

      // Check if any files were infected
      const infectedFiles = scanResults.filter(result => !result.isClean);

      if (infectedFiles.length > 0) {
        logger.warn('Malware detected in uploaded files, cleaning up all files in request', {
          totalFiles: scanResults.length,
          infectedFiles: infectedFiles.length,
        });

        // Cleanup ALL files for this request to prevent leaks
        for (const fileItem of files) {
          try {
            await fs.unlink(fileItem.path);
          } catch (unlinkErr) {
            // File might already be unlinked if it was the infected one
          }
        }

        return res.status(422).json({
          success: false,
          error: 'Malware detected',
          message: `${infectedFiles.length} file(s) contained malware. All uploaded files for this request have been removed.`,
          infectedFiles: infectedFiles.map(f => ({
            originalname: f.originalname,
            threats: f.scanResult.threats,
          })),
        });
      }

      // Attach scan results to request
      req.fileScanResults = scanResults;

      logger.info('All files scanned successfully', {
        totalFiles: scanResults.length,
        totalSize: scanResults.reduce((sum, f) => sum + f.size, 0),
      });

      next();
    } catch (error) {
      logger.error('Error in malware scan middleware:', error);

      // Clean up all files if middleware fails
      const uploadedFiles = req.files;
      if (uploadedFiles && Array.isArray(uploadedFiles)) {
        for (const fileItem of uploadedFiles) {
          try {
            await fs.unlink(fileItem.path);
          } catch (unlinkErr) {
            logger.error('Failed to cleanup file:', unlinkErr);
          }
        }
      }

      return res.status(500).json({
        success: false,
        error: 'File scan process failed',
        details: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * Middleware for single file upload with scanning
   */
  public uploadSingle(field: string) {
    const upload = this.getMulterConfig().single(field);

    return async (req: any, res: any, next: NextFunction) => {
      // First, handle the upload
      upload(req, res, async err => {
        if (err) {
          logger.error('File upload error:', err);
          return res.status(400).json({
            success: false,
            error: 'File upload failed',
            details: err.message,
          });
        }

        // Then scan the file if it exists
        const file = req.file;
        if (file) {
          const userId = req.user?.id;

          try {
            const scanResult = await this.scanner.scanFile(file.path, userId);

            if (scanResult.isInfected) {
              // Track threat event
              if (userId) {
                await this.behaviorService.trackThreat(
                  userId,
                  file.originalname,
                  scanResult.threats,
                  this.getClientIP(req)
                );
              }

              // Remove infected file
              try {
                await fs.unlink(file.path);
              } catch (unlinkErr) {
                logger.error('Failed to remove infected file:', unlinkErr);
              }

              return res.status(422).json({
                success: false,
                error: 'Malware detected',
                message: 'Uploaded file contains malware and was removed',
                threats: scanResult.threats,
              });
            }

            // Attach scan result
            req.fileScanResult = scanResult;
            logger.info('File scanned successfully', {
              filename: file.filename,
              scanTime: scanResult.scanTime,
            });
          } catch (error) {
            logger.error('Error scanning uploaded file:', error);

            // Remove file if scan failed
            try {
              if (file) {
                await fs.unlink(file.path);
              }
            } catch (unlinkErr) {
              logger.error('Failed to remove file after scan error:', unlinkErr);
            }

            return res.status(500).json({
              success: false,
              error: 'File scan failed',
              details: error instanceof Error ? error.message : 'Unknown error',
            });
          }
        }

        next();
      });
    };
  }

  /**
   * Middleware for multiple file upload with scanning
   */
  public uploadMultiple(field: string, maxCount: number = 5) {
    const upload = this.getMulterConfig().array(field, maxCount);

    return async (req: any, res: any, next: NextFunction) => {
      // First, handle the upload
      upload(req, res, async err => {
        if (err) {
          logger.error('File upload error:', err);
          return res.status(400).json({
            success: false,
            error: 'File upload failed',
            details: err.message,
          });
        }

        // Then scan files using the scanFiles middleware
        this.scanFiles(req, res, next);
      });
    };
  }

  /**
   * Get scanner statistics
   */
  public getScannerStats() {
    return this.scanner.getScanStats();
  }

  /**
   * Clear scanner cache
   */
  public clearCache() {
    this.scanner.clearCache();
  }

  /**
   * Get client IP address
   */
  private getClientIP(req: any): string {
    return req.ip || req.connection?.remoteAddress || req.socket?.remoteAddress || 'unknown';
  }
}

// Export singleton instance
export const malwareScanner = new MalwareScannerMiddleware();

// Export convenience methods
export const uploadSingle = (field: string) => malwareScanner.uploadSingle(field);
export const uploadMultiple = (field: string, maxCount?: number) =>
  malwareScanner.uploadMultiple(field, maxCount);
export const scanUploadedFiles = malwareScanner.scanFiles;
