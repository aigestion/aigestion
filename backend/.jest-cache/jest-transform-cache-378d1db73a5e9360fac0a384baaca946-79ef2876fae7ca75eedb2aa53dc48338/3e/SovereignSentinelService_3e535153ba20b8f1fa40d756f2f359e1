b209693ebcbce5677f6a8a51ecaf11fb
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SovereignSentinelService = void 0;
const inversify_1 = require("inversify");
const types_1 = require("../types");
const monitoring_service_1 = require("./monitoring.service");
const logger_1 = require("../utils/logger");
const config_1 = require("../config/config");
let SovereignSentinelService = class SovereignSentinelService {
    monitoringService;
    constructor(monitoringService) {
        this.monitoringService = monitoringService;
    }
    async getResourceForecasts() {
        const metricsToTrack = ['cpu_usage', 'memory_usage'];
        const forecasts = [];
        for (const metricName of metricsToTrack) {
            try {
                const forecast = await this.calculateForecast(metricName);
                if (forecast)
                    forecasts.push(forecast);
            }
            catch (err) {
                logger_1.logger.error({ err, metricName }, '[SovereignSentinel] Forecast calculation failed');
            }
        }
        return forecasts;
    }
    async calculateForecast(metricName) {
        const now = Date.now();
        const startTime = now - 60 * 60 * 1000; // Last hour
        const rawMetrics = await this.monitoringService.getMetricsInRange(metricName, startTime, now);
        if (rawMetrics.length < 5) {
            return null; // Not enough data for trend analysis
        }
        // Simplified Linear Regression: y = mx + b
        const n = rawMetrics.length;
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXX = 0;
        const baseTime = rawMetrics[0].timestamp.getTime();
        for (const metric of rawMetrics) {
            const x = (metric.timestamp.getTime() - baseTime) / 1000; // x in seconds from start
            const y = metric.value;
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumXX += x * x;
        }
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        const currentX = (now - baseTime) / 1000;
        const currentValue = rawMetrics[rawMetrics.length - 1].value;
        // Predictions
        const x1h = currentX + 3600;
        const x24h = currentX + 86400;
        const predicted1h = Math.max(0, slope * x1h + intercept);
        const predicted24h = Math.max(0, slope * x24h + intercept);
        // Threshold check
        const threshold = metricName === 'cpu_usage'
            ? config_1.config.monitoring.cpuThreshold
            : config_1.config.monitoring.memoryThreshold;
        let timeToThresholdMs = null;
        if (slope > 0) {
            const xThreshold = (threshold - intercept) / slope;
            if (xThreshold > currentX) {
                timeToThresholdMs = (xThreshold - currentX) * 1000;
            }
        }
        // Confidence heuristic based on R-squared (simplified)
        const confidence = Math.min(0.95, n / 100); // Higher data frequency = higher confidence placeholder
        return {
            metric: metricName.replace('_usage', '').toUpperCase(),
            currentValue,
            predictedValue1h: predicted1h,
            predictedValue24h: predicted24h,
            timeToThresholdMs,
            confidence,
        };
    }
};
exports.SovereignSentinelService = SovereignSentinelService;
exports.SovereignSentinelService = SovereignSentinelService = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.MonitoringService)),
    __metadata("design:paramtypes", [typeof (_a = typeof monitoring_service_1.MonitoringService !== "undefined" && monitoring_service_1.MonitoringService) === "function" ? _a : Object])
], SovereignSentinelService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcU292ZXJlaWduU2VudGluZWxTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBK0M7QUFDL0Msb0NBQWlDO0FBQ2pDLDZEQUF5RDtBQUN6RCw0Q0FBeUM7QUFDekMsNkNBQTBDO0FBWW5DLElBQU0sd0JBQXdCLEdBQTlCLE1BQU0sd0JBQXdCO0lBQ2tCO0lBQXJELFlBQXFELGlCQUFvQztRQUFwQyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO0lBQUcsQ0FBQztJQUV0RixLQUFLLENBQUMsb0JBQW9CO1FBQy9CLE1BQU0sY0FBYyxHQUFHLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sU0FBUyxHQUF1QixFQUFFLENBQUM7UUFFekMsS0FBSyxNQUFNLFVBQVUsSUFBSSxjQUFjLEVBQUUsQ0FBQztZQUN4QyxJQUFJLENBQUM7Z0JBQ0gsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzFELElBQUksUUFBUTtvQkFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pDLENBQUM7WUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO2dCQUNiLGVBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLEVBQUUsaURBQWlELENBQUMsQ0FBQztZQUN2RixDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFTyxLQUFLLENBQUMsaUJBQWlCLENBQUMsVUFBa0I7UUFDaEQsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLFlBQVk7UUFDcEQsTUFBTSxVQUFV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QUVwRyxPQUFPO1lBQ0wsTUFBTSxFQUFFLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRTtZQUN0RCxZQUFZO1lBQ1osZ0JBQWdCLEVBQUUsV0FBVztZQUM3QixpQkFBaUIsRUFBRSxZQUFZO1lBQy9CLGlCQUFpQjtZQUNqQixVQUFVO1NBQ1gsQ0FBQztJQUNKLENBQUM7Q0FDRixDQUFBO0FBcEZZLDREQUF3QjttQ0FBeEIsd0JBQXdCO0lBRHBDLElBQUEsc0JBQVUsR0FBRTtJQUVFLFdBQUEsSUFBQSxrQkFBTSxFQUFDLGFBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO3lEQUE0QixzQ0FBaUIsb0JBQWpCLHNDQUFpQjtHQUQ5RSx3QkFBd0IsQ0FvRnBDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXFNvdmVyZWlnblNlbnRpbmVsU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tICdpbnZlcnNpZnknO1xyXG5pbXBvcnQgeyBUWVBFUyB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgTW9uaXRvcmluZ1NlcnZpY2UgfSBmcm9tICcuL21vbml0b3Jpbmcuc2VydmljZSc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9jb25maWcnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZUZvcmVjYXN0IHtcclxuICBtZXRyaWM6IHN0cmluZztcclxuICBjdXJyZW50VmFsdWU6IG51bWJlcjtcclxuICBwcmVkaWN0ZWRWYWx1ZTFoOiBudW1iZXI7XHJcbiAgcHJlZGljdGVkVmFsdWUyNGg6IG51bWJlcjtcclxuICB0aW1lVG9UaHJlc2hvbGRNczogbnVtYmVyIHwgbnVsbDtcclxuICBjb25maWRlbmNlOiBudW1iZXI7XHJcbn1cclxuXHJcbkBpbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFNvdmVyZWlnblNlbnRpbmVsU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoQGluamVjdChUWVBFUy5Nb25pdG9yaW5nU2VydmljZSkgcHJpdmF0ZSBtb25pdG9yaW5nU2VydmljZTogTW9uaXRvcmluZ1NlcnZpY2UpIHt9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRSZXNvdXJjZUZvcmVjYXN0cygpOiBQcm9taXNlPFJlc291cmNlRm9yZWNhc3RbXT4ge1xyXG4gICAgY29uc3QgbWV0cmljc1RvVHJhY2sgPSBbJ2NwdV91c2FnZScsICdtZW1vcnlfdXNhZ2UnXTtcclxuICAgIGNvbnN0IGZvcmVjYXN0czogUmVzb3VyY2VGb3JlY2FzdFtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBtZXRyaWNOYW1lIG9mIG1ldHJpY3NUb1RyYWNrKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZm9yZWNhc3QgPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZvcmVjYXN0KG1ldHJpY05hbWUpO1xyXG4gICAgICAgIGlmIChmb3JlY2FzdCkgZm9yZWNhc3RzLnB1c2goZm9yZWNhc3QpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoeyBlcnIsIG1ldHJpY05hbWUgfSwgJ1tTb3ZlcmVpZ25TZW50aW5lbF0gRm9yZWNhc3QgY2FsY3VsYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9yZWNhc3RzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhdGVGb3JlY2FzdChtZXRyaWNOYW1lOiBzdHJpbmcpOiBQcm9taXNlPFJlc291cmNlRm9yZWNhc3QgfCBudWxsPiB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbm93IC0gNjAgKiA2MCAqIDEwMDA7IC8vIExhc3QgaG91clxyXG4gICAgY29uc3QgcmF3TWV0cmljcyA9IGF3YWl0IHRoaXMubW9uaXRvcmluZ1NlcnZpY2UuZ2V0TWV0cmljc0luUmFuZ2UobWV0cmljTmFtZSwgc3RhcnRUaW1lLCBub3cpO1xyXG5cclxuICAgIGlmIChyYXdNZXRyaWNzLmxlbmd0aCA8IDUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7IC8vIE5vdCBlbm91Z2ggZGF0YSBmb3IgdHJlbmQgYW5hbHlzaXNcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaW1wbGlmaWVkIExpbmVhciBSZWdyZXNzaW9uOiB5ID0gbXggKyBiXHJcbiAgICBjb25zdCBuID0gcmF3TWV0cmljcy5sZW5ndGg7XHJcbiAgICBsZXQgc3VtWCA9IDA7XHJcbiAgICBsZXQgc3VtWSA9IDA7XHJcbiAgICBsZXQgc3VtWFkgPSAwO1xyXG4gICAgbGV0IHN1bVhYID0gMDtcclxuXHJcbiAgICBjb25zdCBiYXNlVGltZSA9IHJhd01ldHJpY3NbMF0udGltZXN0YW1wLmdldFRpbWUoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG1ldHJpYyBvZiByYXdNZXRyaWNzKSB7XHJcbiAgICAgIGNvbnN0IHggPSAobWV0cmljLnRpbWVzdGFtcC5nZXRUaW1lKCkgLSBiYXNlVGltZSkgLyAxMDAwOyAvLyB4IGluIHNlY29uZHMgZnJvbSBzdGFydFxyXG4gICAgICBjb25zdCB5ID0gbWV0cmljLnZhbHVlO1xyXG4gICAgICBzdW1YICs9IHg7XHJcbiAgICAgIHN1bVkgKz0geTtcclxuICAgICAgc3VtWFkgKz0geCAqIHk7XHJcbiAgICAgIHN1bVhYICs9IHggKiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNsb3BlID0gKG4gKiBzdW1YWSAtIHN1bVggKiBzdW1ZKSAvIChuICogc3VtWFggLSBzdW1YICogc3VtWCk7XHJcbiAgICBjb25zdCBpbnRlcmNlcHQgPSAoc3VtWSAtIHNsb3BlICogc3VtWCkgLyBuO1xyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRYID0gKG5vdyAtIGJhc2VUaW1lKSAvIDEwMDA7XHJcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSByYXdNZXRyaWNzW3Jhd01ldHJpY3MubGVuZ3RoIC0gMV0udmFsdWU7XHJcblxyXG4gICAgLy8gUHJlZGljdGlvbnNcclxuICAgIGNvbnN0IHgxaCA9IGN1cnJlbnRYICsgMzYwMDtcclxuICAgIGNvbnN0IHgyNGggPSBjdXJyZW50WCArIDg2NDAwO1xyXG4gICAgY29uc3QgcHJlZGljdGVkMWggPSBNYXRoLm1heCgwLCBzbG9wZSAqIHgxaCArIGludGVyY2VwdCk7XHJcbiAgICBjb25zdCBwcmVkaWN0ZWQyNGggPSBNYXRoLm1heCgwLCBzbG9wZSAqIHgyNGggKyBpbnRlcmNlcHQpO1xyXG5cclxuICAgIC8vIFRocmVzaG9sZCBjaGVja1xyXG4gICAgY29uc3QgdGhyZXNob2xkID1cclxuICAgICAgbWV0cmljTmFtZSA9PT0gJ2NwdV91c2FnZSdcclxuICAgICAgICA/IGNvbmZpZy5tb25pdG9yaW5nLmNwdVRocmVzaG9sZFxyXG4gICAgICAgIDogY29uZmlnLm1vbml0b3JpbmcubWVtb3J5VGhyZXNob2xkO1xyXG5cclxuICAgIGxldCB0aW1lVG9UaHJlc2hvbGRNcyA9IG51bGw7XHJcbiAgICBpZiAoc2xvcGUgPiAwKSB7XHJcbiAgICAgIGNvbnN0IHhUaHJlc2hvbGQgPSAodGhyZXNob2xkIC0gaW50ZXJjZXB0KSAvIHNsb3BlO1xyXG4gICAgICBpZiAoeFRocmVzaG9sZCA+IGN1cnJlbnRYKSB7XHJcbiAgICAgICAgdGltZVRvVGhyZXNob2xkTXMgPSAoeFRocmVzaG9sZCAtIGN1cnJlbnRYKSAqIDEwMDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb25maWRlbmNlIGhldXJpc3RpYyBiYXNlZCBvbiBSLXNxdWFyZWQgKHNpbXBsaWZpZWQpXHJcbiAgICBjb25zdCBjb25maWRlbmNlID0gTWF0aC5taW4oMC45NSwgbiAvIDEwMCk7IC8vIEhpZ2hlciBkYXRhIGZyZXF1ZW5jeSA9IGhpZ2hlciBjb25maWRlbmNlIHBsYWNlaG9sZGVyXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbWV0cmljOiBtZXRyaWNOYW1lLnJlcGxhY2UoJ191c2FnZScsICcnKS50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICBjdXJyZW50VmFsdWUsXHJcbiAgICAgIHByZWRpY3RlZFZhbHVlMWg6IHByZWRpY3RlZDFoLFxyXG4gICAgICBwcmVkaWN0ZWRWYWx1ZTI0aDogcHJlZGljdGVkMjRoLFxyXG4gICAgICB0aW1lVG9UaHJlc2hvbGRNcyxcclxuICAgICAgY29uZmlkZW5jZSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdLCJ2ZXJzaW9uIjozfQ==