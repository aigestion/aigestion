db7702f490445c48d7633321de1062e2
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const response_builder_1 = require("../common/response-builder");
const config_1 = require("../config/config");
const inversify_config_1 = require("../config/inversify.config");
const healthRouter = (0, express_1.Router)();
/**
 * @openapi
 * /api/v1/health:
 *   get:
 *     summary: Basic health check
 *     tags: [System]
 *     responses:
 *       200:
 *         description: System is up
 */
healthRouter.get('/', (req, res) => {
    const requestId = req.requestId || 'unknown';
    return res.json((0, response_builder_1.buildResponse)({
        status: 'healthy',
        uptime: process.uptime(),
        version: config_1.config.apiDocs.version || '1.0.0',
    }, 200, requestId));
});
/**
 * @openapi
 * /api/v1/health/detailed:
 *   get:
 *     summary: Get detailed system health diagnostics
 *     tags: [System]
 *     responses:
 *       200:
 *         description: System health report
 */
healthRouter.get('/detailed', async (req, res) => {
    const requestId = req.requestId ?? 'unknown';
    try {
        const healthService = inversify_config_1.container.get(inversify_config_1.TYPES.DetailedHealthService);
        const report = await healthService.getDetailedHealth();
        return res.json((0, response_builder_1.buildResponse)(report, 200, requestId));
    }
    catch (error) {
        console.error('Detailed Health Check Failed:', error);
        return res.status(500).json({
            success: false,
            message: 'Failed to generate detailed health report',
            error: error.message ?? 'Unknown',
        });
    }
});
exports.default = healthRouter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxyb3V0ZXNcXGhlYWx0aC5yb3V0ZXMudHMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBb0Q7QUFDcEQsaUVBQTJEO0FBQzNELDZDQUEwQztBQUMxQyxpRUFBOEQ7QUFHOUQsTUFBTSxZQUFZLEdBQUcsSUFBQSxnQkFBTSxHQUFFLENBQUM7QUFFOUI7Ozs7Ozs7OztHQVNHO0FBQ0gsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFZLEVBQUUsR0FBYSxFQUFFLEVBQUU7SUFDcEQsTUFBTSxTQUFTLEdBQUksR0FBVyxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUM7SUFDdEQsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUNiLElBQUEsZ0NBQWEsRUFDWDtRQUNFLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFO1FBQ3hCLE9BQU8sRUFBRSxlQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sSUFBSSxPQUFPO0tBQzNDLEVBQ0QsR0FBRyxFQUNILFNBQVMsQ0FDVixDQUNGLENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQztBQUVIOzs7Ozs7Ozs7R0FTRztBQUNILFlBQVksQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxHQUFZLEVBQUUsR0FBYSxFQUFFLEVBQUU7SUFDbEUsTUFBTSxTQUFTLEdBQUksR0FBVyxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUM7SUFDdEQsSUFBSSxDQUFDO1FBQ0gsTUFBTSxhQUFhLEdBQUcsNEJBQVMsQ0FBQyxHQUFHLENBQWdCLHdCQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUNoRixNQUFNLE1BQU0sR0FBRyxNQUFNLGFBQWEsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3ZELE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFBLGdDQUFhLEVBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFtQixDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBQUMsT0FBTyxLQUFVLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsS0FBSyxDQUFDLCtCQUErQixFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3RELE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDMUIsT0FBTyxFQUFFLEtBQUs7WUFDZCxPQUFPLEVBQUUsMkNBQTJDO1lBQ3BELEtBQUssRUFBRSxLQUFLLENBQUMsT0FBTyxJQUFJLFNBQVM7U0FDbEMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztBQUNILENBQUMsQ0FBQyxDQUFDO0FBRUgsa0JBQWUsWUFBWSxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xccm91dGVzXFxoZWFsdGgucm91dGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcXVlc3QsIFJlc3BvbnNlLCBSb3V0ZXIgfSBmcm9tICdleHByZXNzJztcbmltcG9ydCB7IGJ1aWxkUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vcmVzcG9uc2UtYnVpbGRlcic7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcvY29uZmlnJztcbmltcG9ydCB7IGNvbnRhaW5lciwgVFlQRVMgfSBmcm9tICcuLi9jb25maWcvaW52ZXJzaWZ5LmNvbmZpZyc7XG5pbXBvcnQgeyBIZWFsdGhTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvaGVhbHRoLnNlcnZpY2UnO1xuXG5jb25zdCBoZWFsdGhSb3V0ZXIgPSBSb3V0ZXIoKTtcblxuLyoqXG4gKiBAb3BlbmFwaVxuICogL2FwaS92MS9oZWFsdGg6XG4gKiAgIGdldDpcbiAqICAgICBzdW1tYXJ5OiBCYXNpYyBoZWFsdGggY2hlY2tcbiAqICAgICB0YWdzOiBbU3lzdGVtXVxuICogICAgIHJlc3BvbnNlczpcbiAqICAgICAgIDIwMDpcbiAqICAgICAgICAgZGVzY3JpcHRpb246IFN5c3RlbSBpcyB1cFxuICovXG5oZWFsdGhSb3V0ZXIuZ2V0KCcvJywgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBjb25zdCByZXF1ZXN0SWQgPSAocmVxIGFzIGFueSkucmVxdWVzdElkIHx8ICd1bmtub3duJztcbiAgcmV0dXJuIHJlcy5qc29uKFxuICAgIGJ1aWxkUmVzcG9uc2UoXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogJ2hlYWx0aHknLFxuICAgICAgICB1cHRpbWU6IHByb2Nlc3MudXB0aW1lKCksXG4gICAgICAgIHZlcnNpb246IGNvbmZpZy5hcGlEb2NzLnZlcnNpb24gfHwgJzEuMC4wJyxcbiAgICAgIH0sXG4gICAgICAyMDAsXG4gICAgICByZXF1ZXN0SWQsXG4gICAgKSxcbiAgKTtcbn0pO1xuXG4vKipcbiAqIEBvcGVuYXBpXG4gKiAvYXBpL3YxL2hlYWx0aC9kZXRhaWxlZDpcbiAqICAgZ2V0OlxuICogICAgIHN1bW1hcnk6IEdldCBkZXRhaWxlZCBzeXN0ZW0gaGVhbHRoIGRpYWdub3N0aWNzXG4gKiAgICAgdGFnczogW1N5c3RlbV1cbiAqICAgICByZXNwb25zZXM6XG4gKiAgICAgICAyMDA6XG4gKiAgICAgICAgIGRlc2NyaXB0aW9uOiBTeXN0ZW0gaGVhbHRoIHJlcG9ydFxuICovXG5oZWFsdGhSb3V0ZXIuZ2V0KCcvZGV0YWlsZWQnLCBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IChyZXEgYXMgYW55KS5yZXF1ZXN0SWQgPz8gJ3Vua25vd24nO1xuICB0cnkge1xuICAgIGNvbnN0IGhlYWx0aFNlcnZpY2UgPSBjb250YWluZXIuZ2V0PEhlYWx0aFNlcnZpY2U+KFRZUEVTLkRldGFpbGVkSGVhbHRoU2VydmljZSk7XG4gICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgaGVhbHRoU2VydmljZS5nZXREZXRhaWxlZEhlYWx0aCgpO1xuICAgIHJldHVybiByZXMuanNvbihidWlsZFJlc3BvbnNlKHJlcG9ydCwgMjAwLCByZXF1ZXN0SWQgYXMgc3RyaW5nKSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdEZXRhaWxlZCBIZWFsdGggQ2hlY2sgRmFpbGVkOicsIGVycm9yKTtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGdlbmVyYXRlIGRldGFpbGVkIGhlYWx0aCByZXBvcnQnLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgPz8gJ1Vua25vd24nLFxuICAgIH0pO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaGVhbHRoUm91dGVyO1xuIl0sInZlcnNpb24iOjN9