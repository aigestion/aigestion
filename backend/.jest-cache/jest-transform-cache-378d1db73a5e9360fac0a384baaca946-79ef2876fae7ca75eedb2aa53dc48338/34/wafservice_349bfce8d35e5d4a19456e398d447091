596b605595766fdc6537266280bd0405
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WAFService = void 0;
const inversify_1 = require("inversify");
const waf_middleware_1 = require("../middleware/waf.middleware");
const logger_1 = require("../utils/logger");
let WAFService = class WAFService {
    events = [];
    maxEvents = 10000; // Keep last 10k events
    timeSeriesData = [];
    ipStats = new Map();
    constructor() {
        // Initialize time series data
        this.initializeTimeSeries();
        // Clean up old data periodically
        setInterval(() => this.cleanupOldData(), 5 * 60 * 1000); // Every 5 minutes
    }
    initializeTimeSeries() {
        // Initialize with last 24 hours of data
        const now = new Date();
        for (let i = 23; i >= 0; i--) {
            const timestamp = new Date(now.getTime() - i * 60 * 60 * 1000);
            this.timeSeriesData.push({
                timestamp,
                requests: 0,
                blocks: 0,
                warnings: 0,
            });
        }
    }
    logEvent(event) {
        const fullEvent = {
            id: this.generateEventId(),
            timestamp: new Date(),
            type: event.type || 'info',
            rule: event.rule || 'unknown',
            severity: event.severity || 'medium',
            ip: event.ip || 'unknown',
            userAgent: event.userAgent || 'unknown',
            path: event.path || 'unknown',
            method: event.method || 'unknown',
            payload: event.payload,
            context: event.context || 'unknown',
        };
        // Add to events array
        this.events.push(fullEvent);
        // Keep only last maxEvents
        if (this.events.length > this.maxEvents) {
            this.events = this.events.slice(-this.maxEvents);
        }
        // Update IP statistics
        this.updateIPStats(fullEvent.ip, fullEvent.type === 'block');
        // Update time series data
        this.updateTimeSeriesData(fullEvent.type);
        // Log based on severity
        switch (fullEvent.severity) {
            case 'critical':
                logger_1.logger.error('WAF Critical Event', fullEvent);
                break;
            case 'high':
                logger_1.logger.warn('WAF High Severity Event', fullEvent);
                break;
            case 'medium':
                logger_1.logger.warn('WAF Medium Severity Event', fullEvent);
                break;
            default:
                logger_1.logger.info('WAF Event', fullEvent);
        }
    }
    generateEventId() {
        return `waf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    updateIPStats(ip, blocked) {
        const existing = this.ipStats.get(ip);
        if (existing) {
            existing.count++;
            existing.blocked = existing.blocked || blocked;
            existing.lastSeen = new Date();
        }
        else {
            this.ipStats.set(ip, {
                count: 1,
                blocked,
                lastSeen: new Date(),
            });
        }
    }
    updateTimeSeriesData(type) {
        const now = new Date();
        const currentHour = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours());
        // Find or create current hour entry
        let currentData = this.timeSeriesData.find(d => d.timestamp.getTime() === currentHour.getTime());
        if (!currentData) {
            currentData = {
                timestamp: currentHour,
                requests: 0,
                blocks: 0,
                warnings: 0,
            };
            this.timeSeriesData.push(currentData);
            // Keep only last 24 hours
            this.timeSeriesData = this.timeSeriesData.filter(d => d.timestamp.getTime() > now.getTime() - 24 * 60 * 60 * 1000);
        }
        currentData.requests++;
        if (type === 'block')
            currentData.blocks++;
        if (type === 'warning')
            currentData.warnings++;
    }
    cleanupOldData() {
        const now = new Date();
        const cutoff = now.getTime() - 24 * 60 * 60 * 1000; // 24 hours ago
        // Clean up old IP stats
        for (const [ip, stats] of this.ipStats.entries()) {
            if (stats.lastSeen.getTime() < cutoff) {
                this.ipStats.delete(ip);
            }
        }
    }
    getMetrics() {
        const stats = waf_middleware_1.wafManagement.getStats();
        const rules = waf_middleware_1.wafManagement.getRules();
        const rulesTriggered = stats.rulesTriggered;
        // Calculate top attacks
        const topAttacks = Object.entries(rulesTriggered)
            .map(([rule, count]) => ({
            rule,
            count,
            percentage: stats.totalRequests > 0 ? (count / stats.totalRequests) * 100 : 0,
        }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        // Calculate top IPs
        const topIPs = Array.from(this.ipStats.entries())
            .map(([ip, stats]) => ({
            ip,
            count: stats.count,
            blocked: stats.blocked,
        }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 20);
        return {
            totalRequests: stats.totalRequests,
            blockedRequests: stats.blockedRequests,
            warnings: stats.warnings,
            blockRate: stats.totalRequests > 0 ? (stats.blockedRequests / stats.totalRequests) * 100 : 0,
            topAttacks,
            topIPs,
            timeSeriesData: this.timeSeriesData,
        };
    }
    getEvents(filters) {
        let filteredEvents = [...this.events];
        // Apply filters
        if (filters?.type) {
            filteredEvents = filteredEvents.filter(e => e.type === filters.type);
        }
        if (filters?.severity) {
            filteredEvents = filteredEvents.filter(e => e.severity === filters.severity);
        }
        if (filters?.rule) {
            filteredEvents = filteredEvents.filter(e => e.rule === filters.rule);
        }
        if (filters?.ip) {
            filteredEvents = filteredEvents.filter(e => e.ip === filters.ip);
        }
        // Sort by timestamp (newest first)
        filteredEvents.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        const total = filteredEvents.length;
        const limit = filters?.limit || 100;
        const offset = filters?.offset || 0;
        return {
            events: filteredEvents.slice(offset, offset + limit),
            total,
        };
    }
    getIPReputation(ip) {
        const ipStats = this.ipStats.get(ip);
        if (!ipStats) {
            return {
                reputation: 'good',
                score: 100,
                details: {
                    totalRequests: 0,
                    blockedRequests: 0,
                    lastSeen: new Date(),
                    rulesTriggered: [],
                },
            };
        }
        const ipEvents = this.events.filter(e => e.ip === ip);
        const blockedRequests = ipEvents.filter(e => e.type === 'block').length;
        const rulesTriggered = [...new Set(ipEvents.map(e => e.rule))];
        // Calculate reputation score (0-100)
        let score = 100;
        if (ipStats.blocked)
            score -= 50;
        score -= (blockedRequests / ipStats.count) * 30; // Penalty for high block rate
        score -= Math.min(rulesTriggered.length * 5, 20); // Penalty for multiple rules
        let reputation;
        if (score >= 80)
            reputation = 'good';
        else if (score >= 50)
            reputation = 'suspicious';
        else
            reputation = 'malicious';
        return {
            reputation,
            score: Math.max(0, Math.round(score)),
            details: {
                totalRequests: ipStats.count,
                blockedRequests,
                lastSeen: ipStats.lastSeen,
                rulesTriggered,
            },
        };
    }
    blockIP(ip, reason, duration = 24 * 60 * 60 * 1000) {
        // This would integrate with your IP blocking system
        logger_1.logger.warn('IP blocked by WAF service', {
            ip,
            reason,
            duration,
            timestamp: new Date().toISOString(),
        });
        // Update IP stats to mark as blocked
        const stats = this.ipStats.get(ip);
        if (stats) {
            stats.blocked = true;
        }
        // Log event
        this.logEvent({
            type: 'block',
            rule: 'MANUAL_BLOCK',
            severity: 'high',
            ip,
            context: `Manual block: ${reason}`,
            path: '/blocked',
            method: 'BLOCK',
        });
    }
    unblockIP(ip, reason) {
        logger_1.logger.info('IP unblocked by WAF service', {
            ip,
            reason,
            timestamp: new Date().toISOString(),
        });
        // Update IP stats to mark as unblocked
        const stats = this.ipStats.get(ip);
        if (stats) {
            stats.blocked = false;
        }
    }
    exportEvents(format = 'json') {
        const events = this.getEvents({ limit: 10000 }).events;
        if (format === 'csv') {
            const headers = [
                'id',
                'timestamp',
                'type',
                'rule',
                'severity',
                'ip',
                'path',
                'method',
                'context',
            ];
            const csvData = events.map(event => [
                event.id,
                event.timestamp.toISOString(),
                event.type,
                event.rule,
                event.severity,
                event.ip,
                event.path,
                event.method,
                event.context,
            ]);
            return [headers, ...csvData].map(row => row.join(',')).join('\n');
        }
        return JSON.stringify(events, null, 2);
    }
    getDashboardData() {
        const overview = this.getMetrics();
        const recentEvents = this.getEvents({ limit: 50 }).events;
        const topThreats = overview.topAttacks.map(attack => ({
            rule: attack.rule,
            count: attack.count,
            severity: this.getRuleSeverity(attack.rule),
        }));
        // Simple threat map (would integrate with GeoIP in production)
        const threatMap = Array.from(this.ipStats.entries())
            .map(([ip, stats]) => ({
            country: this.getCountryFromIP(ip), // Placeholder function
            count: stats.count,
        }))
            .filter(item => item.country !== 'unknown')
            .reduce((acc, item) => {
            const existing = acc.find(x => x.country === item.country);
            if (existing) {
                existing.count += item.count;
            }
            else {
                acc.push(item);
            }
            return acc;
        }, [])
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        return {
            overview,
            recentEvents,
            topThreats,
            threatMap,
        };
    }
    getRuleSeverity(ruleName) {
        const rules = waf_middleware_1.wafManagement.getRules();
        const rule = rules.find(r => r.name === ruleName);
        return rule?.severity || 'medium';
    }
    getCountryFromIP(ip) {
        // Placeholder - would integrate with GeoIP database
        if (ip.startsWith('192.168.') || ip.startsWith('10.') || ip.startsWith('172.')) {
            return 'private';
        }
        if (ip === '127.0.0.1' || ip === '::1') {
            return 'localhost';
        }
        return 'unknown';
    }
};
exports.WAFService = WAFService;
exports.WAFService = WAFService = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], WAFService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcd2FmLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEseUNBQXVDO0FBQ3ZDLGlFQUE2RDtBQUM3RCw0Q0FBeUM7QUF3Q2xDLElBQU0sVUFBVSxHQUFoQixNQUFNLFVBQVU7SUFDYixNQUFNLEdBQWUsRUFBRSxDQUFDO0lBQ3hCLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQyx1QkFBdUI7SUFDMUMsY0FBYyxHQUtqQixFQUFFLENBQUM7SUFDQSxPQUFPLEdBQUcsSUFBSSxHQUFHLEVBQStELENBQUM7SUFFekY7UUFDRSw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFFNUIsaUNBQWlDO1FBQ2pDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLGtCQUFrQjtJQUM3RSxDQUFDO0lBRU8sb0JBQW9CO1FBQzFCLHdDQUF3QztRQUN4QyxNQUFNLEdBQUcsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM3QixNQUFNLFNBQVMsR0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7Z0JBQ3ZCLFNBQVM7Z0JBQ1QsUUFBUSxFQUFFLENBQUM7Z0JBQ1gsTUFBTSxFQUFFLENBQUM7Z0JBQ1QsUUFBUSxFQUFFLENBQUM7YUFDWixDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVNLFFBQVEsQ0FBQyxLQUF3QjtRQUN0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QUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztZQUMvRSxPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO1FBQ0QsSUFBSSxFQUFFLEtBQUssV0FBVyxJQUFJLEVBQUUsS0FBSyxLQUFLLEVBQUUsQ0FBQztZQUN2QyxPQUFPLFdBQVcsQ0FBQztRQUNyQixDQUFDO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztDQUNGLENBQUE7QUE3WVksZ0NBQVU7cUJBQVYsVUFBVTtJQUR0QixJQUFBLHNCQUFVLEdBQUU7O0dBQ0EsVUFBVSxDQTZZdEIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcd2FmLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0YWJsZSB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyB3YWZNYW5hZ2VtZW50IH0gZnJvbSAnLi4vbWlkZGxld2FyZS93YWYubWlkZGxld2FyZSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5pbnRlcmZhY2UgV0FGRXZlbnQge1xuICBpZDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIHR5cGU6ICdibG9jaycgfCAnd2FybmluZycgfCAnaW5mbyc7XG4gIHJ1bGU6IHN0cmluZztcbiAgc2V2ZXJpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnO1xuICBpcDogc3RyaW5nO1xuICB1c2VyQWdlbnQ6IHN0cmluZztcbiAgcGF0aDogc3RyaW5nO1xuICBtZXRob2Q6IHN0cmluZztcbiAgcGF5bG9hZD86IHN0cmluZztcbiAgY29udGV4dDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgV0FGTWV0cmljcyB7XG4gIHRvdGFsUmVxdWVzdHM6IG51bWJlcjtcbiAgYmxvY2tlZFJlcXVlc3RzOiBudW1iZXI7XG4gIHdhcm5pbmdzOiBudW1iZXI7XG4gIGJsb2NrUmF0ZTogbnVtYmVyO1xuICB0b3BBdHRhY2tzOiBBcnJheTx7XG4gICAgcnVsZTogc3RyaW5nO1xuICAgIGNvdW50OiBudW1iZXI7XG4gICAgcGVyY2VudGFnZTogbnVtYmVyO1xuICB9PjtcbiAgdG9wSVBzOiBBcnJheTx7XG4gICAgaXA6IHN0cmluZztcbiAgICBjb3VudDogbnVtYmVyO1xuICAgIGJsb2NrZWQ6IGJvb2xlYW47XG4gIH0+O1xuICB0aW1lU2VyaWVzRGF0YTogQXJyYXk8e1xuICAgIHRpbWVzdGFtcDogRGF0ZTtcbiAgICByZXF1ZXN0czogbnVtYmVyO1xuICAgIGJsb2NrczogbnVtYmVyO1xuICAgIHdhcm5pbmdzOiBudW1iZXI7XG4gIH0+O1xufVxuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgV0FGU2VydmljZSB7XG4gIHByaXZhdGUgZXZlbnRzOiBXQUZFdmVudFtdID0gW107XG4gIHByaXZhdGUgbWF4RXZlbnRzID0gMTAwMDA7IC8vIEtlZXAgbGFzdCAxMGsgZXZlbnRzXG4gIHByaXZhdGUgdGltZVNlcmllc0RhdGE6IEFycmF5PHtcbiAgICB0aW1lc3RhbXA6IERhdGU7XG4gICAgcmVxdWVzdHM6IG51bWJlcjtcbiAgICBibG9ja3M6IG51bWJlcjtcbiAgICB3YXJuaW5nczogbnVtYmVyO1xuICB9PiA9IFtdO1xuICBwcml2YXRlIGlwU3RhdHMgPSBuZXcgTWFwPHN0cmluZywgeyBjb3VudDogbnVtYmVyOyBibG9ja2VkOiBib29sZWFuOyBsYXN0U2VlbjogRGF0ZSB9PigpO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEluaXRpYWxpemUgdGltZSBzZXJpZXMgZGF0YVxuICAgIHRoaXMuaW5pdGlhbGl6ZVRpbWVTZXJpZXMoKTtcblxuICAgIC8vIENsZWFuIHVwIG9sZCBkYXRhIHBlcmlvZGljYWxseVxuICAgIHNldEludGVydmFsKCgpID0+IHRoaXMuY2xlYW51cE9sZERhdGEoKSwgNSAqIDYwICogMTAwMCk7IC8vIEV2ZXJ5IDUgbWludXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplVGltZVNlcmllcygpIHtcbiAgICAvLyBJbml0aWFsaXplIHdpdGggbGFzdCAyNCBob3VycyBvZiBkYXRhXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBmb3IgKGxldCBpID0gMjM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gaSAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgIHRoaXMudGltZVNlcmllc0RhdGEucHVzaCh7XG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgcmVxdWVzdHM6IDAsXG4gICAgICAgIGJsb2NrczogMCxcbiAgICAgICAgd2FybmluZ3M6IDAsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbG9nRXZlbnQoZXZlbnQ6IFBhcnRpYWw8V0FGRXZlbnQ+KTogdm9pZCB7XG4gICAgY29uc3QgZnVsbEV2ZW50OiBXQUZFdmVudCA9IHtcbiAgICAgIGlkOiB0aGlzLmdlbmVyYXRlRXZlbnRJZCgpLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgdHlwZTogZXZlbnQudHlwZSB8fCAnaW5mbycsXG4gICAgICBydWxlOiBldmVudC5ydWxlIHx8ICd1bmtub3duJyxcbiAgICAgIHNldmVyaXR5OiBldmVudC5zZXZlcml0eSB8fCAnbWVkaXVtJyxcbiAgICAgIGlwOiBldmVudC5pcCB8fCAndW5rbm93bicsXG4gICAgICB1c2VyQWdlbnQ6IGV2ZW50LnVzZXJBZ2VudCB8fCAndW5rbm93bicsXG4gICAgICBwYXRoOiBldmVudC5wYXRoIHx8ICd1bmtub3duJyxcbiAgICAgIG1ldGhvZDogZXZlbnQubWV0aG9kIHx8ICd1bmtub3duJyxcbiAgICAgIHBheWxvYWQ6IGV2ZW50LnBheWxvYWQsXG4gICAgICBjb250ZXh0OiBldmVudC5jb250ZXh0IHx8ICd1bmtub3duJyxcbiAgICB9O1xuXG4gICAgLy8gQWRkIHRvIGV2ZW50cyBhcnJheVxuICAgIHRoaXMuZXZlbnRzLnB1c2goZnVsbEV2ZW50KTtcblxuICAgIC8vIEtlZXAgb25seSBsYXN0IG1heEV2ZW50c1xuICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPiB0aGlzLm1heEV2ZW50cykge1xuICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZSgtdGhpcy5tYXhFdmVudHMpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBJUCBzdGF0aXN0aWNzXG4gICAgdGhpcy51cGRhdGVJUFN0YXRzKGZ1bGxFdmVudC5pcCwgZnVsbEV2ZW50LnR5cGUgPT09ICdibG9jaycpO1xuXG4gICAgLy8gVXBkYXRlIHRpbWUgc2VyaWVzIGRhdGFcbiAgICB0aGlzLnVwZGF0ZVRpbWVTZXJpZXNEYXRhKGZ1bGxFdmVudC50eXBlKTtcblxuICAgIC8vIExvZyBiYXNlZCBvbiBzZXZlcml0eVxuICAgIHN3aXRjaCAoZnVsbEV2ZW50LnNldmVyaXR5KSB7XG4gICAgICBjYXNlICdjcml0aWNhbCc6XG4gICAgICAgIGxvZ2dlci5lcnJvcignV0FGIENyaXRpY2FsIEV2ZW50JywgZnVsbEV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1dBRiBIaWdoIFNldmVyaXR5IEV2ZW50JywgZnVsbEV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICBsb2dnZXIud2FybignV0FGIE1lZGl1bSBTZXZlcml0eSBFdmVudCcsIGZ1bGxFdmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nZ2VyLmluZm8oJ1dBRiBFdmVudCcsIGZ1bGxFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUV2ZW50SWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHdhZl8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUlQU3RhdHMoaXA6IHN0cmluZywgYmxvY2tlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5pcFN0YXRzLmdldChpcCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICBleGlzdGluZy5jb3VudCsrO1xuICAgICAgZXhpc3RpbmcuYmxvY2tlZCA9IGV4aXN0aW5nLmJsb2NrZWQgfHwgYmxvY2tlZDtcbiAgICAgIGV4aXN0aW5nLmxhc3RTZWVuID0gbmV3IERhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pcFN0YXRzLnNldChpcCwge1xuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgYmxvY2tlZCxcbiAgICAgICAgbGFzdFNlZW46IG5ldyBEYXRlKCksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVRpbWVTZXJpZXNEYXRhKHR5cGU6ICdibG9jaycgfCAnd2FybmluZycgfCAnaW5mbycpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRIb3VyID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpLCBub3cuZ2V0SG91cnMoKSk7XG5cbiAgICAvLyBGaW5kIG9yIGNyZWF0ZSBjdXJyZW50IGhvdXIgZW50cnlcbiAgICBsZXQgY3VycmVudERhdGEgPSB0aGlzLnRpbWVTZXJpZXNEYXRhLmZpbmQoXG4gICAgICBkID0+IGQudGltZXN0YW1wLmdldFRpbWUoKSA9PT0gY3VycmVudEhvdXIuZ2V0VGltZSgpLFxuICAgICk7XG5cbiAgICBpZiAoIWN1cnJlbnREYXRhKSB7XG4gICAgICBjdXJyZW50RGF0YSA9IHtcbiAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50SG91cixcbiAgICAgICAgcmVxdWVzdHM6IDAsXG4gICAgICAgIGJsb2NrczogMCxcbiAgICAgICAgd2FybmluZ3M6IDAsXG4gICAgICB9O1xuICAgICAgdGhpcy50aW1lU2VyaWVzRGF0YS5wdXNoKGN1cnJlbnREYXRhKTtcblxuICAgICAgLy8gS2VlcCBvbmx5IGxhc3QgMjQgaG91cnNcbiAgICAgIHRoaXMudGltZVNlcmllc0RhdGEgPSB0aGlzLnRpbWVTZXJpZXNEYXRhLmZpbHRlcihcbiAgICAgICAgZCA9PiBkLnRpbWVzdGFtcC5nZXRUaW1lKCkgPiBub3cuZ2V0VGltZSgpIC0gMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY3VycmVudERhdGEucmVxdWVzdHMrKztcbiAgICBpZiAodHlwZSA9PT0gJ2Jsb2NrJykgY3VycmVudERhdGEuYmxvY2tzKys7XG4gICAgaWYgKHR5cGUgPT09ICd3YXJuaW5nJykgY3VycmVudERhdGEud2FybmluZ3MrKztcbiAgfVxuXG4gIHByaXZhdGUgY2xlYW51cE9sZERhdGEoKTogdm9pZCB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBjdXRvZmYgPSBub3cuZ2V0VGltZSgpIC0gMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gMjQgaG91cnMgYWdvXG5cbiAgICAvLyBDbGVhbiB1cCBvbGQgSVAgc3RhdHNcbiAgICBmb3IgKGNvbnN0IFtpcCwgc3RhdHNdIG9mIHRoaXMuaXBTdGF0cy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChzdGF0cy5sYXN0U2Vlbi5nZXRUaW1lKCkgPCBjdXRvZmYpIHtcbiAgICAgICAgdGhpcy5pcFN0YXRzLmRlbGV0ZShpcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldE1ldHJpY3MoKTogV0FGTWV0cmljcyB7XG4gICAgY29uc3Qgc3RhdHMgPSB3YWZNYW5hZ2VtZW50LmdldFN0YXRzKCk7XG4gICAgY29uc3QgcnVsZXMgPSB3YWZNYW5hZ2VtZW50LmdldFJ1bGVzKCk7XG4gICAgY29uc3QgcnVsZXNUcmlnZ2VyZWQgPSBzdGF0cy5ydWxlc1RyaWdnZXJlZDtcblxuICAgIC8vIENhbGN1bGF0ZSB0b3AgYXR0YWNrc1xuICAgIGNvbnN0IHRvcEF0dGFja3MgPSBPYmplY3QuZW50cmllcyhydWxlc1RyaWdnZXJlZClcbiAgICAgIC5tYXAoKFtydWxlLCBjb3VudF0pID0+ICh7XG4gICAgICAgIHJ1bGUsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBwZXJjZW50YWdlOiBzdGF0cy50b3RhbFJlcXVlc3RzID4gMCA/IChjb3VudCAvIHN0YXRzLnRvdGFsUmVxdWVzdHMpICogMTAwIDogMCxcbiAgICAgIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KVxuICAgICAgLnNsaWNlKDAsIDEwKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0b3AgSVBzXG4gICAgY29uc3QgdG9wSVBzID0gQXJyYXkuZnJvbSh0aGlzLmlwU3RhdHMuZW50cmllcygpKVxuICAgICAgLm1hcCgoW2lwLCBzdGF0c10pID0+ICh7XG4gICAgICAgIGlwLFxuICAgICAgICBjb3VudDogc3RhdHMuY291bnQsXG4gICAgICAgIGJsb2NrZWQ6IHN0YXRzLmJsb2NrZWQsXG4gICAgICB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudClcbiAgICAgIC5zbGljZSgwLCAyMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxSZXF1ZXN0czogc3RhdHMudG90YWxSZXF1ZXN0cyxcbiAgICAgIGJsb2NrZWRSZXF1ZXN0czogc3RhdHMuYmxvY2tlZFJlcXVlc3RzLFxuICAgICAgd2FybmluZ3M6IHN0YXRzLndhcm5pbmdzLFxuICAgICAgYmxvY2tSYXRlOiBzdGF0cy50b3RhbFJlcXVlc3RzID4gMCA/IChzdGF0cy5ibG9ja2VkUmVxdWVzdHMgLyBzdGF0cy50b3RhbFJlcXVlc3RzKSAqIDEwMCA6IDAsXG4gICAgICB0b3BBdHRhY2tzLFxuICAgICAgdG9wSVBzLFxuICAgICAgdGltZVNlcmllc0RhdGE6IHRoaXMudGltZVNlcmllc0RhdGEsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFdmVudHMoZmlsdGVycz86IHtcbiAgICB0eXBlPzogJ2Jsb2NrJyB8ICd3YXJuaW5nJyB8ICdpbmZvJztcbiAgICBzZXZlcml0eT86ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnO1xuICAgIHJ1bGU/OiBzdHJpbmc7XG4gICAgaXA/OiBzdHJpbmc7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gICAgb2Zmc2V0PzogbnVtYmVyO1xuICB9KTogeyBldmVudHM6IFdBRkV2ZW50W107IHRvdGFsOiBudW1iZXIgfSB7XG4gICAgbGV0IGZpbHRlcmVkRXZlbnRzID0gWy4uLnRoaXMuZXZlbnRzXTtcblxuICAgIC8vIEFwcGx5IGZpbHRlcnNcbiAgICBpZiAoZmlsdGVycz8udHlwZSkge1xuICAgICAgZmlsdGVyZWRFdmVudHMgPSBmaWx0ZXJlZEV2ZW50cy5maWx0ZXIoZSA9PiBlLnR5cGUgPT09IGZpbHRlcnMudHlwZSk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzPy5zZXZlcml0eSkge1xuICAgICAgZmlsdGVyZWRFdmVudHMgPSBmaWx0ZXJlZEV2ZW50cy5maWx0ZXIoZSA9PiBlLnNldmVyaXR5ID09PSBmaWx0ZXJzLnNldmVyaXR5KTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnM/LnJ1bGUpIHtcbiAgICAgIGZpbHRlcmVkRXZlbnRzID0gZmlsdGVyZWRFdmVudHMuZmlsdGVyKGUgPT4gZS5ydWxlID09PSBmaWx0ZXJzLnJ1bGUpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycz8uaXApIHtcbiAgICAgIGZpbHRlcmVkRXZlbnRzID0gZmlsdGVyZWRFdmVudHMuZmlsdGVyKGUgPT4gZS5pcCA9PT0gZmlsdGVycy5pcCk7XG4gICAgfVxuXG4gICAgLy8gU29ydCBieSB0aW1lc3RhbXAgKG5ld2VzdCBmaXJzdClcbiAgICBmaWx0ZXJlZEV2ZW50cy5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcC5nZXRUaW1lKCkgLSBhLnRpbWVzdGFtcC5nZXRUaW1lKCkpO1xuXG4gICAgY29uc3QgdG90YWwgPSBmaWx0ZXJlZEV2ZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbGltaXQgPSBmaWx0ZXJzPy5saW1pdCB8fCAxMDA7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZmlsdGVycz8ub2Zmc2V0IHx8IDA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnRzOiBmaWx0ZXJlZEV2ZW50cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KSxcbiAgICAgIHRvdGFsLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0SVBSZXB1dGF0aW9uKGlwOiBzdHJpbmcpOiB7XG4gICAgcmVwdXRhdGlvbjogJ2dvb2QnIHwgJ3N1c3BpY2lvdXMnIHwgJ21hbGljaW91cyc7XG4gICAgc2NvcmU6IG51bWJlcjtcbiAgICBkZXRhaWxzOiB7XG4gICAgICB0b3RhbFJlcXVlc3RzOiBudW1iZXI7XG4gICAgICBibG9ja2VkUmVxdWVzdHM6IG51bWJlcjtcbiAgICAgIGxhc3RTZWVuOiBEYXRlO1xuICAgICAgcnVsZXNUcmlnZ2VyZWQ6IHN0cmluZ1tdO1xuICAgIH07XG4gIH0ge1xuICAgIGNvbnN0IGlwU3RhdHMgPSB0aGlzLmlwU3RhdHMuZ2V0KGlwKTtcbiAgICBpZiAoIWlwU3RhdHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcHV0YXRpb246ICdnb29kJyxcbiAgICAgICAgc2NvcmU6IDEwMCxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIHRvdGFsUmVxdWVzdHM6IDAsXG4gICAgICAgICAgYmxvY2tlZFJlcXVlc3RzOiAwLFxuICAgICAgICAgIGxhc3RTZWVuOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHJ1bGVzVHJpZ2dlcmVkOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgaXBFdmVudHMgPSB0aGlzLmV2ZW50cy5maWx0ZXIoZSA9PiBlLmlwID09PSBpcCk7XG4gICAgY29uc3QgYmxvY2tlZFJlcXVlc3RzID0gaXBFdmVudHMuZmlsdGVyKGUgPT4gZS50eXBlID09PSAnYmxvY2snKS5sZW5ndGg7XG4gICAgY29uc3QgcnVsZXNUcmlnZ2VyZWQgPSBbLi4ubmV3IFNldChpcEV2ZW50cy5tYXAoZSA9PiBlLnJ1bGUpKV07XG5cbiAgICAvLyBDYWxjdWxhdGUgcmVwdXRhdGlvbiBzY29yZSAoMC0xMDApXG4gICAgbGV0IHNjb3JlID0gMTAwO1xuICAgIGlmIChpcFN0YXRzLmJsb2NrZWQpIHNjb3JlIC09IDUwO1xuICAgIHNjb3JlIC09IChibG9ja2VkUmVxdWVzdHMgLyBpcFN0YXRzLmNvdW50KSAqIDMwOyAvLyBQZW5hbHR5IGZvciBoaWdoIGJsb2NrIHJhdGVcbiAgICBzY29yZSAtPSBNYXRoLm1pbihydWxlc1RyaWdnZXJlZC5sZW5ndGggKiA1LCAyMCk7IC8vIFBlbmFsdHkgZm9yIG11bHRpcGxlIHJ1bGVzXG5cbiAgICBsZXQgcmVwdXRhdGlvbjogJ2dvb2QnIHwgJ3N1c3BpY2lvdXMnIHwgJ21hbGljaW91cyc7XG4gICAgaWYgKHNjb3JlID49IDgwKSByZXB1dGF0aW9uID0gJ2dvb2QnO1xuICAgIGVsc2UgaWYgKHNjb3JlID49IDUwKSByZXB1dGF0aW9uID0gJ3N1c3BpY2lvdXMnO1xuICAgIGVsc2UgcmVwdXRhdGlvbiA9ICdtYWxpY2lvdXMnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcHV0YXRpb24sXG4gICAgICBzY29yZTogTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChzY29yZSkpLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0b3RhbFJlcXVlc3RzOiBpcFN0YXRzLmNvdW50LFxuICAgICAgICBibG9ja2VkUmVxdWVzdHMsXG4gICAgICAgIGxhc3RTZWVuOiBpcFN0YXRzLmxhc3RTZWVuLFxuICAgICAgICBydWxlc1RyaWdnZXJlZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBibG9ja0lQKGlwOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyID0gMjQgKiA2MCAqIDYwICogMTAwMCk6IHZvaWQge1xuICAgIC8vIFRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggeW91ciBJUCBibG9ja2luZyBzeXN0ZW1cbiAgICBsb2dnZXIud2FybignSVAgYmxvY2tlZCBieSBXQUYgc2VydmljZScsIHtcbiAgICAgIGlwLFxuICAgICAgcmVhc29uLFxuICAgICAgZHVyYXRpb24sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBJUCBzdGF0cyB0byBtYXJrIGFzIGJsb2NrZWRcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuaXBTdGF0cy5nZXQoaXApO1xuICAgIGlmIChzdGF0cykge1xuICAgICAgc3RhdHMuYmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gTG9nIGV2ZW50XG4gICAgdGhpcy5sb2dFdmVudCh7XG4gICAgICB0eXBlOiAnYmxvY2snLFxuICAgICAgcnVsZTogJ01BTlVBTF9CTE9DSycsXG4gICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgaXAsXG4gICAgICBjb250ZXh0OiBgTWFudWFsIGJsb2NrOiAke3JlYXNvbn1gLFxuICAgICAgcGF0aDogJy9ibG9ja2VkJyxcbiAgICAgIG1ldGhvZDogJ0JMT0NLJyxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1bmJsb2NrSVAoaXA6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsb2dnZXIuaW5mbygnSVAgdW5ibG9ja2VkIGJ5IFdBRiBzZXJ2aWNlJywge1xuICAgICAgaXAsXG4gICAgICByZWFzb24sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBJUCBzdGF0cyB0byBtYXJrIGFzIHVuYmxvY2tlZFxuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5pcFN0YXRzLmdldChpcCk7XG4gICAgaWYgKHN0YXRzKSB7XG4gICAgICBzdGF0cy5ibG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGV4cG9ydEV2ZW50cyhmb3JtYXQ6ICdqc29uJyB8ICdjc3YnID0gJ2pzb24nKTogc3RyaW5nIHtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmdldEV2ZW50cyh7IGxpbWl0OiAxMDAwMCB9KS5ldmVudHM7XG5cbiAgICBpZiAoZm9ybWF0ID09PSAnY3N2Jykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICd0eXBlJyxcbiAgICAgICAgJ3J1bGUnLFxuICAgICAgICAnc2V2ZXJpdHknLFxuICAgICAgICAnaXAnLFxuICAgICAgICAncGF0aCcsXG4gICAgICAgICdtZXRob2QnLFxuICAgICAgICAnY29udGV4dCcsXG4gICAgICBdO1xuICAgICAgY29uc3QgY3N2RGF0YSA9IGV2ZW50cy5tYXAoZXZlbnQgPT4gW1xuICAgICAgICBldmVudC5pZCxcbiAgICAgICAgZXZlbnQudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGV2ZW50LnR5cGUsXG4gICAgICAgIGV2ZW50LnJ1bGUsXG4gICAgICAgIGV2ZW50LnNldmVyaXR5LFxuICAgICAgICBldmVudC5pcCxcbiAgICAgICAgZXZlbnQucGF0aCxcbiAgICAgICAgZXZlbnQubWV0aG9kLFxuICAgICAgICBldmVudC5jb250ZXh0LFxuICAgICAgXSk7XG5cbiAgICAgIHJldHVybiBbaGVhZGVycywgLi4uY3N2RGF0YV0ubWFwKHJvdyA9PiByb3cuam9pbignLCcpKS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXZlbnRzLCBudWxsLCAyKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREYXNoYm9hcmREYXRhKCk6IHtcbiAgICBvdmVydmlldzogV0FGTWV0cmljcztcbiAgICByZWNlbnRFdmVudHM6IFdBRkV2ZW50W107XG4gICAgdG9wVGhyZWF0czogQXJyYXk8eyBydWxlOiBzdHJpbmc7IGNvdW50OiBudW1iZXI7IHNldmVyaXR5OiBzdHJpbmcgfT47XG4gICAgdGhyZWF0TWFwOiBBcnJheTx7IGNvdW50cnk6IHN0cmluZzsgY291bnQ6IG51bWJlciB9PjtcbiAgfSB7XG4gICAgY29uc3Qgb3ZlcnZpZXcgPSB0aGlzLmdldE1ldHJpY3MoKTtcbiAgICBjb25zdCByZWNlbnRFdmVudHMgPSB0aGlzLmdldEV2ZW50cyh7IGxpbWl0OiA1MCB9KS5ldmVudHM7XG5cbiAgICBjb25zdCB0b3BUaHJlYXRzID0gb3ZlcnZpZXcudG9wQXR0YWNrcy5tYXAoYXR0YWNrID0+ICh7XG4gICAgICBydWxlOiBhdHRhY2sucnVsZSxcbiAgICAgIGNvdW50OiBhdHRhY2suY291bnQsXG4gICAgICBzZXZlcml0eTogdGhpcy5nZXRSdWxlU2V2ZXJpdHkoYXR0YWNrLnJ1bGUpLFxuICAgIH0pKTtcblxuICAgIC8vIFNpbXBsZSB0aHJlYXQgbWFwICh3b3VsZCBpbnRlZ3JhdGUgd2l0aCBHZW9JUCBpbiBwcm9kdWN0aW9uKVxuICAgIGNvbnN0IHRocmVhdE1hcCA9IEFycmF5LmZyb20odGhpcy5pcFN0YXRzLmVudHJpZXMoKSlcbiAgICAgIC5tYXAoKFtpcCwgc3RhdHNdKSA9PiAoe1xuICAgICAgICBjb3VudHJ5OiB0aGlzLmdldENvdW50cnlGcm9tSVAoaXApLCAvLyBQbGFjZWhvbGRlciBmdW5jdGlvblxuICAgICAgICBjb3VudDogc3RhdHMuY291bnQsXG4gICAgICB9KSlcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmNvdW50cnkgIT09ICd1bmtub3duJylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGFjYy5maW5kKHggPT4geC5jb3VudHJ5ID09PSBpdGVtLmNvdW50cnkpO1xuICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgZXhpc3RpbmcuY291bnQgKz0gaXRlbS5jb3VudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIFtdIGFzIEFycmF5PHsgY291bnRyeTogc3RyaW5nOyBjb3VudDogbnVtYmVyIH0+LFxuICAgICAgKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KVxuICAgICAgLnNsaWNlKDAsIDEwKTtcblxuICAgIHJldHVybiB7XG4gICAgICBvdmVydmlldyxcbiAgICAgIHJlY2VudEV2ZW50cyxcbiAgICAgIHRvcFRocmVhdHMsXG4gICAgICB0aHJlYXRNYXAsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UnVsZVNldmVyaXR5KHJ1bGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJ1bGVzID0gd2FmTWFuYWdlbWVudC5nZXRSdWxlcygpO1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlcy5maW5kKHIgPT4gci5uYW1lID09PSBydWxlTmFtZSk7XG4gICAgcmV0dXJuIHJ1bGU/LnNldmVyaXR5IHx8ICdtZWRpdW0nO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb3VudHJ5RnJvbUlQKGlwOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIFBsYWNlaG9sZGVyIC0gd291bGQgaW50ZWdyYXRlIHdpdGggR2VvSVAgZGF0YWJhc2VcbiAgICBpZiAoaXAuc3RhcnRzV2l0aCgnMTkyLjE2OC4nKSB8fCBpcC5zdGFydHNXaXRoKCcxMC4nKSB8fCBpcC5zdGFydHNXaXRoKCcxNzIuJykpIHtcbiAgICAgIHJldHVybiAncHJpdmF0ZSc7XG4gICAgfVxuICAgIGlmIChpcCA9PT0gJzEyNy4wLjAuMScgfHwgaXAgPT09ICc6OjEnKSB7XG4gICAgICByZXR1cm4gJ2xvY2FsaG9zdCc7XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==