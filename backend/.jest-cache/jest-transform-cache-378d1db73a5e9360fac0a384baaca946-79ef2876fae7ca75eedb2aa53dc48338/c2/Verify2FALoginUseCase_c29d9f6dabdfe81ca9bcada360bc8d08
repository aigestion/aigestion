6e87c2eb677192d7f5669f48b142a385
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verify2FALoginUseCase = void 0;
const inversify_1 = require("inversify");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const crypto_1 = __importDefault(require("crypto"));
const types_1 = require("../../types");
const two_factor_service_1 = require("../../services/two-factor.service");
const rate_limit_service_1 = require("../../services/rate-limit.service");
const errors_1 = require("../../utils/errors");
const config_1 = require("../../config");
const UserRepository_1 = require("../../infrastructure/repository/UserRepository");
let Verify2FALoginUseCase = class Verify2FALoginUseCase {
    twoFactorService;
    rateLimitService;
    userRepository;
    constructor(twoFactorService, rateLimitService, userRepository) {
        this.twoFactorService = twoFactorService;
        this.rateLimitService = rateLimitService;
        this.userRepository = userRepository;
    }
    async execute(data) {
        const { userId, token, ip, userAgent } = data;
        // Rate Limit: 5 attempts per 15 minutes for 2FA login
        await this.rateLimitService.incrementAndCheck(`login_2fa:${userId}`, 5, 15 * 60);
        const user = await this.userRepository.findById(userId);
        if (!user) {
            throw new errors_1.AppError('User not found', 404, 'USER_NOT_FOUND');
        }
        if (!user.isMfaEnabled && !user.isTwoFactorEnabled) {
            // If MFA is not enabled, why are we here?
            // Maybe user disabled it in another session?
            // Proceed with login anyway for UX or throw?
            // Better to throw as this endpoint expects 2FA.
            throw new errors_1.AppError('2FA not enabled for user', 400, '2FA_NOT_ENABLED');
        }
        // Verify token
        if (!user.twoFactorSecret) {
            throw new errors_1.AppError('2FA setup incomplete', 400, '2FA_SETUP_INCOMPLETE');
        }
        const isValid = await this.twoFactorService.verifyTOTPToken(userId, token);
        // Also check backup codes if TOTP failed?
        // The service has verifyBackupCode method.
        // Let's check if code length is 6 (TOTP) or longer (Likely Backup Code).
        // Usually TOTP is 6 digits. Backup codes are longer.
        let isBackupValid = false;
        if (!isValid && token && token.length > 6) {
            isBackupValid = await this.twoFactorService.verifyBackupCode(userId, token);
        }
        if (!isValid && !isBackupValid) {
            throw new errors_1.AppError('Invalid 2FA code', 401, 'INVALID_2FA_CODE');
        }
        // Generate tokens (Duplicated from LoginUserUseCase)
        const refreshToken = this.generateRefreshTokenString(user);
        const newRefreshTokens = [
            ...(user.refreshTokens ?? []),
            {
                token: refreshToken,
                expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
                familyId: crypto_1.default.randomUUID(),
                ip: ip ?? 'unknown',
                userAgent: userAgent ?? 'unknown',
                createdAt: new Date(),
            },
        ];
        const updates = {
            loginAttempts: 0,
            lockUntil: undefined,
            lastLogin: new Date(),
            refreshTokens: newRefreshTokens.length > 10 ? newRefreshTokens.slice(-10) : newRefreshTokens,
        };
        const updatedUser = await this.userRepository.update(user.id, updates);
        const accessToken = this.generateToken(user, { ip, userAgent });
        // Clear rate limit on success
        await this.rateLimitService.reset(`login_2fa:${userId}`);
        return { user: updatedUser ?? user, token: accessToken, refreshToken };
    }
    generateToken(user, fingerprint) {
        const payload = { id: user._id, email: user.email, role: user.role };
        if (fingerprint) {
            payload.fingerprint = {
                ip: fingerprint.ip ?? 'unknown',
                userAgent: fingerprint.userAgent ?? 'unknown',
            };
        }
        return jsonwebtoken_1.default.sign(payload, config_1.config.jwt.secret, { expiresIn: config_1.config.jwt.expiresIn });
    }
    generateRefreshTokenString(user, familyId) {
        const payload = { id: user._id, familyId: familyId ?? crypto_1.default.randomUUID(), type: 'refresh' };
        return jsonwebtoken_1.default.sign(payload, config_1.config.jwt.secret, { expiresIn: '7d' });
    }
};
exports.Verify2FALoginUseCase = Verify2FALoginUseCase;
exports.Verify2FALoginUseCase = Verify2FALoginUseCase = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.TwoFactorService)),
    __param(1, (0, inversify_1.inject)(types_1.TYPES.RateLimitService)),
    __param(2, (0, inversify_1.inject)(types_1.TYPES.UserRepository)),
    __metadata("design:paramtypes", [typeof (_a = typeof two_factor_service_1.TwoFactorService !== "undefined" && two_factor_service_1.TwoFactorService) === "function" ? _a : Object, typeof (_b = typeof rate_limit_service_1.RateLimitService !== "undefined" && rate_limit_service_1.RateLimitService) === "function" ? _b : Object, typeof (_c = typeof UserRepository_1.IUserRepository !== "undefined" && UserRepository_1.IUserRepository) === "function" ? _c : Object])
], Verify2FALoginUseCase);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxhcHBsaWNhdGlvblxcdXNlY2FzZXNcXFZlcmlmeTJGQUxvZ2luVXNlQ2FzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUNBQStDO0FBQy9DLGdFQUErQjtBQUMvQixvREFBNEI7QUFDNUIsdUNBQW9DO0FBRXBDLDBFQUFxRTtBQUNyRSwwRUFBcUU7QUFDckUsK0NBQThDO0FBQzlDLHlDQUFzQztBQUV0QyxtRkFBaUY7QUFHMUUsSUFBTSxxQkFBcUIsR0FBM0IsTUFBTSxxQkFBcUI7SUFFVTtJQUNBO0lBQ0Y7SUFIeEMsWUFDMEMsZ0JBQWtDLEVBQ2xDLGdCQUFrQyxFQUNwQyxjQUErQjtRQUY3QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDcEMsbUJBQWMsR0FBZCxjQUFjLENBQWlCO0lBQ3BFLENBQUM7SUFFSixLQUFLLENBQUMsT0FBTyxDQUFDLElBQXdFO1FBQ3BGLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFFOUMsc0RBQXNEO1FBQ3RELE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLGFBQWEsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUVqRixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3hELElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLE1BQU0sSUFBSSxpQkFBUSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzlELENBQUM7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0Is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LHFDQUFnQixvREFDcEIsZ0NBQWUsb0JBQWYsZ0NBQWU7R0FKNUQscUJBQXFCLENBNEZqQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFsZWphbmRyb1xcQUlHZXN0aW9uXFxiYWNrZW5kXFxzcmNcXGFwcGxpY2F0aW9uXFx1c2VjYXNlc1xcVmVyaWZ5MkZBTG9naW5Vc2VDYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluamVjdGFibGUsIGluamVjdCB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBUWVBFUyB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFVzZXIsIElVc2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL1VzZXInO1xuaW1wb3J0IHsgVHdvRmFjdG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3R3by1mYWN0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBSYXRlTGltaXRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcmF0ZS1saW1pdC5zZXJ2aWNlJztcbmltcG9ydCB7IEFwcEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uLy4uL2NvbmZpZyc7XG5cbmltcG9ydCB7IElVc2VyUmVwb3NpdG9yeSB9IGZyb20gJy4uLy4uL2luZnJhc3RydWN0dXJlL3JlcG9zaXRvcnkvVXNlclJlcG9zaXRvcnknO1xuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmVyaWZ5MkZBTG9naW5Vc2VDYXNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQGluamVjdChUWVBFUy5Ud29GYWN0b3JTZXJ2aWNlKSBwcml2YXRlIHR3b0ZhY3RvclNlcnZpY2U6IFR3b0ZhY3RvclNlcnZpY2UsXG4gICAgQGluamVjdChUWVBFUy5SYXRlTGltaXRTZXJ2aWNlKSBwcml2YXRlIHJhdGVMaW1pdFNlcnZpY2U6IFJhdGVMaW1pdFNlcnZpY2UsXG4gICAgQGluamVjdChUWVBFUy5Vc2VyUmVwb3NpdG9yeSkgcHJpdmF0ZSB1c2VyUmVwb3NpdG9yeTogSVVzZXJSZXBvc2l0b3J5LFxuICApIHt9XG5cbiAgYXN5bmMgZXhlY3V0ZShkYXRhOiB7IHVzZXJJZDogc3RyaW5nOyB0b2tlbjogc3RyaW5nOyBpcD86IHN0cmluZzsgdXNlckFnZW50Pzogc3RyaW5nIH0pIHtcbiAgICBjb25zdCB7IHVzZXJJZCwgdG9rZW4sIGlwLCB1c2VyQWdlbnQgfSA9IGRhdGE7XG5cbiAgICAvLyBSYXRlIExpbWl0OiA1IGF0dGVtcHRzIHBlciAxNSBtaW51dGVzIGZvciAyRkEgbG9naW5cbiAgICBhd2FpdCB0aGlzLnJhdGVMaW1pdFNlcnZpY2UuaW5jcmVtZW50QW5kQ2hlY2soYGxvZ2luXzJmYToke3VzZXJJZH1gLCA1LCAxNSAqIDYwKTtcblxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRCeUlkKHVzZXJJZCk7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgQXBwRXJyb3IoJ1VzZXIgbm90IGZvdW5kJywgNDA0LCAnVVNFUl9OT1RfRk9VTkQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZXIuaXNNZmFFbmFibGVkICYmICF1c2VyLmlzVHdvRmFjdG9yRW5hYmxlZCkge1xuICAgICAgLy8gSWYgTUZBIGlzIG5vdCBlbmFibGVkLCB3aHkgYXJlIHdlIGhlcmU/XG4gICAgICAvLyBNYXliZSB1c2VyIGRpc2FibGVkIGl0IGluIGFub3RoZXIgc2Vzc2lvbj9cbiAgICAgIC8vIFByb2NlZWQgd2l0aCBsb2dpbiBhbnl3YXkgZm9yIFVYIG9yIHRocm93P1xuICAgICAgLy8gQmV0dGVyIHRvIHRocm93IGFzIHRoaXMgZW5kcG9pbnQgZXhwZWN0cyAyRkEuXG4gICAgICB0aHJvdyBuZXcgQXBwRXJyb3IoJzJGQSBub3QgZW5hYmxlZCBmb3IgdXNlcicsIDQwMCwgJzJGQV9OT1RfRU5BQkxFRCcpO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSB0b2tlblxuICAgIGlmICghdXNlci50d29GYWN0b3JTZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBBcHBFcnJvcignMkZBIHNldHVwIGluY29tcGxldGUnLCA0MDAsICcyRkFfU0VUVVBfSU5DT01QTEVURScpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB0aGlzLnR3b0ZhY3RvclNlcnZpY2UudmVyaWZ5VE9UUFRva2VuKHVzZXJJZCwgdG9rZW4pO1xuXG4gICAgLy8gQWxzbyBjaGVjayBiYWNrdXAgY29kZXMgaWYgVE9UUCBmYWlsZWQ/XG4gICAgLy8gVGhlIHNlcnZpY2UgaGFzIHZlcmlmeUJhY2t1cENvZGUgbWV0aG9kLlxuICAgIC8vIExldCdzIGNoZWNrIGlmIGNvZGUgbGVuZ3RoIGlzIDYgKFRPVFApIG9yIGxvbmdlciAoTGlrZWx5IEJhY2t1cCBDb2RlKS5cbiAgICAvLyBVc3VhbGx5IFRPVFAgaXMgNiBkaWdpdHMuIEJhY2t1cCBjb2RlcyBhcmUgbG9uZ2VyLlxuICAgIGxldCBpc0JhY2t1cFZhbGlkID0gZmFsc2U7XG4gICAgaWYgKCFpc1ZhbGlkICYmIHRva2VuICYmIHRva2VuLmxlbmd0aCA+IDYpIHtcbiAgICAgIGlzQmFja3VwVmFsaWQgPSBhd2FpdCB0aGlzLnR3b0ZhY3RvclNlcnZpY2UudmVyaWZ5QmFja3VwQ29kZSh1c2VySWQsIHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVmFsaWQgJiYgIWlzQmFja3VwVmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBBcHBFcnJvcignSW52YWxpZCAyRkEgY29kZScsIDQwMSwgJ0lOVkFMSURfMkZBX0NPREUnKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSB0b2tlbnMgKER1cGxpY2F0ZWQgZnJvbSBMb2dpblVzZXJVc2VDYXNlKVxuICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHRoaXMuZ2VuZXJhdGVSZWZyZXNoVG9rZW5TdHJpbmcodXNlcik7XG4gICAgY29uc3QgbmV3UmVmcmVzaFRva2VucyA9IFtcbiAgICAgIC4uLih1c2VyLnJlZnJlc2hUb2tlbnMgPz8gW10pLFxuICAgICAge1xuICAgICAgICB0b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICBleHBpcmVzOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLFxuICAgICAgICBmYW1pbHlJZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgaXA6IGlwID8/ICd1bmtub3duJyxcbiAgICAgICAgdXNlckFnZW50OiB1c2VyQWdlbnQgPz8gJ3Vua25vd24nLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCB1cGRhdGVzOiBQYXJ0aWFsPElVc2VyPiA9IHtcbiAgICAgIGxvZ2luQXR0ZW1wdHM6IDAsXG4gICAgICBsb2NrVW50aWw6IHVuZGVmaW5lZCxcbiAgICAgIGxhc3RMb2dpbjogbmV3IERhdGUoKSxcbiAgICAgIHJlZnJlc2hUb2tlbnM6IG5ld1JlZnJlc2hUb2tlbnMubGVuZ3RoID4gMTAgPyBuZXdSZWZyZXNoVG9rZW5zLnNsaWNlKC0xMCkgOiBuZXdSZWZyZXNoVG9rZW5zLFxuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkudXBkYXRlKHVzZXIuaWQsIHVwZGF0ZXMpO1xuXG4gICAgY29uc3QgYWNjZXNzVG9rZW4gPSB0aGlzLmdlbmVyYXRlVG9rZW4odXNlciwgeyBpcCwgdXNlckFnZW50IH0pO1xuXG4gICAgLy8gQ2xlYXIgcmF0ZSBsaW1pdCBvbiBzdWNjZXNzXG4gICAgYXdhaXQgdGhpcy5yYXRlTGltaXRTZXJ2aWNlLnJlc2V0KGBsb2dpbl8yZmE6JHt1c2VySWR9YCk7XG5cbiAgICByZXR1cm4geyB1c2VyOiB1cGRhdGVkVXNlciA/PyB1c2VyLCB0b2tlbjogYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVRva2VuKHVzZXI6IGFueSwgZmluZ2VycHJpbnQ/OiB7IGlwPzogc3RyaW5nOyB1c2VyQWdlbnQ/OiBzdHJpbmcgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgcGF5bG9hZDogYW55ID0geyBpZDogdXNlci5faWQsIGVtYWlsOiB1c2VyLmVtYWlsLCByb2xlOiB1c2VyLnJvbGUgfTtcbiAgICBpZiAoZmluZ2VycHJpbnQpIHtcbiAgICAgIHBheWxvYWQuZmluZ2VycHJpbnQgPSB7XG4gICAgICAgIGlwOiBmaW5nZXJwcmludC5pcCA/PyAndW5rbm93bicsXG4gICAgICAgIHVzZXJBZ2VudDogZmluZ2VycHJpbnQudXNlckFnZW50ID8/ICd1bmtub3duJyxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBjb25maWcuand0LnNlY3JldCwgeyBleHBpcmVzSW46IGNvbmZpZy5qd3QuZXhwaXJlc0luIGFzIGFueSB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVSZWZyZXNoVG9rZW5TdHJpbmcodXNlcjogYW55LCBmYW1pbHlJZD86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgaWQ6IHVzZXIuX2lkLCBmYW1pbHlJZDogZmFtaWx5SWQgPz8gY3J5cHRvLnJhbmRvbVVVSUQoKSwgdHlwZTogJ3JlZnJlc2gnIH07XG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIGNvbmZpZy5qd3Quc2VjcmV0LCB7IGV4cGlyZXNJbjogJzdkJyB9KTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9