{"file":"C:\\Users\\Alejandro\\AIGestion\\backend\\src\\application\\usecases\\LoginUserUseCase.ts","mappings":"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","names":[],"sources":["C:\\Users\\Alejandro\\AIGestion\\backend\\src\\application\\usecases\\LoginUserUseCase.ts"],"sourcesContent":["import { injectable, inject } from 'inversify';\nimport bcrypt from 'bcryptjs';\nimport crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\nimport type { IUserRepository } from '../../infrastructure/repository/UserRepository';\nimport type { IUser } from '../../models/User';\nimport { TYPES } from '../../types';\nimport { AppError } from '../../utils/errors';\nimport { config } from '../../config';\n\n@injectable()\nexport class LoginUserUseCase {\n  constructor(@inject(TYPES.UserRepository) private userRepository: IUserRepository) {}\n\n  async execute(data: { email: string; password: string; ip?: string; userAgent?: string }) {\n    const { email, password, ip, userAgent } = data;\n    const user = await this.userRepository.findByEmail(email);\n    if (!user) {\n      throw new AppError('Credenciales inválidas', 401, 'AUTH_ERROR');\n    }\n    // lock check\n    if (user.lockUntil && user.lockUntil > new Date()) {\n      throw new AppError('Credenciales inválidas', 401, 'AUTH_ERROR');\n    }\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n      const loginAttempts = (user.loginAttempts ?? 0) + 1;\n      const updates: Partial<IUser> = { loginAttempts };\n\n      if (loginAttempts >= 5) {\n        updates.lockUntil = new Date(Date.now() + 30 * 60 * 1000);\n        updates.loginAttempts = 0;\n      }\n\n      await this.userRepository.update(user.id, updates);\n      throw new AppError('Credenciales inválidas', 401, 'AUTH_ERROR');\n    }\n\n    // success reset attempts\n    const refreshToken = this.generateRefreshTokenString(user);\n    const newRefreshTokens = [\n      ...(user.refreshTokens ?? []),\n      {\n        token: refreshToken,\n        expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n        familyId: crypto.randomUUID(),\n        ip: ip ?? 'unknown',\n        userAgent: userAgent ?? 'unknown',\n        createdAt: new Date(),\n      },\n    ];\n\n    const updates: Partial<IUser> = {\n      loginAttempts: 0,\n      lockUntil: undefined,\n      lastLogin: new Date(),\n      refreshTokens: newRefreshTokens.length > 10 ? newRefreshTokens.slice(-10) : newRefreshTokens,\n    };\n\n    const updatedUser = await this.userRepository.update(user.id, updates);\n\n    // Check for 2FA\n    if (user.isMfaEnabled || user.isTwoFactorEnabled) {\n      return {\n        user: { _id: user.id, email: user.email } as any,\n        mfaRequired: true,\n      };\n    }\n\n    const token = this.generateToken(user, { ip, userAgent });\n    return { user: updatedUser ?? user, token, refreshToken };\n  }\n\n  private generateToken(user: any, fingerprint?: { ip?: string; userAgent?: string }): string {\n    const payload: any = { id: user._id, email: user.email, role: user.role };\n    if (fingerprint) {\n      payload.fingerprint = {\n        ip: fingerprint.ip ?? 'unknown',\n        userAgent: fingerprint.userAgent ?? 'unknown',\n      };\n    }\n    return jwt.sign(payload, config.jwt.secret, { expiresIn: config.jwt.expiresIn as any });\n  }\n\n  private generateRefreshTokenString(user: any, familyId?: string): string {\n    const payload = { id: user._id, familyId: familyId ?? crypto.randomUUID(), type: 'refresh' };\n    return jwt.sign(payload, config.jwt.secret, { expiresIn: '7d' });\n  }\n}\n"],"version":3}