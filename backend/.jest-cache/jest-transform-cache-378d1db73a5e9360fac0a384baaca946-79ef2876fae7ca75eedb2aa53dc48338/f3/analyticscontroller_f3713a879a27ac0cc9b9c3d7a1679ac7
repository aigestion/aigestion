313278c8d6fba0d06fd6a0de0ae3361d
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAnalyticsOverview = getAnalyticsOverview;
exports.getUserActivity = getUserActivity;
exports.getSystemUsage = getSystemUsage;
exports.getErrorRates = getErrorRates;
exports.getDashboardData = getDashboardData;
exports.exportReport = exportReport;
const os_1 = __importDefault(require("os"));
const User_1 = require("../models/User");
const redis_1 = require("../utils/redis");
const stats_1 = require("../utils/stats");
/**
 * Get analytics overview
 */
async function getAnalyticsOverview(_req, res) {
    try {
        const cacheKey = 'analytics:overview:real';
        const cachedData = await (0, redis_1.getCache)(cacheKey);
        if (cachedData) {
            res.json(JSON.parse(cachedData));
            return;
        }
        // Real data from DB and stats
        const totalUsers = await User_1.User.countDocuments();
        const activeUsersInRange = await User_1.User.countDocuments({
            lastLogin: { $gte: new Date(Date.now() - 15 * 60 * 1000) }, // Active in last 15 mins
        });
        const overview = {
            activeUsers: activeUsersInRange || 1, // Fallback to 1 if empty for UI
            totalUsers,
            totalRequests: stats_1.stats.totalRequests,
            errorRate: stats_1.stats.totalRequests > 0
                ? parseFloat(((stats_1.stats.errorCount / stats_1.stats.totalRequests) * 100).toFixed(2))
                : 0,
            avgResponseTime: stats_1.stats.lastRequestTime,
            timestamp: Date.now(),
        };
        await (0, redis_1.setCache)(cacheKey, JSON.stringify(overview), 10);
        res.json(overview);
    }
    catch (error) {
        res.status(500).json({ error: 'Failed to get analytics overview' });
    }
}
/**
 * Get user activity
 */
async function getUserActivity(req, res) {
    try {
        const range = req.query.range || '24h';
        // In a real app we'd query an Activity model.
        // Here we generate a realistic trend based on total users.
        const totalUsers = await User_1.User.countDocuments();
        const activity = Array.from({ length: 24 }, (_, i) => ({
            hour: i,
            users: Math.floor(totalUsers * (0.1 + Math.random() * 0.2)),
            sessions: Math.floor(totalUsers * (0.15 + Math.random() * 0.3)),
        }));
        res.json({
            range,
            data: activity,
        });
    }
    catch (error) {
        res.status(500).json({ error: 'Failed to get user activity' });
    }
}
/**
 * Get system usage
 */
function getSystemUsage(_req, res) {
    try {
        const freeMem = os_1.default.freemem();
        const totalMem = os_1.default.totalmem();
        const loadAvg = os_1.default.loadavg()[0];
        const usage = {
            cpu: Array.from({ length: 60 }, () => parseFloat((loadAvg * 10 + Math.random() * 5).toFixed(1))),
            memory: Array.from({ length: 60 }, () => parseFloat((((totalMem - freeMem) / totalMem) * 100).toFixed(1))),
            network: Array.from({ length: 60 }, () => parseFloat((Math.random() * 10).toFixed(1))),
        };
        res.json(usage);
    }
    catch (error) {
        res.status(500).json({ error: 'Failed to get system usage' });
    }
}
/**
 * Get error rates
 */
function getErrorRates(_req, res) {
    try {
        const errors = {
            total: stats_1.stats.errorCount,
            byType: {
                '4xx': Math.floor(stats_1.stats.errorCount * 0.7),
                '5xx': Math.floor(stats_1.stats.errorCount * 0.3),
                timeout: 0,
            },
            trend: Array.from({ length: 24 }, () => Math.floor(Math.random() * 2)),
        };
        res.json(errors);
    }
    catch (error) {
        res.status(500).json({ error: 'Failed to get error rates' });
    }
}
/**
 * Get aggregated dashboard data (Revenue, User Growth, Conversions)
 */
async function getDashboardData(_req, res) {
    try {
        // In a real app, this would aggregate data from Orders, Users, and Events tables.
        // For now, we move the logic from the frontend hook to here to centralize it.
        // Revenue Data (12 months)
        const months = [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec',
        ];
        const revenue = months.map(month => ({
            name: month,
            value: Math.floor(Math.random() * 50000) + 20000 + Math.random() * 10000,
        }));
        // User Growth (14 days)
        const days = Array.from({ length: 14 }, (_, i) => `Day ${i + 1}`);
        let previous = 1000;
        const users = days.map(day => {
            previous = Math.floor(previous * (1 + (Math.random() * 0.1 - 0.02)));
            return { name: day, value: previous };
        });
        // Conversions
        const conversions = [
            { name: 'Visitors', value: 12000 + Math.floor(Math.random() * 2000) },
            { name: 'Signups', value: 4500 + Math.floor(Math.random() * 500) },
            { name: 'Active', value: 3200 + Math.floor(Math.random() * 300) },
            { name: 'Paying', value: 850 + Math.floor(Math.random() * 100) },
        ];
        res.json({
            revenue,
            users,
            conversions,
        });
    }
    catch (error) {
        res.status(500).json({ error: 'Failed to get dashboard data' });
    }
}
/**
 * Export analytics report as CSV
 */
async function exportReport(_req, res) {
    try {
        const timestamp = new Date().toISOString();
        let csv = `Report Generated,${timestamp}\n\n`;
        // Metrics Overview
        csv += 'SECTION,METRICS\n';
        csv += `Total Users,${await User_1.User.countDocuments()}\n`;
        csv += `Total Requests,${stats_1.stats.totalRequests}\n`;
        csv += `Error Rate,${((stats_1.stats.errorCount / (stats_1.stats.totalRequests || 1)) * 100).toFixed(2)}%\n`;
        csv += '\n';
        // Activity Sample
        csv += 'hour,users,sessions\n';
        for (let i = 0; i < 24; i++) {
            const users = Math.floor(Math.random() * 1000);
            csv += `${i}:00,${users},${Math.floor(users * 1.5)}\n`;
        }
        res.header('Content-Type', 'text/csv');
        res.attachment(`analytics_report_${Date.now()}.csv`);
        res.send(csv);
    }
    catch (error) {
        res.status(500).json({ error: 'Failed to export report' });
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxjb250cm9sbGVyc1xcYW5hbHl0aWNzLmNvbnRyb2xsZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFVQSxvREFpQ0M7QUFLRCwwQ0FvQkM7QUFLRCx3Q0FvQkM7QUFLRCxzQ0FnQkM7QUFJRCw0Q0FpREM7QUFLRCxvQ0F5QkM7QUFwTUQsNENBQW9CO0FBRXBCLHlDQUFzQztBQUN0QywwQ0FBb0Q7QUFDcEQsMENBQXVDO0FBRXZDOztHQUVHO0FBQ0ksS0FBSyxVQUFVLG9CQUFvQixDQUFDLElBQWEsRUFBRSxHQUFhO0lBQ3JFLElBQUksQ0FBQztRQUNILE1BQU0sUUFBUSxHQUFHLHlCQUF5QixDQUFDO1FBQzNDLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBQSxnQkFBUSxFQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTVDLElBQUksVUFBVSxFQUFFLENBQUM7WUFDZixHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNqQyxPQUFPO1FBQ1QsQ0FBQztRQUVELDhCQUE4QjtRQUM5QixNQUFNLFVBQVUsR0FBRyxNQUFNLFdBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUMvQyxNQUFNLGtCQUFrQixHQUFHLE1BQU0sV0FBSSxDQUFDLGNBQWMsQ0FBQztZQUNuRCxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSx5QkFBeUI7U0FDdEYsQ0FBQyxDQUFDO1FBRUgsTUFBTSxRQUFRLEdBQUc7WUFDZixXQUFXLEVBQUUsa0JBQWtCLElBQUksQ0FBQyxFQUFFLGdDQUFnQztZQUN0RSxVQUFVO1lBQ1YsYUFBYSxFQUFFLGFBQUssQ0FBQyxhQUFhO1lBQ2xDLFNBQVMsRUFDUCxhQUFLLENBQUMsYUFBYSxHQUFHLENBQUM7Z0JB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Q0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoQixDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNmLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLHlCQUF5QixFQUFFLENBQUMsQ0FBQztJQUM3RCxDQUFDO0FBQ0gsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFsZWphbmRyb1xcQUlHZXN0aW9uXFxiYWNrZW5kXFxzcmNcXGNvbnRyb2xsZXJzXFxhbmFseXRpY3MuY29udHJvbGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSAnZXhwcmVzcyc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vbW9kZWxzL1VzZXInO1xuaW1wb3J0IHsgZ2V0Q2FjaGUsIHNldENhY2hlIH0gZnJvbSAnLi4vdXRpbHMvcmVkaXMnO1xuaW1wb3J0IHsgc3RhdHMgfSBmcm9tICcuLi91dGlscy9zdGF0cyc7XG5cbi8qKlxuICogR2V0IGFuYWx5dGljcyBvdmVydmlld1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QW5hbHl0aWNzT3ZlcnZpZXcoX3JlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gJ2FuYWx5dGljczpvdmVydmlldzpyZWFsJztcbiAgICBjb25zdCBjYWNoZWREYXRhID0gYXdhaXQgZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuXG4gICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgIHJlcy5qc29uKEpTT04ucGFyc2UoY2FjaGVkRGF0YSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlYWwgZGF0YSBmcm9tIERCIGFuZCBzdGF0c1xuICAgIGNvbnN0IHRvdGFsVXNlcnMgPSBhd2FpdCBVc2VyLmNvdW50RG9jdW1lbnRzKCk7XG4gICAgY29uc3QgYWN0aXZlVXNlcnNJblJhbmdlID0gYXdhaXQgVXNlci5jb3VudERvY3VtZW50cyh7XG4gICAgICBsYXN0TG9naW46IHsgJGd0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDE1ICogNjAgKiAxMDAwKSB9LCAvLyBBY3RpdmUgaW4gbGFzdCAxNSBtaW5zXG4gICAgfSk7XG5cbiAgICBjb25zdCBvdmVydmlldyA9IHtcbiAgICAgIGFjdGl2ZVVzZXJzOiBhY3RpdmVVc2Vyc0luUmFuZ2UgfHwgMSwgLy8gRmFsbGJhY2sgdG8gMSBpZiBlbXB0eSBmb3IgVUlcbiAgICAgIHRvdGFsVXNlcnMsXG4gICAgICB0b3RhbFJlcXVlc3RzOiBzdGF0cy50b3RhbFJlcXVlc3RzLFxuICAgICAgZXJyb3JSYXRlOlxuICAgICAgICBzdGF0cy50b3RhbFJlcXVlc3RzID4gMFxuICAgICAgICAgID8gcGFyc2VGbG9hdCgoKHN0YXRzLmVycm9yQ291bnQgLyBzdGF0cy50b3RhbFJlcXVlc3RzKSAqIDEwMCkudG9GaXhlZCgyKSlcbiAgICAgICAgICA6IDAsXG4gICAgICBhdmdSZXNwb25zZVRpbWU6IHN0YXRzLmxhc3RSZXF1ZXN0VGltZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9O1xuXG4gICAgYXdhaXQgc2V0Q2FjaGUoY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KG92ZXJ2aWV3KSwgMTApO1xuICAgIHJlcy5qc29uKG92ZXJ2aWV3KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnRmFpbGVkIHRvIGdldCBhbmFseXRpY3Mgb3ZlcnZpZXcnIH0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHVzZXIgYWN0aXZpdHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJBY3Rpdml0eShyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYW5nZSA9IHJlcS5xdWVyeS5yYW5nZSB8fCAnMjRoJztcblxuICAgIC8vIEluIGEgcmVhbCBhcHAgd2UnZCBxdWVyeSBhbiBBY3Rpdml0eSBtb2RlbC5cbiAgICAvLyBIZXJlIHdlIGdlbmVyYXRlIGEgcmVhbGlzdGljIHRyZW5kIGJhc2VkIG9uIHRvdGFsIHVzZXJzLlxuICAgIGNvbnN0IHRvdGFsVXNlcnMgPSBhd2FpdCBVc2VyLmNvdW50RG9jdW1lbnRzKCk7XG4gICAgY29uc3QgYWN0aXZpdHkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNCB9LCAoXywgaSkgPT4gKHtcbiAgICAgIGhvdXI6IGksXG4gICAgICB1c2VyczogTWF0aC5mbG9vcih0b3RhbFVzZXJzICogKDAuMSArIE1hdGgucmFuZG9tKCkgKiAwLjIpKSxcbiAgICAgIHNlc3Npb25zOiBNYXRoLmZsb29yKHRvdGFsVXNlcnMgKiAoMC4xNSArIE1hdGgucmFuZG9tKCkgKiAwLjMpKSxcbiAgICB9KSk7XG5cbiAgICByZXMuanNvbih7XG4gICAgICByYW5nZSxcbiAgICAgIGRhdGE6IGFjdGl2aXR5LFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gZ2V0IHVzZXIgYWN0aXZpdHknIH0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHN5c3RlbSB1c2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3lzdGVtVXNhZ2UoX3JlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IHZvaWQge1xuICB0cnkge1xuICAgIGNvbnN0IGZyZWVNZW0gPSBvcy5mcmVlbWVtKCk7XG4gICAgY29uc3QgdG90YWxNZW0gPSBvcy50b3RhbG1lbSgpO1xuICAgIGNvbnN0IGxvYWRBdmcgPSBvcy5sb2FkYXZnKClbMF07XG5cbiAgICBjb25zdCB1c2FnZSA9IHtcbiAgICAgIGNwdTogQXJyYXkuZnJvbSh7IGxlbmd0aDogNjAgfSwgKCkgPT5cbiAgICAgICAgcGFyc2VGbG9hdCgobG9hZEF2ZyAqIDEwICsgTWF0aC5yYW5kb20oKSAqIDUpLnRvRml4ZWQoMSkpLFxuICAgICAgKSxcbiAgICAgIG1lbW9yeTogQXJyYXkuZnJvbSh7IGxlbmd0aDogNjAgfSwgKCkgPT5cbiAgICAgICAgcGFyc2VGbG9hdCgoKCh0b3RhbE1lbSAtIGZyZWVNZW0pIC8gdG90YWxNZW0pICogMTAwKS50b0ZpeGVkKDEpKSxcbiAgICAgICksXG4gICAgICBuZXR3b3JrOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2MCB9LCAoKSA9PiBwYXJzZUZsb2F0KChNYXRoLnJhbmRvbSgpICogMTApLnRvRml4ZWQoMSkpKSxcbiAgICB9O1xuXG4gICAgcmVzLmpzb24odXNhZ2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gZ2V0IHN5c3RlbSB1c2FnZScgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZXJyb3IgcmF0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yUmF0ZXMoX3JlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IHZvaWQge1xuICB0cnkge1xuICAgIGNvbnN0IGVycm9ycyA9IHtcbiAgICAgIHRvdGFsOiBzdGF0cy5lcnJvckNvdW50LFxuICAgICAgYnlUeXBlOiB7XG4gICAgICAgICc0eHgnOiBNYXRoLmZsb29yKHN0YXRzLmVycm9yQ291bnQgKiAwLjcpLFxuICAgICAgICAnNXh4JzogTWF0aC5mbG9vcihzdGF0cy5lcnJvckNvdW50ICogMC4zKSxcbiAgICAgICAgdGltZW91dDogMCxcbiAgICAgIH0sXG4gICAgICB0cmVuZDogQXJyYXkuZnJvbSh7IGxlbmd0aDogMjQgfSwgKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMikpLFxuICAgIH07XG5cbiAgICByZXMuanNvbihlcnJvcnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gZ2V0IGVycm9yIHJhdGVzJyB9KTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgYWdncmVnYXRlZCBkYXNoYm9hcmQgZGF0YSAoUmV2ZW51ZSwgVXNlciBHcm93dGgsIENvbnZlcnNpb25zKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGFzaGJvYXJkRGF0YShfcmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBhZ2dyZWdhdGUgZGF0YSBmcm9tIE9yZGVycywgVXNlcnMsIGFuZCBFdmVudHMgdGFibGVzLlxuICAgIC8vIEZvciBub3csIHdlIG1vdmUgdGhlIGxvZ2ljIGZyb20gdGhlIGZyb250ZW5kIGhvb2sgdG8gaGVyZSB0byBjZW50cmFsaXplIGl0LlxuXG4gICAgLy8gUmV2ZW51ZSBEYXRhICgxMiBtb250aHMpXG4gICAgY29uc3QgbW9udGhzID0gW1xuICAgICAgJ0phbicsXG4gICAgICAnRmViJyxcbiAgICAgICdNYXInLFxuICAgICAgJ0FwcicsXG4gICAgICAnTWF5JyxcbiAgICAgICdKdW4nLFxuICAgICAgJ0p1bCcsXG4gICAgICAnQXVnJyxcbiAgICAgICdTZXAnLFxuICAgICAgJ09jdCcsXG4gICAgICAnTm92JyxcbiAgICAgICdEZWMnLFxuICAgIF07XG4gICAgY29uc3QgcmV2ZW51ZSA9IG1vbnRocy5tYXAobW9udGggPT4gKHtcbiAgICAgIG5hbWU6IG1vbnRoLFxuICAgICAgdmFsdWU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMDAwKSArIDIwMDAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwLFxuICAgIH0pKTtcblxuICAgIC8vIFVzZXIgR3Jvd3RoICgxNCBkYXlzKVxuICAgIGNvbnN0IGRheXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNCB9LCAoXywgaSkgPT4gYERheSAke2kgKyAxfWApO1xuICAgIGxldCBwcmV2aW91cyA9IDEwMDA7XG4gICAgY29uc3QgdXNlcnMgPSBkYXlzLm1hcChkYXkgPT4ge1xuICAgICAgcHJldmlvdXMgPSBNYXRoLmZsb29yKHByZXZpb3VzICogKDEgKyAoTWF0aC5yYW5kb20oKSAqIDAuMSAtIDAuMDIpKSk7XG4gICAgICByZXR1cm4geyBuYW1lOiBkYXksIHZhbHVlOiBwcmV2aW91cyB9O1xuICAgIH0pO1xuXG4gICAgLy8gQ29udmVyc2lvbnNcbiAgICBjb25zdCBjb252ZXJzaW9ucyA9IFtcbiAgICAgIHsgbmFtZTogJ1Zpc2l0b3JzJywgdmFsdWU6IDEyMDAwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjAwMCkgfSxcbiAgICAgIHsgbmFtZTogJ1NpZ251cHMnLCB2YWx1ZTogNDUwMCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMCkgfSxcbiAgICAgIHsgbmFtZTogJ0FjdGl2ZScsIHZhbHVlOiAzMjAwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMzAwKSB9LFxuICAgICAgeyBuYW1lOiAnUGF5aW5nJywgdmFsdWU6IDg1MCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCkgfSxcbiAgICBdO1xuXG4gICAgcmVzLmpzb24oe1xuICAgICAgcmV2ZW51ZSxcbiAgICAgIHVzZXJzLFxuICAgICAgY29udmVyc2lvbnMsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0ZhaWxlZCB0byBnZXQgZGFzaGJvYXJkIGRhdGEnIH0pO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3J0IGFuYWx5dGljcyByZXBvcnQgYXMgQ1NWXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBvcnRSZXBvcnQoX3JlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBsZXQgY3N2ID0gYFJlcG9ydCBHZW5lcmF0ZWQsJHt0aW1lc3RhbXB9XFxuXFxuYDtcblxuICAgIC8vIE1ldHJpY3MgT3ZlcnZpZXdcbiAgICBjc3YgKz0gJ1NFQ1RJT04sTUVUUklDU1xcbic7XG4gICAgY3N2ICs9IGBUb3RhbCBVc2Vycywke2F3YWl0IFVzZXIuY291bnREb2N1bWVudHMoKX1cXG5gO1xuICAgIGNzdiArPSBgVG90YWwgUmVxdWVzdHMsJHtzdGF0cy50b3RhbFJlcXVlc3RzfVxcbmA7XG4gICAgY3N2ICs9IGBFcnJvciBSYXRlLCR7KChzdGF0cy5lcnJvckNvdW50IC8gKHN0YXRzLnRvdGFsUmVxdWVzdHMgfHwgMSkpICogMTAwKS50b0ZpeGVkKDIpfSVcXG5gO1xuICAgIGNzdiArPSAnXFxuJztcblxuICAgIC8vIEFjdGl2aXR5IFNhbXBsZVxuICAgIGNzdiArPSAnaG91cix1c2VycyxzZXNzaW9uc1xcbic7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICBjb25zdCB1c2VycyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApO1xuICAgICAgY3N2ICs9IGAke2l9OjAwLCR7dXNlcnN9LCR7TWF0aC5mbG9vcih1c2VycyAqIDEuNSl9XFxuYDtcbiAgICB9XG5cbiAgICByZXMuaGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9jc3YnKTtcbiAgICByZXMuYXR0YWNobWVudChgYW5hbHl0aWNzX3JlcG9ydF8ke0RhdGUubm93KCl9LmNzdmApO1xuICAgIHJlcy5zZW5kKGNzdik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0ZhaWxlZCB0byBleHBvcnQgcmVwb3J0JyB9KTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9