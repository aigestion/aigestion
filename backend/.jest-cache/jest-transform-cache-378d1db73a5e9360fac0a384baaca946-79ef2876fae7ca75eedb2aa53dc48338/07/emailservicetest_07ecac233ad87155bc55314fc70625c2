47992fc95a120508a065983adc5ae421
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
// Move mock implementation to allow accessing variables (or use factory correctly)
globals_1.jest.mock('nodemailer', () => {
    return {
        createTransport: globals_1.jest.fn(() => ({
            sendMail: mockSendMail,
            verify: mockVerify,
        })),
    };
});
require("reflect-metadata");
const nodemailer_1 = __importDefault(require("nodemailer"));
const typedi_1 = require("typedi");
const email_service_1 = require("../../services/email.service");
const mockSendMail = globals_1.jest.fn();
const mockVerify = globals_1.jest.fn();
describe('EmailService', () => {
    let service;
    beforeEach(() => {
        globals_1.jest.clearAllMocks();
        service = typedi_1.Container.get(email_service_1.EmailService);
    });
    it('should create transporter on initialization', () => {
        expect(nodemailer_1.default.createTransport).toHaveBeenCalled();
    });
    describe('verifyConnection', () => {
        it('should return true on success', async () => {
            mockVerify.mockResolvedValue(true);
            const result = await service.verifyConnection();
            expect(result).toBe(true);
        });
        it('should return false on failure', async () => {
            mockVerify.mockRejectedValue(new Error('Connection failed'));
            const result = await service.verifyConnection();
            expect(result).toBe(false);
        });
    });
    describe('sendEmail', () => {
        it('should send email successfully', async () => {
            mockSendMail.mockResolvedValue({ messageId: 'test-id' });
            await service.sendEmail('test@example.com', 'Test Subject', 'Test Body');
            expect(mockSendMail).toHaveBeenCalledWith(expect.objectContaining({
                to: 'test@example.com',
                subject: 'Test Subject',
                html: 'Test Body',
            }));
        });
        it('should throw error on failure', async () => {
            mockSendMail.mockRejectedValue(new Error('Send failed'));
            await expect(service.sendEmail('test', 'test', 'test')).rejects.toThrow('Send failed');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxfX3Rlc3RzX19cXHNlcnZpY2VzXFxlbWFpbC5zZXJ2aWNlLnRlc3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQSwyQ0FBcUM7QUFTckMsbUZBQW1GO0FBQ25GLGNBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTtJQUMzQixPQUFPO1FBQ0wsZUFBZSxFQUFFLGNBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUM5QixRQUFRLEVBQUUsWUFBWTtZQUN0QixNQUFNLEVBQUUsVUFBVTtTQUNuQixDQUFDLENBQUM7S0FDSixDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUM7QUFuQkgsNEJBQTBCO0FBRzFCLDREQUFvQztBQUNwQyxtQ0FBbUM7QUFFbkMsZ0VBQTREO0FBRTVELE1BQU0sWUFBWSxHQUFHLGNBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUMvQixNQUFNLFVBQVUsR0FBRyxjQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7QUFZN0IsUUFBUSxDQUFDLGNBQWMsRUFBRSxHQUFHLEVBQUU7SUFDNUIsSUFBSSxPQUFxQixDQUFDO0lBRTFCLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxjQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDckIsT0FBTyxHQUFHLGtCQUFTLENBQUMsR0FBRyxDQUFDLDRCQUFZLENBQUMsQ0FBQztJQUN4QyxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyw2Q0FBNkMsRUFBRSxHQUFHLEVBQUU7UUFDckQsTUFBTSxDQUFDLG9CQUFVLENBQUMsZUFBZSxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUN4RCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUU7UUFDaEMsRUFBRSxDQUFDLCtCQUErQixFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuQyxNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsZ0NBQWdDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDOUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztZQUM3RCxNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxXQUFXLEVBQUUsR0FBRyxFQUFFO1FBQ3pCLEVBQUUsQ0FBQyxnQ0FBZ0MsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM5QyxZQUFZLENBQUMsaUJBQWlCLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQztZQUN6RCxNQUFNLE9BQU8sQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsY0FBYyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ3pFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxvQkFBb0IsQ0FDdkMsTUFBTSxDQUFDLGdCQUFnQixDQUFDO2dCQUN0QixFQUFFLEVBQUUsa0JBQWtCO2dCQUN0QixPQUFPLEVBQUUsY0FBYztnQkFDdkIsSUFBSSxFQUFFLFdBQVc7YUFDbEIsQ0FBQyxDQUNILENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywrQkFBK0IsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM3QyxZQUFZLENBQUMsaUJBQWlCLENBQUMsSUFBSSxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztZQUN6RCxNQUFNLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pGLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFsZWphbmRyb1xcQUlHZXN0aW9uXFxiYWNrZW5kXFxzcmNcXF9fdGVzdHNfX1xcc2VydmljZXNcXGVtYWlsLnNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnO1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgbm9kZW1haWxlciBmcm9tICdub2RlbWFpbGVyJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ3R5cGVkaSc7XG5cbmltcG9ydCB7IEVtYWlsU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2VtYWlsLnNlcnZpY2UnO1xuXG5jb25zdCBtb2NrU2VuZE1haWwgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrVmVyaWZ5ID0gamVzdC5mbigpO1xuXG4vLyBNb3ZlIG1vY2sgaW1wbGVtZW50YXRpb24gdG8gYWxsb3cgYWNjZXNzaW5nIHZhcmlhYmxlcyAob3IgdXNlIGZhY3RvcnkgY29ycmVjdGx5KVxuamVzdC5tb2NrKCdub2RlbWFpbGVyJywgKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZVRyYW5zcG9ydDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgc2VuZE1haWw6IG1vY2tTZW5kTWFpbCxcbiAgICAgIHZlcmlmeTogbW9ja1ZlcmlmeSxcbiAgICB9KSksXG4gIH07XG59KTtcblxuZGVzY3JpYmUoJ0VtYWlsU2VydmljZScsICgpID0+IHtcbiAgbGV0IHNlcnZpY2U6IEVtYWlsU2VydmljZTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBzZXJ2aWNlID0gQ29udGFpbmVyLmdldChFbWFpbFNlcnZpY2UpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGNyZWF0ZSB0cmFuc3BvcnRlciBvbiBpbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICBleHBlY3Qobm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZlcmlmeUNvbm5lY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBvbiBzdWNjZXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1ZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UudmVyaWZ5Q29ubmVjdGlvbigpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIG9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVmVyaWZ5Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ29ubmVjdGlvbiBmYWlsZWQnKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLnZlcmlmeUNvbm5lY3Rpb24oKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnc2VuZEVtYWlsJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc2VuZCBlbWFpbCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU2VuZE1haWwubW9ja1Jlc29sdmVkVmFsdWUoeyBtZXNzYWdlSWQ6ICd0ZXN0LWlkJyB9KTtcbiAgICAgIGF3YWl0IHNlcnZpY2Uuc2VuZEVtYWlsKCd0ZXN0QGV4YW1wbGUuY29tJywgJ1Rlc3QgU3ViamVjdCcsICdUZXN0IEJvZHknKTtcbiAgICAgIGV4cGVjdChtb2NrU2VuZE1haWwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdG86ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBzdWJqZWN0OiAnVGVzdCBTdWJqZWN0JyxcbiAgICAgICAgICBodG1sOiAnVGVzdCBCb2R5JyxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1NlbmRNYWlsLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignU2VuZCBmYWlsZWQnKSk7XG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS5zZW5kRW1haWwoJ3Rlc3QnLCAndGVzdCcsICd0ZXN0JykpLnJlamVjdHMudG9UaHJvdygnU2VuZCBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==