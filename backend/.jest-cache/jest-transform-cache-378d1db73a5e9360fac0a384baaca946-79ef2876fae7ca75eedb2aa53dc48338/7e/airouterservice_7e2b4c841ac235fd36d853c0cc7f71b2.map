{"file":"C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\ai-router.service.ts","mappings":";;;;;;;;;AAAA,yCAAuC;AACvC,4CAAyC;AACzC,qDAAiD;AAEjD,IAAY,eAGX;AAHD,WAAY,eAAe;IACzB,oCAAiB,CAAA;IACjB,sCAAmB,CAAA;AACrB,CAAC,EAHW,eAAe,+BAAf,eAAe,QAG1B;AAQM,IAAM,qBAAqB,GAA3B,MAAM,qBAAqB;IAChC;;;;OAIG;IACK,aAAa,CAAC,KAAa;QACjC,MAAM,eAAe,GAAG;YACtB,SAAS;YACT,WAAW;YACX,aAAa;YACb,UAAU;YACV,OAAO;YACP,gBAAgB;YAChB,gBAAgB;YAChB,UAAU;SACX,CAAC;QAEF,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;QAC1C,MAAM,iBAAiB,GAAG,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;QAEvF,IAAI,SAAS,GAAG,EAAE,IAAI,iBAAiB,EAAE,CAAC;YACxC,OAAO,eAAe,CAAC,OAAO,CAAC;QACjC,CAAC;QAED,OAAO,eAAe,CAAC,MAAM,CAAC;IAChC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,eAAe,CAAC,KAAa;QACjC,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAE7C,uCAAuC;QACvC,MAAM,aAAa,GAAG,MAAM,8BAAa,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAC3D,MAAM,kBAAkB,GAAG,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC;QAEpD,IAAI,UAAU,KAAK,eAAe,CAAC,OAAO,IAAI,kBAAkB,EAAE,CAAC;YACjE,eAAM,CAAC,KAAK,CACV,EAAE,UAAU,EAAE,kBAAkB,EAAE,EAClC,qDAAqD,CACtD,CAAC;YACF,OAAO;gBACL,KAAK,EAAE,OAAO,CAAC,GAAG,CAAC,gBAAgB,IAAI,qBAAqB;gBAC5D,QAAQ,EAAE,QAAQ;aACnB,CAAC;QACJ,CAAC;QAED,eAAM,CAAC,KAAK,CAAC,EAAE,UAAU,EAAE,EAAE,iDAAiD,CAAC,CAAC;QAChF,OAAO;YACL,KAAK,EAAE,OAAO,CAAC,GAAG,CAAC,eAAe,IAAI,eAAe;YACrD,QAAQ,EAAE,QAAQ;SACnB,CAAC;IACJ,CAAC;CACF,CAAA;AAvDY,sDAAqB;gCAArB,qBAAqB;IADjC,IAAA,sBAAU,GAAE;GACA,qBAAqB,CAuDjC;AAEY,QAAA,QAAQ,GAAG,IAAI,qBAAqB,EAAE,CAAC","names":[],"sources":["C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\ai-router.service.ts"],"sourcesContent":["import { injectable } from 'inversify';\nimport { logger } from '../utils/logger';\nimport { vectorService } from './vector.service';\n\nexport enum ModelComplexity {\n  SIMPLE = 'simple',\n  COMPLEX = 'complex',\n}\n\nexport interface AIRoute {\n  model: string;\n  provider: 'openai' | 'anthropic' | 'google';\n}\n\n@injectable()\nexport class SemanticRouterService {\n  /**\n   * Classify query complexity\n   * In a production scenario, this might use embeddings or a small local model.\n   * For this implementation, we use a heuristic-based approach.\n   */\n  private classifyQuery(query: string): ModelComplexity {\n    const complexKeywords = [\n      'analyze',\n      'architect',\n      'performance',\n      'optimize',\n      'debug',\n      'explain deeply',\n      'security audit',\n      'refactor',\n    ];\n\n    const wordCount = query.split(' ').length;\n    const hasComplexKeyword = complexKeywords.some(kw => query.toLowerCase().includes(kw));\n\n    if (wordCount > 30 || hasComplexKeyword) {\n      return ModelComplexity.COMPLEX;\n    }\n\n    return ModelComplexity.SIMPLE;\n  }\n\n  /**\n   * Get the optimal route for a given query\n   */\n  async getOptimalRoute(query: string): Promise<AIRoute> {\n    const complexity = this.classifyQuery(query);\n\n    // Phase 14: Enhanced Context Awareness\n    const memoryContext = await vectorService.search(query, 1);\n    const hasLongTermContext = memoryContext.length > 0;\n\n    if (complexity === ModelComplexity.COMPLEX || hasLongTermContext) {\n      logger.debug(\n        { complexity, hasLongTermContext },\n        'Routing to high-intelligence model (GPT-4/Claude-3)',\n      );\n      return {\n        model: process.env.AI_MODEL_COMPLEX || 'gpt-4-turbo-preview',\n        provider: 'openai',\n      };\n    }\n\n    logger.debug({ complexity }, 'Routing to cost-efficient model (GPT-3.5/Haiku)');\n    return {\n      model: process.env.AI_MODEL_SIMPLE || 'gpt-3.5-turbo',\n      provider: 'openai',\n    };\n  }\n}\n\nexport const aiRouter = new SemanticRouterService();\n"],"version":3}