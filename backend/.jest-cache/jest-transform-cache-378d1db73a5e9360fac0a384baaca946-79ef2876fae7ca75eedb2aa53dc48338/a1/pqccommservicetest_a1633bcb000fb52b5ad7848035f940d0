9fa6fe11422c654eb9c93b3df885cff0
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const pqc_comm_service_1 = require("../src/services/pqc-comm.service");
const kyber = __importStar(require("crystals-kyber"));
const nacl = __importStar(require("tweetnacl"));
const node_crypto_1 = __importDefault(require("node:crypto"));
describe('PQCCommService Hybrid Handshake', () => {
    let pqcService;
    beforeEach(() => {
        pqcService = new pqc_comm_service_1.PQCCommService();
    });
    it('should derive the same symmetric key on both sides', async () => {
        // 1. Server generates its hybrid keys
        const serverKeys = await pqcService.generateHandshakeKeys();
        // 2. Client simulates receiving server's public keys
        const clientClassicKeys = nacl.box.keyPair();
        const [clientCiphertext, clientKyberSS] = kyber.Encrypt768(Buffer.from(serverKeys.pqc.public, 'hex'));
        const clientClassicSS = nacl.box.before(Buffer.from(serverKeys.classic.public, 'hex'), clientClassicKeys.secretKey);
        // Client-side derivation (simulated manually to match service logic)
        const combinedClient = Buffer.concat([Buffer.from(clientClassicSS), Buffer.from(clientKyberSS)]);
        const clientDerivedKey = node_crypto_1.default.createHash('sha256').update(combinedClient).digest('hex');
        // 3. Server receives client's public keys and ciphertext
        const serverDerivedKey = await pqcService.deriveSymmetricKey(serverKeys.classic.private, Buffer.from(clientClassicKeys.publicKey).toString('hex'), serverKeys.pqc.private, Buffer.from(clientCiphertext).toString('hex'));
        // 4. ASSERT: Both keys must match
        expect(serverDerivedKey).toBe(clientDerivedKey);
        console.log('âœ… Hybrid PQC Key Derivation Verified:', serverDerivedKey);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xccHFjLWNvbW0uc2VydmljZS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNEJBQTBCO0FBQzFCLHVFQUFrRTtBQUNsRSxzREFBd0M7QUFDeEMsZ0RBQWtDO0FBQ2xDLDhEQUFpQztBQUVqQyxRQUFRLENBQUMsaUNBQWlDLEVBQUUsR0FBRyxFQUFFO0lBQy9DLElBQUksVUFBMEIsQ0FBQztJQUUvQixVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsVUFBVSxHQUFHLElBQUksaUNBQWMsRUFBRSxDQUFDO0lBQ3BDLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLG9EQUFvRCxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ2xFLHNDQUFzQztRQUN0QyxNQUFNLFVBQVUsR0FBRyxNQUFNLFVBQVUsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBRTVELHFEQUFxRDtRQUNyRCxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDN0MsTUFBTSxDQUFDLGdCQUFnQixFQUFFLGFBQWEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBRXRHLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUNyQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUM3QyxpQkFBaUIsQ0FBQyxTQUFTLENBQzVCLENBQUM7UUFFRixxRUFBcUU7UUFDckUsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakcsTUFBTSxnQkFBZ0IsR0FBRyxxQkFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTFGLHlEQUF5RDtRQUN6RCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sVUFBVSxDQUFDLGtCQUFrQixDQUMxRCxVQUFVLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFDMUIsTUFBTSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQ3hELFVBQVUsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUN0QixNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUM5QyxDQUFDO1FBRUYsa0NBQWtDO1FBQ2xDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ2hELE9BQU8sQ0FBQyxHQUFHLENBQUMsdUNBQXVDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUN6RSxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXHBxYy1jb21tLnNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBQUUNDb21tU2VydmljZSB9IGZyb20gJy4uL3NyYy9zZXJ2aWNlcy9wcWMtY29tbS5zZXJ2aWNlJztcclxuaW1wb3J0ICogYXMga3liZXIgZnJvbSAnY3J5c3RhbHMta3liZXInO1xyXG5pbXBvcnQgKiBhcyBuYWNsIGZyb20gJ3R3ZWV0bmFjbCc7XHJcbmltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xyXG5cclxuZGVzY3JpYmUoJ1BRQ0NvbW1TZXJ2aWNlIEh5YnJpZCBIYW5kc2hha2UnLCAoKSA9PiB7XHJcbiAgbGV0IHBxY1NlcnZpY2U6IFBRQ0NvbW1TZXJ2aWNlO1xyXG5cclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIHBxY1NlcnZpY2UgPSBuZXcgUFFDQ29tbVNlcnZpY2UoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBkZXJpdmUgdGhlIHNhbWUgc3ltbWV0cmljIGtleSBvbiBib3RoIHNpZGVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gMS4gU2VydmVyIGdlbmVyYXRlcyBpdHMgaHlicmlkIGtleXNcclxuICAgIGNvbnN0IHNlcnZlcktleXMgPSBhd2FpdCBwcWNTZXJ2aWNlLmdlbmVyYXRlSGFuZHNoYWtlS2V5cygpO1xyXG4gICAgXHJcbiAgICAvLyAyLiBDbGllbnQgc2ltdWxhdGVzIHJlY2VpdmluZyBzZXJ2ZXIncyBwdWJsaWMga2V5c1xyXG4gICAgY29uc3QgY2xpZW50Q2xhc3NpY0tleXMgPSBuYWNsLmJveC5rZXlQYWlyKCk7XHJcbiAgICBjb25zdCBbY2xpZW50Q2lwaGVydGV4dCwgY2xpZW50S3liZXJTU10gPSBreWJlci5FbmNyeXB0NzY4KEJ1ZmZlci5mcm9tKHNlcnZlcktleXMucHFjLnB1YmxpYywgJ2hleCcpKTtcclxuICAgIFxyXG4gICAgY29uc3QgY2xpZW50Q2xhc3NpY1NTID0gbmFjbC5ib3guYmVmb3JlKFxyXG4gICAgICBCdWZmZXIuZnJvbShzZXJ2ZXJLZXlzLmNsYXNzaWMucHVibGljLCAnaGV4JyksXHJcbiAgICAgIGNsaWVudENsYXNzaWNLZXlzLnNlY3JldEtleVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8gQ2xpZW50LXNpZGUgZGVyaXZhdGlvbiAoc2ltdWxhdGVkIG1hbnVhbGx5IHRvIG1hdGNoIHNlcnZpY2UgbG9naWMpXHJcbiAgICBjb25zdCBjb21iaW5lZENsaWVudCA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKGNsaWVudENsYXNzaWNTUyksIEJ1ZmZlci5mcm9tKGNsaWVudEt5YmVyU1MpXSk7XHJcbiAgICBjb25zdCBjbGllbnREZXJpdmVkS2V5ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShjb21iaW5lZENsaWVudCkuZGlnZXN0KCdoZXgnKTtcclxuXHJcbiAgICAvLyAzLiBTZXJ2ZXIgcmVjZWl2ZXMgY2xpZW50J3MgcHVibGljIGtleXMgYW5kIGNpcGhlcnRleHRcclxuICAgIGNvbnN0IHNlcnZlckRlcml2ZWRLZXkgPSBhd2FpdCBwcWNTZXJ2aWNlLmRlcml2ZVN5bW1ldHJpY0tleShcclxuICAgICAgc2VydmVyS2V5cy5jbGFzc2ljLnByaXZhdGUsXHJcbiAgICAgIEJ1ZmZlci5mcm9tKGNsaWVudENsYXNzaWNLZXlzLnB1YmxpY0tleSkudG9TdHJpbmcoJ2hleCcpLFxyXG4gICAgICBzZXJ2ZXJLZXlzLnBxYy5wcml2YXRlLFxyXG4gICAgICBCdWZmZXIuZnJvbShjbGllbnRDaXBoZXJ0ZXh0KS50b1N0cmluZygnaGV4JylcclxuICAgICk7XHJcblxyXG4gICAgLy8gNC4gQVNTRVJUOiBCb3RoIGtleXMgbXVzdCBtYXRjaFxyXG4gICAgZXhwZWN0KHNlcnZlckRlcml2ZWRLZXkpLnRvQmUoY2xpZW50RGVyaXZlZEtleSk7XHJcbiAgICBjb25zb2xlLmxvZygn4pyFIEh5YnJpZCBQUUMgS2V5IERlcml2YXRpb24gVmVyaWZpZWQ6Jywgc2VydmVyRGVyaXZlZEtleSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwidmVyc2lvbiI6M30=