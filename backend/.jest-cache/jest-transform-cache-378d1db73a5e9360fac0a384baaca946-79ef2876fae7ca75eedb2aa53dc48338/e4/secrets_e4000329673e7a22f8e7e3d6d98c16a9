9f8634e4721a448fffc751d093cf96a8
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadSecrets = loadSecrets;
exports.deriveMissionKey = deriveMissionKey;
const secret_manager_1 = require("@google-cloud/secret-manager");
const node_crypto_1 = require("node:crypto");
const node_util_1 = require("node:util");
const logger_1 = require("./logger");
const hkdfAsync = (0, node_util_1.promisify)(node_crypto_1.hkdf);
async function loadSecrets() {
    // Only fetching secrets in production or if explicitly enabled
    // We skip if we are in CI/CD (GITHUB_ACTIONS) unless specifically required
    if (process.env.NODE_ENV !== 'production' && process.env.ENABLE_GCP_SECRETS !== 'true') {
        logger_1.logger.info('Skipping Google Secret Manager (Dev mode)');
        return;
    }
    if (!process.env.GOOGLE_CLOUD_PROJECT_ID) {
        logger_1.logger.warn('Skipping Secret Manager: GOOGLE_CLOUD_PROJECT_ID not set');
        return;
    }
    const client = new secret_manager_1.SecretManagerServiceClient();
    const projectId = process.env.GOOGLE_CLOUD_PROJECT_ID;
    // List of critical secrets to fetch
    // Add new secrets here as needed
    const secretNames = [
        'MONGODB_URI',
        'GEMINI_API_KEY',
        'MONGO_ROOT_PASSWORD',
        'JWT_SECRET',
        'STRIPE_SECRET_KEY',
        'STRIPE_WEBHOOK_SECRET',
        'ML_SERVICE_API_KEY',
    ];
    logger_1.logger.info(`Fetching ${secretNames.length} secrets from GCP Secret Manager...`);
    const results = await Promise.allSettled(secretNames.map(async (name) => {
        try {
            const [version] = await client.accessSecretVersion({
                name: `projects/${projectId}/secrets/${name}/versions/latest`,
            });
            const payload = version.payload?.data?.toString();
            if (payload) {
                process.env[name] = payload;
                return name;
            }
            else {
                throw new Error('Empty payload');
            }
        }
        catch (err) {
            // Don't crash, just log warning. Some secrets might not exist yet.
            // We throw so Promise.allSettled marks as rejected
            throw new Error(`Failed to fetch ${name}: ${err.message}`);
        }
    }));
    const loaded = results.filter(r => r.status === 'fulfilled').map((r) => r.value);
    const failed = results.filter(r => r.status === 'rejected').map((r) => r.reason.message);
    if (loaded.length > 0) {
        logger_1.logger.info(`✅ Successfully loaded secrets: ${loaded.join(', ')}`);
    }
    if (failed.length > 0) {
        // We log warnings but don't crash - let env.schema validation catch missing required envs later
        logger_1.logger.warn(`⚠️  Failed to load some secrets:\n${failed.join('\n')}`);
    }
}
/**
 * Derives a mission-specific sub-key from a Master Sovereign Seed using HKDF.
 * This ensures that even if one mission key is compromised, others remain secure.
 */
async function deriveMissionKey(masterSeed, missionId, userId) {
    const salt = Buffer.from(userId);
    const info = `AIG_SOVEREIGN_MISSION_${missionId}`;
    const keyLength = 32; // AES-256
    try {
        const derivedKey = await hkdfAsync('sha256', Buffer.from(masterSeed), salt, Buffer.from(info), keyLength);
        return Buffer.from(derivedKey);
    }
    catch (error) {
        logger_1.logger.error('[Secrets] HKDF derivation failed:', error);
        throw new Error('Failed to derive Sovereign mission key');
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFx1dGlsc1xcc2VjcmV0cy50cyIsIm1hcHBpbmdzIjoiOztBQU9BLGtDQTZEQztBQU1ELDRDQXNCQztBQWhHRCxpRUFBMEU7QUFDMUUsNkNBQW1DO0FBQ25DLHlDQUFzQztBQUN0QyxxQ0FBa0M7QUFFbEMsTUFBTSxTQUFTLEdBQUcsSUFBQSxxQkFBUyxFQUFDLGtCQUFJLENBQUMsQ0FBQztBQUUzQixLQUFLLFVBQVUsV0FBVztJQUMvQiwrREFBK0Q7SUFDL0QsMkVBQTJFO0lBQzNFLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEtBQUssWUFBWSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEtBQUssTUFBTSxFQUFFLENBQUM7UUFDdkYsZUFBTSxDQUFDLElBQUksQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO1FBQ3pELE9BQU87SUFDVCxDQUFDO0lBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztRQUN6QyxlQUFNLENBQUMsSUFBSSxDQUFDLDBEQUEwRCxDQUFDLENBQUM7UUFDeEUsT0FBTztJQUNULENBQUM7SUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLDJDQUEwQixFQUFFLENBQUM7SUFDaEQsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQztJQUV0RCxvQ0FBb0M7SUFDcEMsaUNBQWlDO0lBQ2pDLE1BQU0sV0FBVyxHQUFHO1FBQ2xCLGFBQWE7UUFDYixnQkFBZ0I7UUFDaEIscUJBQXFCO1FBQ3JCLFlBQVk7UUFDWixtQkFBbUI7UUFDbkIsdUJBQXVCO1FBQ3ZCLG9CQUFvQjtLQUNyQixDQUFDO0lBRUYsZUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLFdBQVcsQ0FBQyxNQUFNLHFDQUFxQyxDQUFDLENBQUM7SUFFakYsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsVUFBVSxDQUN0QyxXQUFXLENBQUMs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R2VzdGlvblxcYmFja2VuZFxcc3JjXFx1dGlsc1xcc2VjcmV0cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZWNyZXRNYW5hZ2VyU2VydmljZUNsaWVudCB9IGZyb20gJ0Bnb29nbGUtY2xvdWQvc2VjcmV0LW1hbmFnZXInO1xuaW1wb3J0IHsgaGtkZiB9IGZyb20gJ25vZGU6Y3J5cHRvJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbmNvbnN0IGhrZGZBc3luYyA9IHByb21pc2lmeShoa2RmKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRTZWNyZXRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBPbmx5IGZldGNoaW5nIHNlY3JldHMgaW4gcHJvZHVjdGlvbiBvciBpZiBleHBsaWNpdGx5IGVuYWJsZWRcbiAgLy8gV2Ugc2tpcCBpZiB3ZSBhcmUgaW4gQ0kvQ0QgKEdJVEhVQl9BQ1RJT05TKSB1bmxlc3Mgc3BlY2lmaWNhbGx5IHJlcXVpcmVkXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHByb2Nlc3MuZW52LkVOQUJMRV9HQ1BfU0VDUkVUUyAhPT0gJ3RydWUnKSB7XG4gICAgbG9nZ2VyLmluZm8oJ1NraXBwaW5nIEdvb2dsZSBTZWNyZXQgTWFuYWdlciAoRGV2IG1vZGUpJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFwcm9jZXNzLmVudi5HT09HTEVfQ0xPVURfUFJPSkVDVF9JRCkge1xuICAgIGxvZ2dlci53YXJuKCdTa2lwcGluZyBTZWNyZXQgTWFuYWdlcjogR09PR0xFX0NMT1VEX1BST0pFQ1RfSUQgbm90IHNldCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudCA9IG5ldyBTZWNyZXRNYW5hZ2VyU2VydmljZUNsaWVudCgpO1xuICBjb25zdCBwcm9qZWN0SWQgPSBwcm9jZXNzLmVudi5HT09HTEVfQ0xPVURfUFJPSkVDVF9JRDtcblxuICAvLyBMaXN0IG9mIGNyaXRpY2FsIHNlY3JldHMgdG8gZmV0Y2hcbiAgLy8gQWRkIG5ldyBzZWNyZXRzIGhlcmUgYXMgbmVlZGVkXG4gIGNvbnN0IHNlY3JldE5hbWVzID0gW1xuICAgICdNT05HT0RCX1VSSScsXG4gICAgJ0dFTUlOSV9BUElfS0VZJyxcbiAgICAnTU9OR09fUk9PVF9QQVNTV09SRCcsXG4gICAgJ0pXVF9TRUNSRVQnLFxuICAgICdTVFJJUEVfU0VDUkVUX0tFWScsXG4gICAgJ1NUUklQRV9XRUJIT09LX1NFQ1JFVCcsXG4gICAgJ01MX1NFUlZJQ0VfQVBJX0tFWScsXG4gIF07XG5cbiAgbG9nZ2VyLmluZm8oYEZldGNoaW5nICR7c2VjcmV0TmFtZXMubGVuZ3RofSBzZWNyZXRzIGZyb20gR0NQIFNlY3JldCBNYW5hZ2VyLi4uYCk7XG5cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICBzZWNyZXROYW1lcy5tYXAoYXN5bmMgbmFtZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbdmVyc2lvbl0gPSBhd2FpdCBjbGllbnQuYWNjZXNzU2VjcmV0VmVyc2lvbih7XG4gICAgICAgICAgbmFtZTogYHByb2plY3RzLyR7cHJvamVjdElkfS9zZWNyZXRzLyR7bmFtZX0vdmVyc2lvbnMvbGF0ZXN0YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB2ZXJzaW9uLnBheWxvYWQ/LmRhdGE/LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnZbbmFtZV0gPSBwYXlsb2FkO1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgcGF5bG9hZCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAvLyBEb24ndCBjcmFzaCwganVzdCBsb2cgd2FybmluZy4gU29tZSBzZWNyZXRzIG1pZ2h0IG5vdCBleGlzdCB5ZXQuXG4gICAgICAgIC8vIFdlIHRocm93IHNvIFByb21pc2UuYWxsU2V0dGxlZCBtYXJrcyBhcyByZWplY3RlZFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke25hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIGNvbnN0IGxvYWRlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKS5tYXAoKHI6IGFueSkgPT4gci52YWx1ZSk7XG4gIGNvbnN0IGZhaWxlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09ICdyZWplY3RlZCcpLm1hcCgocjogYW55KSA9PiByLnJlYXNvbi5tZXNzYWdlKTtcblxuICBpZiAobG9hZGVkLmxlbmd0aCA+IDApIHtcbiAgICBsb2dnZXIuaW5mbyhg4pyFIFN1Y2Nlc3NmdWxseSBsb2FkZWQgc2VjcmV0czogJHtsb2FkZWQuam9pbignLCAnKX1gKTtcbiAgfVxuICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAvLyBXZSBsb2cgd2FybmluZ3MgYnV0IGRvbid0IGNyYXNoIC0gbGV0IGVudi5zY2hlbWEgdmFsaWRhdGlvbiBjYXRjaCBtaXNzaW5nIHJlcXVpcmVkIGVudnMgbGF0ZXJcbiAgICBsb2dnZXIud2Fybihg4pqg77iPICBGYWlsZWQgdG8gbG9hZCBzb21lIHNlY3JldHM6XFxuJHtmYWlsZWQuam9pbignXFxuJyl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXJpdmVzIGEgbWlzc2lvbi1zcGVjaWZpYyBzdWIta2V5IGZyb20gYSBNYXN0ZXIgU292ZXJlaWduIFNlZWQgdXNpbmcgSEtERi5cbiAqIFRoaXMgZW5zdXJlcyB0aGF0IGV2ZW4gaWYgb25lIG1pc3Npb24ga2V5IGlzIGNvbXByb21pc2VkLCBvdGhlcnMgcmVtYWluIHNlY3VyZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcml2ZU1pc3Npb25LZXkoXG4gIG1hc3RlclNlZWQ6IHN0cmluZyxcbiAgbWlzc2lvbklkOiBzdHJpbmcsXG4gIHVzZXJJZDogc3RyaW5nLFxuKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgY29uc3Qgc2FsdCA9IEJ1ZmZlci5mcm9tKHVzZXJJZCk7XG4gIGNvbnN0IGluZm8gPSBgQUlHX1NPVkVSRUlHTl9NSVNTSU9OXyR7bWlzc2lvbklkfWA7XG4gIGNvbnN0IGtleUxlbmd0aCA9IDMyOyAvLyBBRVMtMjU2XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gYXdhaXQgaGtkZkFzeW5jKFxuICAgICAgJ3NoYTI1NicsXG4gICAgICBCdWZmZXIuZnJvbShtYXN0ZXJTZWVkKSxcbiAgICAgIHNhbHQsXG4gICAgICBCdWZmZXIuZnJvbShpbmZvKSxcbiAgICAgIGtleUxlbmd0aCxcbiAgICApO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShkZXJpdmVkS2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ1tTZWNyZXRzXSBIS0RGIGRlcml2YXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZXJpdmUgU292ZXJlaWduIG1pc3Npb24ga2V5Jyk7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==