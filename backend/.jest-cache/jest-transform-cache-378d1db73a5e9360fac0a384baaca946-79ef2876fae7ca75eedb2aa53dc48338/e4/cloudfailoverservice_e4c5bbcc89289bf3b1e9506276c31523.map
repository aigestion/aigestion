{"file":"C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\cloud-failover.service.ts","mappings":";;;;;;;;;;;;AAAA,yCAAuC;AACvC,8FAA2F;AAC3F,4CAAyC;AAEzC,IAAY,aAGX;AAHD,WAAY,aAAa;IACvB,4BAAW,CAAA;IACX,4BAAW,CAAA;AACb,CAAC,EAHW,aAAa,6BAAb,aAAa,QAGxB;AAGM,IAAM,oBAAoB,GAA1B,MAAM,oBAAoB;IACvB,eAAe,GAAkB,aAAa,CAAC,GAAG,CAAC;IACnD,OAAO,CAAM;IAErB;QACE,iEAAiE;QACjE,IAAI,CAAC,OAAO,GAAG,6CAAqB,CAAC,MAAM,CAAC,KAAK,IAAI,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;YAC7E,IAAI,EAAE,kBAAkB;YACxB,wBAAwB,EAAE,EAAE;YAC5B,YAAY,EAAE,KAAK;SACpB,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;QACvE,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1E,CAAC;IAED;;OAEG;IACI,kBAAkB;QACvB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,OAAO,CAAI,KAAuB,EAAE,KAAuB;QACtE,IAAI,IAAI,CAAC,eAAe,KAAK,aAAa,CAAC,GAAG,EAAE,CAAC;YAC/C,OAAO,KAAK,EAAE,CAAC;QACjB,CAAC;QAED,IAAI,CAAC;YACH,0BAA0B;YAC1B,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QACnC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,IAAI,CAAC,kEAAkE,KAAK,EAAE,CAAC,CAAC;YACvF,+EAA+E;YAC/E,sCAAsC;YACtC,OAAO,KAAK,EAAE,CAAC;QACjB,CAAC;IACH,CAAC;IAEO,KAAK,CAAC,cAAc;QAC1B,gEAAgE;QAChE,gDAAgD;QAChD,iBAAiB;QACjB,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,eAAe,CAAC,EAAiB;QACvC,IAAI,IAAI,CAAC,eAAe,KAAK,EAAE,EAAE,CAAC;YAChC,eAAM,CAAC,IAAI,CACT,gDAAgD,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,OAAO,EAAE,CAAC,WAAW,EAAE,EAAE,CAC5G,CAAC;YACF,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;QAC5B,CAAC;IACH,CAAC;CACF,CAAA;AA3DY,oDAAoB;+BAApB,oBAAoB;IADhC,IAAA,sBAAU,GAAE;;GACA,oBAAoB,CA2DhC","names":[],"sources":["C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\cloud-failover.service.ts"],"sourcesContent":["import { injectable } from 'inversify';\nimport { CircuitBreakerFactory } from '../infrastructure/resilience/CircuitBreakerFactory';\nimport { logger } from '../utils/logger';\n\nexport enum CloudProvider {\n  GCP = 'gcp',\n  AWS = 'aws',\n}\n\n@injectable()\nexport class CloudFailoverService {\n  private currentProvider: CloudProvider = CloudProvider.GCP;\n  private breaker: any;\n\n  constructor() {\n    // Circuit Breaker monitors GCP health. If it opens, we failover.\n    this.breaker = CircuitBreakerFactory.create(async () => this.checkGCPHealth(), {\n      name: 'GCP-Health-Check',\n      errorThresholdPercentage: 50,\n      resetTimeout: 30000,\n    });\n\n    this.breaker.on('open', () => this.triggerFailover(CloudProvider.AWS));\n    this.breaker.on('close', () => this.triggerFailover(CloudProvider.GCP));\n  }\n\n  /**\n   * returns the current active cloud provider.\n   */\n  public getCurrentProvider(): CloudProvider {\n    return this.currentProvider;\n  }\n\n  /**\n   * Executes a critical operation with automatic failover logic.\n   * @param gcpFn Function to execute on GCP\n   * @param awsFn Function to execute on AWS\n   */\n  public async execute<T>(gcpFn: () => Promise<T>, awsFn: () => Promise<T>): Promise<T> {\n    if (this.currentProvider === CloudProvider.AWS) {\n      return awsFn();\n    }\n\n    try {\n      // Attempt GCP via breaker\n      return await this.breaker.fire();\n    } catch (error) {\n      logger.warn(`[Failover] GCP call failed, attempting fallback to AWS. Error: ${error}`);\n      // Force failover state? Maybe not for single error, but breaker handles state.\n      // For now, simple fallback execution:\n      return awsFn();\n    }\n  }\n\n  private async checkGCPHealth(): Promise<boolean> {\n    // In a real app, ping a GCP metadata server or health endpoint.\n    // Simulation: Random failure chance if enabled?\n    // True = Healthy\n    return true;\n  }\n\n  private triggerFailover(to: CloudProvider) {\n    if (this.currentProvider !== to) {\n      logger.warn(\n        `[CloudFailover] ðŸš¨ SWITCHING CLOUD PROVIDER: ${this.currentProvider.toUpperCase()} -> ${to.toUpperCase()}`,\n      );\n      this.currentProvider = to;\n    }\n  }\n}\n"],"version":3}