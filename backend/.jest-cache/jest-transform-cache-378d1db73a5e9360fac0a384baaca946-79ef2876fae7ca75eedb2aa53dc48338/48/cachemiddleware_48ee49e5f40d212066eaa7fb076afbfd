62af141a67d856ad85170b2c07ce6ece
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheMiddleware = void 0;
const cacheManager_1 = require("../utils/cacheManager");
const logger_1 = require("../utils/logger");
/**
 * Middleware to cache API responses
 * @param ttl Time to live in seconds (default 300)
 */
const cacheMiddleware = (ttl = 300) => {
    return async (req, res, next) => {
        // Only cache GET requests
        if (req.method !== 'GET') {
            next();
            return;
        }
        const key = `api:${req.baseUrl}${req.path}`; // Use baseUrl + path so it works with routers
        try {
            // Try to get from cache
            const cached = await cacheManager_1.cache.get(key);
            if (cached) {
                logger_1.logger.debug(`Cache hit for ${key}`);
                res.setHeader('X-Cache', 'HIT');
                res.json(cached);
                return;
            }
            // Intercept response to cache it
            const originalJson = res.json;
            res.json = function (body) {
                // Restore original method
                res.json = originalJson;
                // Cache the response asynchronously if successful
                if (res.statusCode === 200) {
                    cacheManager_1.cache.set(key, body, { ttl }).catch(err => {
                        logger_1.logger.error(err, 'Error caching response:');
                    });
                }
                return originalJson.call(this, body);
            };
            res.setHeader('X-Cache', 'MISS');
            next();
        }
        catch (error) {
            logger_1.logger.error(error, 'Cache middleware error:');
            next();
        }
    };
};
exports.cacheMiddleware = cacheMiddleware;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxtaWRkbGV3YXJlXFxjYWNoZS5taWRkbGV3YXJlLnRzIiwibWFwcGluZ3MiOiI7OztBQUVBLHdEQUE4QztBQUM5Qyw0Q0FBeUM7QUFFekM7OztHQUdHO0FBQ0ksTUFBTSxlQUFlLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxFQUFFLEVBQUU7SUFDM0MsT0FBTyxLQUFLLEVBQUUsR0FBUSxFQUFFLEdBQVEsRUFBRSxJQUFrQixFQUFpQixFQUFFO1FBQ3JFLDBCQUEwQjtRQUMxQixJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssS0FBSyxFQUFFLENBQUM7WUFDekIsSUFBSSxFQUFFLENBQUM7WUFDUCxPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sR0FBRyxHQUFHLE9BQU8sR0FBRyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyw4Q0FBOEM7UUFFM0YsSUFBSSxDQUFDO1lBQ0gsd0JBQXdCO1lBQ3hCLE1BQU0sTUFBTSxHQUFHLE1BQU0sb0JBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEMsSUFBSSxNQUFNLEVBQUUsQ0FBQztnQkFDWCxlQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUNyQyxHQUFHLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDaEMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDakIsT0FBTztZQUNULENBQUM7WUFFRCxpQ0FBaUM7WUFDakMsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztZQUU5QixHQUFHLENBQUMsSUFBSSxHQUFHLFVBQVUsSUFBUztnQkFDNUIsMEJBQTBCO2dCQUMxQixHQUFHLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQztnQkFFeEIsa0RBQWtEO2dCQUNsRCxJQUFJLEdBQUcsQ0FBQyxVQUFVLEtBQUssR0FBRyxFQUFFLENBQUM7b0JBQzNCLG9CQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTt3QkFDeEMsZUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUseUJBQXlCLENBQUMsQ0FBQztvQkFDL0MsQ0FBQyxDQUFDLENBQUM7Z0JBQ0wsQ0FBQztnQkFFRCxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3ZDLENBQUMsQ0FBQztZQUVGLEdBQUcsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ2pDLElBQUksRUFBRSxDQUFDO1FBQ1QsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixlQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO1lBQy9DLElBQUksRUFBRSxDQUFDO1FBQ1QsQ0FBQztJQUNILENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQTVDVyxRQUFBLGVBQWUsbUJBNEMxQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFsZWphbmRyb1xcQUlHZXN0aW9uXFxiYWNrZW5kXFxzcmNcXG1pZGRsZXdhcmVcXGNhY2hlLm1pZGRsZXdhcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOZXh0RnVuY3Rpb24sIFJlc3BvbnNlIH0gZnJvbSAnZXhwcmVzcyc7XG5cbmltcG9ydCB7IGNhY2hlIH0gZnJvbSAnLi4vdXRpbHMvY2FjaGVNYW5hZ2VyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8qKlxuICogTWlkZGxld2FyZSB0byBjYWNoZSBBUEkgcmVzcG9uc2VzXG4gKiBAcGFyYW0gdHRsIFRpbWUgdG8gbGl2ZSBpbiBzZWNvbmRzIChkZWZhdWx0IDMwMClcbiAqL1xuZXhwb3J0IGNvbnN0IGNhY2hlTWlkZGxld2FyZSA9ICh0dGwgPSAzMDApID0+IHtcbiAgcmV0dXJuIGFzeW5jIChyZXE6IGFueSwgcmVzOiBhbnksIG5leHQ6IE5leHRGdW5jdGlvbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIC8vIE9ubHkgY2FjaGUgR0VUIHJlcXVlc3RzXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gYGFwaToke3JlcS5iYXNlVXJsfSR7cmVxLnBhdGh9YDsgLy8gVXNlIGJhc2VVcmwgKyBwYXRoIHNvIGl0IHdvcmtzIHdpdGggcm91dGVyc1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBnZXQgZnJvbSBjYWNoZVxuICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGUgaGl0IGZvciAke2tleX1gKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcignWC1DYWNoZScsICdISVQnKTtcbiAgICAgICAgcmVzLmpzb24oY2FjaGVkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcmNlcHQgcmVzcG9uc2UgdG8gY2FjaGUgaXRcbiAgICAgIGNvbnN0IG9yaWdpbmFsSnNvbiA9IHJlcy5qc29uO1xuXG4gICAgICByZXMuanNvbiA9IGZ1bmN0aW9uIChib2R5OiBhbnkpOiBSZXNwb25zZSB7XG4gICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWV0aG9kXG4gICAgICAgIHJlcy5qc29uID0gb3JpZ2luYWxKc29uO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSByZXNwb25zZSBhc3luY2hyb25vdXNseSBpZiBzdWNjZXNzZnVsXG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgY2FjaGUuc2V0KGtleSwgYm9keSwgeyB0dGwgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIsICdFcnJvciBjYWNoaW5nIHJlc3BvbnNlOicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsSnNvbi5jYWxsKHRoaXMsIGJvZHkpO1xuICAgICAgfTtcblxuICAgICAgcmVzLnNldEhlYWRlcignWC1DYWNoZScsICdNSVNTJyk7XG4gICAgICBuZXh0KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvciwgJ0NhY2hlIG1pZGRsZXdhcmUgZXJyb3I6Jyk7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9O1xufTtcbiJdLCJ2ZXJzaW9uIjozfQ==