f400b8232d24984bac9b33ca63c24be0
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemanticCacheService = void 0;
const generative_ai_1 = require("@google/generative-ai");
const inversify_1 = require("inversify");
const redis_1 = require("../cache/redis");
const env_schema_1 = require("../config/env.schema");
const logger_1 = require("../utils/logger");
let SemanticCacheService = class SemanticCacheService {
    genAI;
    SIMILARITY_THRESHOLD = 0.95;
    EMBEDDING_MODEL = 'embedding-001';
    constructor() {
        this.genAI = new generative_ai_1.GoogleGenerativeAI(env_schema_1.env.GEMINI_API_KEY || '');
    }
    /**
     * Generates a semantic embedding for the given text.
     */
    async getEmbedding(text) {
        try {
            const model = this.genAI.getGenerativeModel({ model: this.EMBEDDING_MODEL });
            const result = await model.embedContent(text);
            return result.embedding.values;
        }
        catch (error) {
            logger_1.logger.error(error, '[SemanticCache] Error generating embedding');
            return [];
        }
    }
    /**
     * Tries to find a cached response for a similar prompt.
     * Currently uses simple key-based lookup (L2) as fallback,
     * but prepared for Vector Search.
     */
    async getSemantic(prompt) {
        const key = `semantic_cache:${this.hashPrompt(prompt)}`;
        // First try exact match in Redis (L2)
        const exactMatch = await (0, redis_1.getCache)(key);
        if (exactMatch) {
            logger_1.logger.info({ key }, '[SemanticCache] Exact Match Hit');
            return exactMatch;
        }
        // TODO: Implement Vector Search (L3) once RedisVL or standard RediSearch is confirmed
        return null;
    }
    /**
     * Caches a response semantically.
     */
    async setSemantic(prompt, response, ttl = 3600 * 24) {
        const key = `semantic_cache:${this.hashPrompt(prompt)}`;
        await (0, redis_1.setCache)(key, response, ttl);
        // In a full implementation, we would store the embedding in a Redis Vector Index here
        // await this.storeVector(prompt, response, await this.getEmbedding(prompt));
    }
    hashPrompt(prompt) {
        // Simple deterministic hash for prompt keys
        return Buffer.from(prompt.trim().toLowerCase()).toString('base64').substring(0, 64);
    }
};
exports.SemanticCacheService = SemanticCacheService;
exports.SemanticCacheService = SemanticCacheService = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], SemanticCacheService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcc2VtYW50aWMtY2FjaGUuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx5REFBMkQ7QUFDM0QseUNBQXVDO0FBQ3ZDLDBDQUFvRDtBQUNwRCxxREFBMkM7QUFDM0MsNENBQXlDO0FBR2xDLElBQU0sb0JBQW9CLEdBQTFCLE1BQU0sb0JBQW9CO0lBQ3ZCLEtBQUssQ0FBTTtJQUNGLG9CQUFvQixHQUFHLElBQUksQ0FBQztJQUM1QixlQUFlLEdBQUcsZUFBZSxDQUFDO0lBRW5EO1FBQ0UsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLGtDQUFrQixDQUFDLGdCQUFHLENBQUMsY0FBYyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBWTtRQUM3QixJQUFJLENBQUM7WUFDSCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO1lBQzdFLE1BQU0sTUFBTSxHQUFHLE1BQU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ2pDLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsNENBQTRDLENBQUMsQ0FBQztZQUNsRSxPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBYztRQUM5QixNQUFNLEdBQUcsR0FBRyxrQkFBa0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBRXhELHNDQUFzQztRQUN0QyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUEsZ0JBQVEsRUFBQyxHQUFHLENBQUMsQ0FBQztRQUN2QyxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLGlDQUFpQyxDQUFDLENBQUM7WUFDeEQsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQztRQUVELHNGQUFzRjtRQUN0RixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBYyxFQUFFLFFBQWdCLEVBQUUsR0FBRyxHQUFHLElBQUksR0FBRyxFQUFFO1FBQ2pFLE1BQU0sR0FBRyxHQUFHLGtCQUFrQixJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDeEQsTUFBTSxJQUFBLGdCQUFRLEVBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVuQyxzRkFBc0Y7UUFDdEYsNkVBQTZFO0lBQy9FLENBQUM7SUFFTyxVQUFVLENBQUMsTUFBYztRQUMvQiw0Q0FBNEM7UUFDNUMsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3RGLENBQUM7Q0FDRixDQUFBO0FBekRZLG9EQUFvQjsrQkFBcEIsb0JBQW9CO0lBRGhDLElBQUEsc0JBQVUsR0FBRTs7R0FDQSxvQkFBb0IsQ0F5RGhDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXHNlbWFudGljLWNhY2hlLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR29vZ2xlR2VuZXJhdGl2ZUFJIH0gZnJvbSAnQGdvb2dsZS9nZW5lcmF0aXZlLWFpJztcbmltcG9ydCB7IGluamVjdGFibGUgfSBmcm9tICdpbnZlcnNpZnknO1xuaW1wb3J0IHsgZ2V0Q2FjaGUsIHNldENhY2hlIH0gZnJvbSAnLi4vY2FjaGUvcmVkaXMnO1xuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vY29uZmlnL2Vudi5zY2hlbWEnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlbWFudGljQ2FjaGVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBnZW5BSTogYW55O1xuICBwcml2YXRlIHJlYWRvbmx5IFNJTUlMQVJJVFlfVEhSRVNIT0xEID0gMC45NTtcbiAgcHJpdmF0ZSByZWFkb25seSBFTUJFRERJTkdfTU9ERUwgPSAnZW1iZWRkaW5nLTAwMSc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5nZW5BSSA9IG5ldyBHb29nbGVHZW5lcmF0aXZlQUkoZW52LkdFTUlOSV9BUElfS0VZIHx8ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBzZW1hbnRpYyBlbWJlZGRpbmcgZm9yIHRoZSBnaXZlbiB0ZXh0LlxuICAgKi9cbiAgYXN5bmMgZ2V0RW1iZWRkaW5nKHRleHQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmdlbkFJLmdldEdlbmVyYXRpdmVNb2RlbCh7IG1vZGVsOiB0aGlzLkVNQkVERElOR19NT0RFTCB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vZGVsLmVtYmVkQ29udGVudCh0ZXh0KTtcbiAgICAgIHJldHVybiByZXN1bHQuZW1iZWRkaW5nLnZhbHVlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLCAnW1NlbWFudGljQ2FjaGVdIEVycm9yIGdlbmVyYXRpbmcgZW1iZWRkaW5nJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIGZpbmQgYSBjYWNoZWQgcmVzcG9uc2UgZm9yIGEgc2ltaWxhciBwcm9tcHQuXG4gICAqIEN1cnJlbnRseSB1c2VzIHNpbXBsZSBrZXktYmFzZWQgbG9va3VwIChMMikgYXMgZmFsbGJhY2ssXG4gICAqIGJ1dCBwcmVwYXJlZCBmb3IgVmVjdG9yIFNlYXJjaC5cbiAgICovXG4gIGFzeW5jIGdldFNlbWFudGljKHByb21wdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgY29uc3Qga2V5ID0gYHNlbWFudGljX2NhY2hlOiR7dGhpcy5oYXNoUHJvbXB0KHByb21wdCl9YDtcblxuICAgIC8vIEZpcnN0IHRyeSBleGFjdCBtYXRjaCBpbiBSZWRpcyAoTDIpXG4gICAgY29uc3QgZXhhY3RNYXRjaCA9IGF3YWl0IGdldENhY2hlKGtleSk7XG4gICAgaWYgKGV4YWN0TWF0Y2gpIHtcbiAgICAgIGxvZ2dlci5pbmZvKHsga2V5IH0sICdbU2VtYW50aWNDYWNoZV0gRXhhY3QgTWF0Y2ggSGl0Jyk7XG4gICAgICByZXR1cm4gZXhhY3RNYXRjaDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgVmVjdG9yIFNlYXJjaCAoTDMpIG9uY2UgUmVkaXNWTCBvciBzdGFuZGFyZCBSZWRpU2VhcmNoIGlzIGNvbmZpcm1lZFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENhY2hlcyBhIHJlc3BvbnNlIHNlbWFudGljYWxseS5cbiAgICovXG4gIGFzeW5jIHNldFNlbWFudGljKHByb21wdDogc3RyaW5nLCByZXNwb25zZTogc3RyaW5nLCB0dGwgPSAzNjAwICogMjQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBrZXkgPSBgc2VtYW50aWNfY2FjaGU6JHt0aGlzLmhhc2hQcm9tcHQocHJvbXB0KX1gO1xuICAgIGF3YWl0IHNldENhY2hlKGtleSwgcmVzcG9uc2UsIHR0bCk7XG5cbiAgICAvLyBJbiBhIGZ1bGwgaW1wbGVtZW50YXRpb24sIHdlIHdvdWxkIHN0b3JlIHRoZSBlbWJlZGRpbmcgaW4gYSBSZWRpcyBWZWN0b3IgSW5kZXggaGVyZVxuICAgIC8vIGF3YWl0IHRoaXMuc3RvcmVWZWN0b3IocHJvbXB0LCByZXNwb25zZSwgYXdhaXQgdGhpcy5nZXRFbWJlZGRpbmcocHJvbXB0KSk7XG4gIH1cblxuICBwcml2YXRlIGhhc2hQcm9tcHQocHJvbXB0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIFNpbXBsZSBkZXRlcm1pbmlzdGljIGhhc2ggZm9yIHByb21wdCBrZXlzXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHByb21wdC50cmltKCkudG9Mb3dlckNhc2UoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpLnN1YnN0cmluZygwLCA2NCk7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==