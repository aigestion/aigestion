98e534e301208109783be2eb9b0ad322
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SystemMetricsService = void 0;
const child_process_1 = require("child_process");
const inversify_1 = require("inversify");
const os = __importStar(require("os"));
const util_1 = require("util");
const types_1 = require("../types");
const logger_1 = require("../utils/logger");
const credential_manager_service_1 = require("./credential-manager.service");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
let SystemMetricsService = class SystemMetricsService {
    credentialManager;
    lastNetworkStats = null;
    constructor(credentialManager) {
        this.credentialManager = credentialManager;
    }
    /**
     * Get all system metrics aggregated
     */
    async getSystemMetrics() {
        const [cpu, memory, network, disk, dockerCount, proStatus] = await Promise.all([
            this.getCPUUsage(),
            this.getMemoryUsage(),
            this.getNetworkUsage(),
            this.getDiskUsage(),
            this.getDockerContainerCount(),
            this.credentialManager.verifyProfessionalAccount(),
        ]);
        const accountTier = proStatus.status === 'valid' ? 'Professional' : 'Standard';
        return {
            cpu,
            memory,
            network,
            disk,
            dockerContainerCount: dockerCount,
            accountTier,
            uptime: os.uptime(),
            platform: os.platform(),
            hostname: os.hostname(),
            timestamp: Date.now(),
        };
    }
    /**
     * Calculate CPU usage percentage
     */
    async getCPUUsage() {
        const cpus = os.cpus();
        const usage = cpus.reduce((acc, cpu) => {
            const total = Object.values(cpu.times).reduce((a, b) => a + b, 0);
            const idle = cpu.times.idle;
            return acc + ((total - idle) / (total || 1)) * 100;
        }, 0) / cpus.length;
        return parseFloat(usage.toFixed(2));
    }
    /**
     * Calculate Memory usage percentage
     */
    async getMemoryUsage() {
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        const usedMem = totalMem - freeMem;
        return parseFloat(((usedMem / totalMem) * 100).toFixed(2));
    }
    /**
     * Get aggregated Disk usage percentage (C: drive for Windows, root for others as fallback)
     */
    async getDiskUsage() {
        try {
            if (os.platform() === 'win32') {
                const { stdout } = await execAsync('wmic logicaldisk get size,freespace,caption');
                const lines = stdout.trim().split('\n').slice(1);
                let total = 0;
                let free = 0;
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 3 && parts[0].includes('C:')) {
                        free += parseInt(parts[1]);
                        total += parseInt(parts[2]);
                    }
                }
                return total > 0 ? parseFloat((((total - free) / total) * 100).toFixed(2)) : 0;
            }
            return 0; // Fallback for now or implement linux `df - h`
        }
        catch (e) {
            logger_1.logger.error('Error getting disk usage', e);
            return 0;
        }
    }
    /**
     * Get Network activity score (0-100) based on rx bytes
     */
    async getNetworkUsage() {
        let totalBytes = 0;
        try {
            if (os.platform() === 'win32') {
                const { stdout } = await execAsync('powershell -Command "Get-NetAdapterStatistics | Select-Object -ExpandProperty ReceivedBytes"');
                totalBytes = stdout.split('\n').reduce((acc, val) => acc + (parseInt(val.trim()) || 0), 0);
            }
            else {
                // Fallback or Linux implementation
                return 0;
            }
        }
        catch (e) {
            return 0;
        }
        const now = Date.now();
        if (this.lastNetworkStats) {
            const elapsed = (now - this.lastNetworkStats.time) / 1000;
            const delta = (totalBytes - this.lastNetworkStats.rx) / 1024 / 1024; // MB
            this.lastNetworkStats = { rx: totalBytes, tx: 0, time: now };
            return parseFloat(Math.max(0, Math.min(100, (delta / (elapsed || 1)) * 10)).toFixed(2));
        }
        this.lastNetworkStats = { rx: totalBytes, tx: 0, time: now };
        return 0;
    }
    /**
     * Get active Docker container count
     */
    async getDockerContainerCount() {
        try {
            const { stdout } = await execAsync('docker ps -q | Measure-Object | Select-Object -ExpandProperty Count');
            return parseInt(stdout.trim()) || 0;
        }
        catch {
            try {
                const { stdout } = await execAsync('docker ps -q');
                return stdout
                    .trim()
                    .split('\n')
                    .filter(line => line).length;
            }
            catch {
                return 0;
            }
        }
    }
};
exports.SystemMetricsService = SystemMetricsService;
exports.SystemMetricsService = SystemMetricsService = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.CredentialManagerService)),
    __metadata("design:paramtypes", [typeof (_a = typeof credential_manager_service_1.CredentialManagerService !== "undefined" && credential_manager_service_1.CredentialManagerService) === "function" ? _a : Object])
], SystemMetricsService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcc3lzdGVtLW1ldHJpY3Muc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaURBQXFDO0FBQ3JDLHlDQUErQztBQUMvQyx1Q0FBeUI7QUFDekIsK0JBQWlDO0FBRWpDLG9DQUFpQztBQUNqQyw0Q0FBeUM7QUFDekMsNkVBQXdFO0FBRXhFLE1BQU0sU0FBUyxHQUFHLElBQUEsZ0JBQVMsRUFBQyxvQkFBSSxDQUFDLENBQUM7QUFnQjNCLElBQU0sb0JBQW9CLEdBQTFCLE1BQU0sb0JBQW9CO0lBSW1CO0lBSDFDLGdCQUFnQixHQUFvRCxJQUFJLENBQUM7SUFFakYsWUFDa0QsaUJBQTJDO1FBQTNDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMEI7SUFDMUYsQ0FBQztJQUVKOztPQUVHO0lBQ0gsS0FBSyxDQUFDLGdCQUFnQjtRQUNwQixNQUFNLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUM7WUFDN0UsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNsQixJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixJQUFJLENBQUMsdUJBQXVCLEVBQUU7WUFDOUIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLHlCQUF5QixFQUFFO1NBQ25ELENBQUMsQ0FBQztRQUVILE1BQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUUvRSxPQUFPO1lBQ0wsR0FBRztZQUNILE1BQU07WUFDTixPQUFPO1lBQ1AsSUFBSTtZ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Q0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQ2pDLENBQUM7WUFBQyxNQUFNLENBQUM7Z0JBQ1AsT0FBTyxDQUFDLENBQUM7WUFDWCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7Q0FDRixDQUFBO0FBN0lZLG9EQUFvQjsrQkFBcEIsb0JBQW9CO0lBRGhDLElBQUEsc0JBQVUsR0FBRTtJQUtSLFdBQUEsSUFBQSxrQkFBTSxFQUFDLGFBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFBO3lEQUE0QixxREFBd0Isb0JBQXhCLHFEQUF3QjtHQUpsRixvQkFBb0IsQ0E2SWhDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXHN5c3RlbS1tZXRyaWNzLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgaW5qZWN0LCBpbmplY3RhYmxlIH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQgeyBUWVBFUyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBDcmVkZW50aWFsTWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL2NyZWRlbnRpYWwtbWFuYWdlci5zZXJ2aWNlJztcblxuY29uc3QgZXhlY0FzeW5jID0gcHJvbWlzaWZ5KGV4ZWMpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN5c3RlbU1ldHJpY3Mge1xuICBjcHU6IG51bWJlcjtcbiAgbWVtb3J5OiBudW1iZXI7XG4gIG5ldHdvcms6IG51bWJlcjtcbiAgZGlzazogbnVtYmVyO1xuICB1cHRpbWU6IG51bWJlcjtcbiAgcGxhdGZvcm06IE5vZGVKUy5QbGF0Zm9ybTtcbiAgaG9zdG5hbWU6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIGRvY2tlckNvbnRhaW5lckNvdW50PzogbnVtYmVyO1xuICBhY2NvdW50VGllcj86IHN0cmluZztcbn1cblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN5c3RlbU1ldHJpY3NTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBsYXN0TmV0d29ya1N0YXRzOiB7IHJ4OiBudW1iZXI7IHR4OiBudW1iZXI7IHRpbWU6IG51bWJlciB9IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQGluamVjdChUWVBFUy5DcmVkZW50aWFsTWFuYWdlclNlcnZpY2UpIHByaXZhdGUgY3JlZGVudGlhbE1hbmFnZXI6IENyZWRlbnRpYWxNYW5hZ2VyU2VydmljZSxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHN5c3RlbSBtZXRyaWNzIGFnZ3JlZ2F0ZWRcbiAgICovXG4gIGFzeW5jIGdldFN5c3RlbU1ldHJpY3MoKTogUHJvbWlzZTxTeXN0ZW1NZXRyaWNzPiB7XG4gICAgY29uc3QgW2NwdSwgbWVtb3J5LCBuZXR3b3JrLCBkaXNrLCBkb2NrZXJDb3VudCwgcHJvU3RhdHVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuZ2V0Q1BVVXNhZ2UoKSxcbiAgICAgIHRoaXMuZ2V0TWVtb3J5VXNhZ2UoKSxcbiAgICAgIHRoaXMuZ2V0TmV0d29ya1VzYWdlKCksXG4gICAgICB0aGlzLmdldERpc2tVc2FnZSgpLFxuICAgICAgdGhpcy5nZXREb2NrZXJDb250YWluZXJDb3VudCgpLFxuICAgICAgdGhpcy5jcmVkZW50aWFsTWFuYWdlci52ZXJpZnlQcm9mZXNzaW9uYWxBY2NvdW50KCksXG4gICAgXSk7XG5cbiAgICBjb25zdCBhY2NvdW50VGllciA9IHByb1N0YXR1cy5zdGF0dXMgPT09ICd2YWxpZCcgPyAnUHJvZmVzc2lvbmFsJyA6ICdTdGFuZGFyZCc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3B1LFxuICAgICAgbWVtb3J5LFxuICAgICAgbmV0d29yayxcbiAgICAgIGRpc2ssXG4gICAgICBkb2NrZXJDb250YWluZXJDb3VudDogZG9ja2VyQ291bnQsXG4gICAgICBhY2NvdW50VGllcixcbiAgICAgIHVwdGltZTogb3MudXB0aW1lKCksXG4gICAgICBwbGF0Zm9ybTogb3MucGxhdGZvcm0oKSxcbiAgICAgIGhvc3RuYW1lOiBvcy5ob3N0bmFtZSgpLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIENQVSB1c2FnZSBwZXJjZW50YWdlXG4gICAqL1xuICBhc3luYyBnZXRDUFVVc2FnZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IGNwdXMgPSBvcy5jcHVzKCk7XG4gICAgY29uc3QgdXNhZ2UgPVxuICAgICAgY3B1cy5yZWR1Y2UoKGFjYywgY3B1KSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gT2JqZWN0LnZhbHVlcyhjcHUudGltZXMpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgICAgICBjb25zdCBpZGxlID0gY3B1LnRpbWVzLmlkbGU7XG4gICAgICAgIHJldHVybiBhY2MgKyAoKHRvdGFsIC0gaWRsZSkgLyAodG90YWwgfHwgMSkpICogMTAwO1xuICAgICAgfSwgMCkgLyBjcHVzLmxlbmd0aDtcblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHVzYWdlLnRvRml4ZWQoMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBNZW1vcnkgdXNhZ2UgcGVyY2VudGFnZVxuICAgKi9cbiAgYXN5bmMgZ2V0TWVtb3J5VXNhZ2UoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCB0b3RhbE1lbSA9IG9zLnRvdGFsbWVtKCk7XG4gICAgY29uc3QgZnJlZU1lbSA9IG9zLmZyZWVtZW0oKTtcbiAgICBjb25zdCB1c2VkTWVtID0gdG90YWxNZW0gLSBmcmVlTWVtO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KCgodXNlZE1lbSAvIHRvdGFsTWVtKSAqIDEwMCkudG9GaXhlZCgyKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFnZ3JlZ2F0ZWQgRGlzayB1c2FnZSBwZXJjZW50YWdlIChDOiBkcml2ZSBmb3IgV2luZG93cywgcm9vdCBmb3Igb3RoZXJzIGFzIGZhbGxiYWNrKVxuICAgKi9cbiAgYXN5bmMgZ2V0RGlza1VzYWdlKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgICAgIGNvbnN0IHsgc3Rkb3V0IH0gPSBhd2FpdCBleGVjQXN5bmMoJ3dtaWMgbG9naWNhbGRpc2sgZ2V0IHNpemUsZnJlZXNwYWNlLGNhcHRpb24nKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudHJpbSgpLnNwbGl0KCdcXG4nKS5zbGljZSgxKTtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgbGV0IGZyZWUgPSAwO1xuXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDMgJiYgcGFydHNbMF0uaW5jbHVkZXMoJ0M6JykpIHtcbiAgICAgICAgICAgIGZyZWUgKz0gcGFyc2VJbnQocGFydHNbMV0pO1xuICAgICAgICAgICAgdG90YWwgKz0gcGFyc2VJbnQocGFydHNbMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgPiAwID8gcGFyc2VGbG9hdCgoKCh0b3RhbCAtIGZyZWUpIC8gdG90YWwpICogMTAwKS50b0ZpeGVkKDIpKSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDsgLy8gRmFsbGJhY2sgZm9yIG5vdyBvciBpbXBsZW1lbnQgbGludXggYGRmIC0gaGBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZGlzayB1c2FnZScsIGUpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBOZXR3b3JrIGFjdGl2aXR5IHNjb3JlICgwLTEwMCkgYmFzZWQgb24gcnggYnl0ZXNcbiAgICovXG4gIGFzeW5jIGdldE5ldHdvcmtVc2FnZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGxldCB0b3RhbEJ5dGVzID0gMDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xuICAgICAgICBjb25zdCB7IHN0ZG91dCB9ID0gYXdhaXQgZXhlY0FzeW5jKFxuICAgICAgICAgICdwb3dlcnNoZWxsIC1Db21tYW5kIFwiR2V0LU5ldEFkYXB0ZXJTdGF0aXN0aWNzIHwgU2VsZWN0LU9iamVjdCAtRXhwYW5kUHJvcGVydHkgUmVjZWl2ZWRCeXRlc1wiJyxcbiAgICAgICAgKTtcbiAgICAgICAgdG90YWxCeXRlcyA9IHN0ZG91dC5zcGxpdCgnXFxuJykucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgKHBhcnNlSW50KHZhbC50cmltKCkpIHx8IDApLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIG9yIExpbnV4IGltcGxlbWVudGF0aW9uXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKHRoaXMubGFzdE5ldHdvcmtTdGF0cykge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IChub3cgLSB0aGlzLmxhc3ROZXR3b3JrU3RhdHMudGltZSkgLyAxMDAwO1xuICAgICAgY29uc3QgZGVsdGEgPSAodG90YWxCeXRlcyAtIHRoaXMubGFzdE5ldHdvcmtTdGF0cy5yeCkgLyAxMDI0IC8gMTAyNDsgLy8gTUJcbiAgICAgIHRoaXMubGFzdE5ldHdvcmtTdGF0cyA9IHsgcng6IHRvdGFsQnl0ZXMsIHR4OiAwLCB0aW1lOiBub3cgfTtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgKGRlbHRhIC8gKGVsYXBzZWQgfHwgMSkpICogMTApKS50b0ZpeGVkKDIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3ROZXR3b3JrU3RhdHMgPSB7IHJ4OiB0b3RhbEJ5dGVzLCB0eDogMCwgdGltZTogbm93IH07XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjdGl2ZSBEb2NrZXIgY29udGFpbmVyIGNvdW50XG4gICAqL1xuICBhc3luYyBnZXREb2NrZXJDb250YWluZXJDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHN0ZG91dCB9ID0gYXdhaXQgZXhlY0FzeW5jKFxuICAgICAgICAnZG9ja2VyIHBzIC1xIHwgTWVhc3VyZS1PYmplY3QgfCBTZWxlY3QtT2JqZWN0IC1FeHBhbmRQcm9wZXJ0eSBDb3VudCcsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ZG91dC50cmltKCkpIHx8IDA7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHN0ZG91dCB9ID0gYXdhaXQgZXhlY0FzeW5jKCdkb2NrZXIgcHMgLXEnKTtcbiAgICAgICAgcmV0dXJuIHN0ZG91dFxuICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUpLmxlbmd0aDtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==