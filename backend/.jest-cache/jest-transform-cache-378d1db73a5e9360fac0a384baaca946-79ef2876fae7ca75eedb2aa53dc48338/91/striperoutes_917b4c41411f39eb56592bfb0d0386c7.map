{"file":"C:\\Users\\Alejandro\\AIGestion\\backend\\src\\routes\\stripe.routes.ts","mappings":"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","names":[],"sources":["C:\\Users\\Alejandro\\AIGestion\\backend\\src\\routes\\stripe.routes.ts"],"sourcesContent":["import { Router } from 'express';\n\nimport { buildError, buildResponse } from '../common/response-builder';\nimport { User } from '../models/User';\nimport { stripeService } from '../services/stripe.service';\nimport { logger } from '../utils/logger';\n\nconst stripeRouter = Router();\n\n/**\n * @openapi\n * /stripe/checkout:\n *   post:\n *     summary: Create a Stripe Checkout Session\n *     tags: [Stripe]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               priceId:\n *                 type: string\n *               successUrl:\n *                 type: string\n *               cancelUrl:\n *                 type: string\n *               userId:\n *                 type: string\n *                 description: Optional user ID for testing\n *     responses:\n *       200:\n *         description: Checkout session created\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 sessionId:\n *                   type: string\n *                 url:\n *                   type: string\n *       400:\n *         description: Validation error\n *       500:\n *         description: Server error\n */\nstripeRouter.post('/checkout', async (req: any, res: any) => {\n  const requestId = req.requestId;\n  try {\n    const { priceId, successUrl, cancelUrl, userId } = req.body;\n    // In a real app, userId comes from auth middleware: (req as any).user.id\n\n    if (!priceId || !successUrl || !cancelUrl) {\n      return res\n        .status(400)\n        .json(buildError('Missing required fields', 'VALIDATION_ERROR', 400, requestId));\n    }\n\n    // Default to a test user if auth is missing in this context\n    const userToCharge = userId ? await User.findById(userId) : null;\n\n    // Create customer if needed (simplified logic)\n    let customerId = userToCharge?.stripeCustomerId;\n    if (userToCharge && !customerId) {\n      const customer = await stripeService.createCustomer(userToCharge.email, userToCharge.name);\n      customerId = customer.id;\n      userToCharge.stripeCustomerId = customerId;\n      await userToCharge.save();\n    }\n\n    // Fallback for testing without DB\n    if (!customerId) {\n      // Create a guest customer just for the session if we don't have a user\n      // Or throw error in strict mode. For now, we'll assume we need a user.\n      return res\n        .status(400)\n        .json(buildError('User not found or no customer ID', 'USER_ERROR', 400, requestId));\n    }\n\n    const session = await stripeService.createSubscriptionCheckoutSession(\n      customerId,\n      priceId,\n      successUrl,\n      cancelUrl,\n    );\n\n    return res.json(buildResponse({ sessionId: session.id, url: session.url }, 200, requestId));\n  } catch (error: any) {\n    logger.error(error, 'Checkout session creation failed');\n    return res.status(500).json(buildError(error.message, 'STRIPE_ERROR', 500, requestId));\n  }\n});\n\n/**\n * @openapi\n * /stripe/webhook:\n *   post:\n *     summary: Stripe webhook endpoint\n *     tags: [Stripe]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *     responses:\n *       200:\n *         description: Webhook processed\n *       400:\n *         description: Bad request\n */\nstripeRouter.post('/webhook', async (req: any, res: any) => {\n  const sig = req.headers['stripe-signature'];\n  const rawBody = req.rawBody;\n\n  if (!sig || !rawBody) {\n    return res.status(400).send('Webhook Error: Missing signature or body');\n  }\n\n  try {\n    const event = stripeService.constructEvent(rawBody, sig as string); // Cast req.body to buffer? No, use rawBody string/buffer\n\n    logger.info(`Stripe event received: ${event.type}`);\n\n    // Handle the event\n    switch (event.type) {\n      case 'checkout.session.completed':\n        const session = event.data.object as any;\n        logger.info(`Checkout session completed for ${session.customer}`);\n        // TODO: Update user subscription status\n        if (session.customer) {\n          const user = await User.findOne({ stripeCustomerId: session.customer });\n          if (user) {\n            user.subscriptionStatus = 'active';\n            if (session.subscription) {\n              user.subscriptionId = session.subscription as string;\n            }\n            await user.save();\n            logger.info(`User ${user.email} subscription activated`);\n          }\n        }\n        break;\n\n      case 'customer.subscription.deleted':\n        const subscription = event.data.object as any;\n        const user = await User.findOne({ subscriptionId: subscription.id });\n        if (user) {\n          user.subscriptionStatus = 'canceled';\n          await user.save();\n          logger.info(`User ${user.email} subscription canceled`);\n        }\n        break;\n\n      default:\n      // logger.info(`Unhandled event type ${event.type}`);\n    }\n\n    return res.json({ received: true });\n  } catch (err: any) {\n    logger.error(`Webhook Error: ${err.message}`);\n    return res.status(400).send(`Webhook Error: ${err.message}`);\n  }\n});\n\nexport default stripeRouter;\n"],"version":3}