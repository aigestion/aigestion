229e374598b13fe2f60a084d8642e35a
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const response_builder_1 = require("../common/response-builder");
const User_1 = require("../models/User");
const stripe_service_1 = require("../services/stripe.service");
const logger_1 = require("../utils/logger");
const stripeRouter = (0, express_1.Router)();
/**
 * @openapi
 * /stripe/checkout:
 *   post:
 *     summary: Create a Stripe Checkout Session
 *     tags: [Stripe]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               priceId:
 *                 type: string
 *               successUrl:
 *                 type: string
 *               cancelUrl:
 *                 type: string
 *               userId:
 *                 type: string
 *                 description: Optional user ID for testing
 *     responses:
 *       200:
 *         description: Checkout session created
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 sessionId:
 *                   type: string
 *                 url:
 *                   type: string
 *       400:
 *         description: Validation error
 *       500:
 *         description: Server error
 */
stripeRouter.post('/checkout', async (req, res) => {
    const requestId = req.requestId;
    try {
        const { priceId, successUrl, cancelUrl, userId } = req.body;
        // In a real app, userId comes from auth middleware: (req as any).user.id
        if (!priceId || !successUrl || !cancelUrl) {
            return res
                .status(400)
                .json((0, response_builder_1.buildError)('Missing required fields', 'VALIDATION_ERROR', 400, requestId));
        }
        // Default to a test user if auth is missing in this context
        const userToCharge = userId ? await User_1.User.findById(userId) : null;
        // Create customer if needed (simplified logic)
        let customerId = userToCharge?.stripeCustomerId;
        if (userToCharge && !customerId) {
            const customer = await stripe_service_1.stripeService.createCustomer(userToCharge.email, userToCharge.name);
            customerId = customer.id;
            userToCharge.stripeCustomerId = customerId;
            await userToCharge.save();
        }
        // Fallback for testing without DB
        if (!customerId) {
            // Create a guest customer just for the session if we don't have a user
            // Or throw error in strict mode. For now, we'll assume we need a user.
            return res
                .status(400)
                .json((0, response_builder_1.buildError)('User not found or no customer ID', 'USER_ERROR', 400, requestId));
        }
        const session = await stripe_service_1.stripeService.createSubscriptionCheckoutSession(customerId, priceId, successUrl, cancelUrl);
        return res.json((0, response_builder_1.buildResponse)({ sessionId: session.id, url: session.url }, 200, requestId));
    }
    catch (error) {
        logger_1.logger.error(error, 'Checkout session creation failed');
        return res.status(500).json((0, response_builder_1.buildError)(error.message, 'STRIPE_ERROR', 500, requestId));
    }
});
/**
 * @openapi
 * /stripe/webhook:
 *   post:
 *     summary: Stripe webhook endpoint
 *     tags: [Stripe]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *     responses:
 *       200:
 *         description: Webhook processed
 *       400:
 *         description: Bad request
 */
stripeRouter.post('/webhook', async (req, res) => {
    const sig = req.headers['stripe-signature'];
    const rawBody = req.rawBody;
    if (!sig || !rawBody) {
        return res.status(400).send('Webhook Error: Missing signature or body');
    }
    try {
        const event = stripe_service_1.stripeService.constructEvent(rawBody, sig); // Cast req.body to buffer? No, use rawBody string/buffer
        logger_1.logger.info(`Stripe event received: ${event.type}`);
        // Handle the event
        switch (event.type) {
            case 'checkout.session.completed':
                const session = event.data.object;
                logger_1.logger.info(`Checkout session completed for ${session.customer}`);
                // TODO: Update user subscription status
                if (session.customer) {
                    const user = await User_1.User.findOne({ stripeCustomerId: session.customer });
                    if (user) {
                        user.subscriptionStatus = 'active';
                        if (session.subscription) {
                            user.subscriptionId = session.subscription;
                        }
                        await user.save();
                        logger_1.logger.info(`User ${user.email} subscription activated`);
                    }
                }
                break;
            case 'customer.subscription.deleted':
                const subscription = event.data.object;
                const user = await User_1.User.findOne({ subscriptionId: subscription.id });
                if (user) {
                    user.subscriptionStatus = 'canceled';
                    await user.save();
                    logger_1.logger.info(`User ${user.email} subscription canceled`);
                }
                break;
            default:
            // logger.info(`Unhandled event type ${event.type}`);
        }
        return res.json({ received: true });
    }
    catch (err) {
        logger_1.logger.error(`Webhook Error: ${err.message}`);
        return res.status(400).send(`Webhook Error: ${err.message}`);
    }
});
exports.default = stripeRouter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxyb3V0ZXNcXHN0cmlwZS5yb3V0ZXMudHMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBaUM7QUFFakMsaUVBQXVFO0FBQ3ZFLHlDQUFzQztBQUN0QywrREFBMkQ7QUFDM0QsNENBQXlDO0FBRXpDLE1BQU0sWUFBWSxHQUFHLElBQUEsZ0JBQU0sR0FBRSxDQUFDO0FBRTlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNDRztBQUNILFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxHQUFRLEVBQUUsR0FBUSxFQUFFLEVBQUU7SUFDMUQsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQztJQUNoQyxJQUFJLENBQUM7UUFDSCxNQUFNLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUM1RCx5RUFBeUU7UUFFekUsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQzFDLE9BQU8sR0FBRztpQkFDUCxNQUFNLENBQUMsR0FBRyxDQUFDO2lCQUNYLElBQUksQ0FBQyxJQUFBLDZCQUFVLEVBQUMseUJBQXlCLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDckYsQ0FBQztRQUVELDREQUE0RDtRQUM1RCxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sV0FBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBRWpFLCtDQUErQztRQUMvQyxJQUFJLFVBQVUsR0FBRyxZQUFZLEVBQUUsZ0JBQWdCLENBQUM7UUFDaEQsSUFBSSxZQUFZLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNoQyxNQUFNLFFBQVEsR0FB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XSwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFsZWphbmRyb1xcQUlHZXN0aW9uXFxiYWNrZW5kXFxzcmNcXHJvdXRlc1xcc3RyaXBlLnJvdXRlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdleHByZXNzJztcblxuaW1wb3J0IHsgYnVpbGRFcnJvciwgYnVpbGRSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi9yZXNwb25zZS1idWlsZGVyJztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuLi9tb2RlbHMvVXNlcic7XG5pbXBvcnQgeyBzdHJpcGVTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvc3RyaXBlLnNlcnZpY2UnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3Qgc3RyaXBlUm91dGVyID0gUm91dGVyKCk7XG5cbi8qKlxuICogQG9wZW5hcGlcbiAqIC9zdHJpcGUvY2hlY2tvdXQ6XG4gKiAgIHBvc3Q6XG4gKiAgICAgc3VtbWFyeTogQ3JlYXRlIGEgU3RyaXBlIENoZWNrb3V0IFNlc3Npb25cbiAqICAgICB0YWdzOiBbU3RyaXBlXVxuICogICAgIHJlcXVlc3RCb2R5OlxuICogICAgICAgcmVxdWlyZWQ6IHRydWVcbiAqICAgICAgIGNvbnRlbnQ6XG4gKiAgICAgICAgIGFwcGxpY2F0aW9uL2pzb246XG4gKiAgICAgICAgICAgc2NoZW1hOlxuICogICAgICAgICAgICAgdHlwZTogb2JqZWN0XG4gKiAgICAgICAgICAgICBwcm9wZXJ0aWVzOlxuICogICAgICAgICAgICAgICBwcmljZUlkOlxuICogICAgICAgICAgICAgICAgIHR5cGU6IHN0cmluZ1xuICogICAgICAgICAgICAgICBzdWNjZXNzVXJsOlxuICogICAgICAgICAgICAgICAgIHR5cGU6IHN0cmluZ1xuICogICAgICAgICAgICAgICBjYW5jZWxVcmw6XG4gKiAgICAgICAgICAgICAgICAgdHlwZTogc3RyaW5nXG4gKiAgICAgICAgICAgICAgIHVzZXJJZDpcbiAqICAgICAgICAgICAgICAgICB0eXBlOiBzdHJpbmdcbiAqICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogT3B0aW9uYWwgdXNlciBJRCBmb3IgdGVzdGluZ1xuICogICAgIHJlc3BvbnNlczpcbiAqICAgICAgIDIwMDpcbiAqICAgICAgICAgZGVzY3JpcHRpb246IENoZWNrb3V0IHNlc3Npb24gY3JlYXRlZFxuICogICAgICAgICBjb250ZW50OlxuICogICAgICAgICAgIGFwcGxpY2F0aW9uL2pzb246XG4gKiAgICAgICAgICAgICBzY2hlbWE6XG4gKiAgICAgICAgICAgICAgIHR5cGU6IG9iamVjdFxuICogICAgICAgICAgICAgICBwcm9wZXJ0aWVzOlxuICogICAgICAgICAgICAgICAgIHNlc3Npb25JZDpcbiAqICAgICAgICAgICAgICAgICAgIHR5cGU6IHN0cmluZ1xuICogICAgICAgICAgICAgICAgIHVybDpcbiAqICAgICAgICAgICAgICAgICAgIHR5cGU6IHN0cmluZ1xuICogICAgICAgNDAwOlxuICogICAgICAgICBkZXNjcmlwdGlvbjogVmFsaWRhdGlvbiBlcnJvclxuICogICAgICAgNTAwOlxuICogICAgICAgICBkZXNjcmlwdGlvbjogU2VydmVyIGVycm9yXG4gKi9cbnN0cmlwZVJvdXRlci5wb3N0KCcvY2hlY2tvdXQnLCBhc3luYyAocmVxOiBhbnksIHJlczogYW55KSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IHJlcS5yZXF1ZXN0SWQ7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBwcmljZUlkLCBzdWNjZXNzVXJsLCBjYW5jZWxVcmwsIHVzZXJJZCB9ID0gcmVxLmJvZHk7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdXNlcklkIGNvbWVzIGZyb20gYXV0aCBtaWRkbGV3YXJlOiAocmVxIGFzIGFueSkudXNlci5pZFxuXG4gICAgaWYgKCFwcmljZUlkIHx8ICFzdWNjZXNzVXJsIHx8ICFjYW5jZWxVcmwpIHtcbiAgICAgIHJldHVybiByZXNcbiAgICAgICAgLnN0YXR1cyg0MDApXG4gICAgICAgIC5qc29uKGJ1aWxkRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzJywgJ1ZBTElEQVRJT05fRVJST1InLCA0MDAsIHJlcXVlc3RJZCkpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gYSB0ZXN0IHVzZXIgaWYgYXV0aCBpcyBtaXNzaW5nIGluIHRoaXMgY29udGV4dFxuICAgIGNvbnN0IHVzZXJUb0NoYXJnZSA9IHVzZXJJZCA/IGF3YWl0IFVzZXIuZmluZEJ5SWQodXNlcklkKSA6IG51bGw7XG5cbiAgICAvLyBDcmVhdGUgY3VzdG9tZXIgaWYgbmVlZGVkIChzaW1wbGlmaWVkIGxvZ2ljKVxuICAgIGxldCBjdXN0b21lcklkID0gdXNlclRvQ2hhcmdlPy5zdHJpcGVDdXN0b21lcklkO1xuICAgIGlmICh1c2VyVG9DaGFyZ2UgJiYgIWN1c3RvbWVySWQpIHtcbiAgICAgIGNvbnN0IGN1c3RvbWVyID0gYXdhaXQgc3RyaXBlU2VydmljZS5jcmVhdGVDdXN0b21lcih1c2VyVG9DaGFyZ2UuZW1haWwsIHVzZXJUb0NoYXJnZS5uYW1lKTtcbiAgICAgIGN1c3RvbWVySWQgPSBjdXN0b21lci5pZDtcbiAgICAgIHVzZXJUb0NoYXJnZS5zdHJpcGVDdXN0b21lcklkID0gY3VzdG9tZXJJZDtcbiAgICAgIGF3YWl0IHVzZXJUb0NoYXJnZS5zYXZlKCk7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIHRlc3Rpbmcgd2l0aG91dCBEQlxuICAgIGlmICghY3VzdG9tZXJJZCkge1xuICAgICAgLy8gQ3JlYXRlIGEgZ3Vlc3QgY3VzdG9tZXIganVzdCBmb3IgdGhlIHNlc3Npb24gaWYgd2UgZG9uJ3QgaGF2ZSBhIHVzZXJcbiAgICAgIC8vIE9yIHRocm93IGVycm9yIGluIHN0cmljdCBtb2RlLiBGb3Igbm93LCB3ZSdsbCBhc3N1bWUgd2UgbmVlZCBhIHVzZXIuXG4gICAgICByZXR1cm4gcmVzXG4gICAgICAgIC5zdGF0dXMoNDAwKVxuICAgICAgICAuanNvbihidWlsZEVycm9yKCdVc2VyIG5vdCBmb3VuZCBvciBubyBjdXN0b21lciBJRCcsICdVU0VSX0VSUk9SJywgNDAwLCByZXF1ZXN0SWQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgc3RyaXBlU2VydmljZS5jcmVhdGVTdWJzY3JpcHRpb25DaGVja291dFNlc3Npb24oXG4gICAgICBjdXN0b21lcklkLFxuICAgICAgcHJpY2VJZCxcbiAgICAgIHN1Y2Nlc3NVcmwsXG4gICAgICBjYW5jZWxVcmwsXG4gICAgKTtcblxuICAgIHJldHVybiByZXMuanNvbihidWlsZFJlc3BvbnNlKHsgc2Vzc2lvbklkOiBzZXNzaW9uLmlkLCB1cmw6IHNlc3Npb24udXJsIH0sIDIwMCwgcmVxdWVzdElkKSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBsb2dnZXIuZXJyb3IoZXJyb3IsICdDaGVja291dCBzZXNzaW9uIGNyZWF0aW9uIGZhaWxlZCcpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbihidWlsZEVycm9yKGVycm9yLm1lc3NhZ2UsICdTVFJJUEVfRVJST1InLCA1MDAsIHJlcXVlc3RJZCkpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAb3BlbmFwaVxuICogL3N0cmlwZS93ZWJob29rOlxuICogICBwb3N0OlxuICogICAgIHN1bW1hcnk6IFN0cmlwZSB3ZWJob29rIGVuZHBvaW50XG4gKiAgICAgdGFnczogW1N0cmlwZV1cbiAqICAgICByZXF1ZXN0Qm9keTpcbiAqICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gKiAgICAgICBjb250ZW50OlxuICogICAgICAgICBhcHBsaWNhdGlvbi9qc29uOlxuICogICAgICAgICAgIHNjaGVtYTpcbiAqICAgICAgICAgICAgIHR5cGU6IG9iamVjdFxuICogICAgIHJlc3BvbnNlczpcbiAqICAgICAgIDIwMDpcbiAqICAgICAgICAgZGVzY3JpcHRpb246IFdlYmhvb2sgcHJvY2Vzc2VkXG4gKiAgICAgICA0MDA6XG4gKiAgICAgICAgIGRlc2NyaXB0aW9uOiBCYWQgcmVxdWVzdFxuICovXG5zdHJpcGVSb3V0ZXIucG9zdCgnL3dlYmhvb2snLCBhc3luYyAocmVxOiBhbnksIHJlczogYW55KSA9PiB7XG4gIGNvbnN0IHNpZyA9IHJlcS5oZWFkZXJzWydzdHJpcGUtc2lnbmF0dXJlJ107XG4gIGNvbnN0IHJhd0JvZHkgPSByZXEucmF3Qm9keTtcblxuICBpZiAoIXNpZyB8fCAhcmF3Qm9keSkge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuc2VuZCgnV2ViaG9vayBFcnJvcjogTWlzc2luZyBzaWduYXR1cmUgb3IgYm9keScpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBldmVudCA9IHN0cmlwZVNlcnZpY2UuY29uc3RydWN0RXZlbnQocmF3Qm9keSwgc2lnIGFzIHN0cmluZyk7IC8vIENhc3QgcmVxLmJvZHkgdG8gYnVmZmVyPyBObywgdXNlIHJhd0JvZHkgc3RyaW5nL2J1ZmZlclxuXG4gICAgbG9nZ2VyLmluZm8oYFN0cmlwZSBldmVudCByZWNlaXZlZDogJHtldmVudC50eXBlfWApO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBldmVudFxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnY2hlY2tvdXQuc2Vzc2lvbi5jb21wbGV0ZWQnOlxuICAgICAgICBjb25zdCBzZXNzaW9uID0gZXZlbnQuZGF0YS5vYmplY3QgYXMgYW55O1xuICAgICAgICBsb2dnZXIuaW5mbyhgQ2hlY2tvdXQgc2Vzc2lvbiBjb21wbGV0ZWQgZm9yICR7c2Vzc2lvbi5jdXN0b21lcn1gKTtcbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHVzZXIgc3Vic2NyaXB0aW9uIHN0YXR1c1xuICAgICAgICBpZiAoc2Vzc2lvbi5jdXN0b21lcikge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmZpbmRPbmUoeyBzdHJpcGVDdXN0b21lcklkOiBzZXNzaW9uLmN1c3RvbWVyIH0pO1xuICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICB1c2VyLnN1YnNjcmlwdGlvblN0YXR1cyA9ICdhY3RpdmUnO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgIHVzZXIuc3Vic2NyaXB0aW9uSWQgPSBzZXNzaW9uLnN1YnNjcmlwdGlvbiBhcyBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB1c2VyLnNhdmUoKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBVc2VyICR7dXNlci5lbWFpbH0gc3Vic2NyaXB0aW9uIGFjdGl2YXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY3VzdG9tZXIuc3Vic2NyaXB0aW9uLmRlbGV0ZWQnOlxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBldmVudC5kYXRhLm9iamVjdCBhcyBhbnk7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmZpbmRPbmUoeyBzdWJzY3JpcHRpb25JZDogc3Vic2NyaXB0aW9uLmlkIH0pO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIHVzZXIuc3Vic2NyaXB0aW9uU3RhdHVzID0gJ2NhbmNlbGVkJztcbiAgICAgICAgICBhd2FpdCB1c2VyLnNhdmUoKTtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgVXNlciAke3VzZXIuZW1haWx9IHN1YnNjcmlwdGlvbiBjYW5jZWxlZGApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgLy8gbG9nZ2VyLmluZm8oYFVuaGFuZGxlZCBldmVudCB0eXBlICR7ZXZlbnQudHlwZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLmpzb24oeyByZWNlaXZlZDogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBsb2dnZXIuZXJyb3IoYFdlYmhvb2sgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5zZW5kKGBXZWJob29rIEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3RyaXBlUm91dGVyO1xuIl0sInZlcnNpb24iOjN9