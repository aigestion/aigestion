a20d18a6e2330ff8bbd2ddf7a79b3169
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.neuralHealthService = exports.NeuralHealthService = void 0;
const os_1 = __importDefault(require("os"));
const events_1 = require("events");
class NeuralHealthService extends events_1.EventEmitter {
    static instance;
    metrics;
    constructor() {
        super();
        this.metrics = this.calculateInitialMetrics();
        this.startMonitoring();
    }
    static getInstance() {
        if (!NeuralHealthService.instance) {
            NeuralHealthService.instance = new NeuralHealthService();
        }
        return NeuralHealthService.instance;
    }
    calculateInitialMetrics() {
        return {
            cpuUsage: 0,
            memoryUsage: 0,
            uptime: process.uptime(),
            sanityScore: 100,
            status: 'OPTIMAL',
            timestamp: new Date().toISOString(),
        };
    }
    startMonitoring() {
        setInterval(() => {
            this.updateMetrics();
            this.emit('healthUpdate', this.metrics);
        }, 5000);
    }
    updateMetrics() {
        const totalMem = os_1.default.totalmem();
        const freeMem = os_1.default.freemem();
        const memUsage = ((totalMem - freeMem) / totalMem) * 100;
        // Simulación de carga de CPU (basada en el número de procesos activos en el sistema)
        const cpuUsage = Math.random() * 20; // En un entorno real usaríamos librerías como 'node-os-utils'
        let sanityScore = 100 - cpuUsage * 0.5 - memUsage * 0.3;
        sanityScore = Math.max(0, Math.min(100, sanityScore));
        let status = 'OPTIMAL';
        if (sanityScore < 30)
            status = 'CRITICAL';
        else if (sanityScore < 70)
            status = 'DEGRADED';
        this.metrics = {
            cpuUsage,
            memoryUsage: memUsage,
            uptime: process.uptime(),
            sanityScore,
            status,
            timestamp: new Date().toISOString(),
        };
        if (status !== 'OPTIMAL') {
            this.emit('healthWarning', this.metrics);
        }
    }
    getMetrics() {
        return this.metrics;
    }
}
exports.NeuralHealthService = NeuralHealthService;
exports.neuralHealthService = NeuralHealthService.getInstance();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcTmV1cmFsSGVhbHRoU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw0Q0FBb0I7QUFDcEIsbUNBQXNDO0FBV3RDLE1BQWEsbUJBQW9CLFNBQVEscUJBQVk7SUFDM0MsTUFBTSxDQUFDLFFBQVEsQ0FBc0I7SUFDckMsT0FBTyxDQUFnQjtJQUUvQjtRQUNFLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztRQUM5QyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVNLE1BQU0sQ0FBQyxXQUFXO1FBQ3ZCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNsQyxtQkFBbUIsQ0FBQyxRQUFRLEdBQUcsSUFBSSxtQkFBbUIsRUFBRSxDQUFDO1FBQzNELENBQUM7UUFDRCxPQUFPLG1CQUFtQixDQUFDLFFBQVEsQ0FBQztJQUN0QyxDQUFDO0lBRU8sdUJBQXVCO1FBQzdCLE9BQU87WUFDTCxRQUFRLEVBQUUsQ0FBQztZQUNYLFdBQVcsRUFBRSxDQUFDO1lBQ2QsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDeEIsV0FBVyxFQUFFLEdBQUc7WUFDaEIsTUFBTSxFQUFFLFNBQVM7WUFDakIsU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO1NBQ3BDLENBQUM7SUFDSixDQUFDO0lBRU8sZUFBZTtRQUNyQixXQUFXLENBQUMsR0FBRyxFQUFFO1lBQ2YsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMxQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRU8sYUFBYTtRQUNuQixNQUFNLFFBQVEsR0FBRyxZQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDL0IsTUFBTSxPQUFPLEdBQUcsWUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzdCLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBRXpELHFGQUFxRjtRQUNyRixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsOERBQThEO1FBRW5HLElBQUksV0FBVyxHQUFHLEdBQUcsR0FBRyxRQUFRLEdBQUcsR0FBRyxHQUFHLFFBQVEsR0FBRyxHQUFHLENBQUM7UUFDeEQsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFFdEQsSUFBSSxNQUFNLEdBQXdDLFNBQVMsQ0FBQztRQUM1RCxJQUFJLFdBQVcsR0FBRyxFQUFFO1lBQUUsTUFBTSxHQUFHLFVBQVUsQ0FBQzthQUNyQyxJQUFJLFdBQVcsR0FBRyxFQUFFO1lBQUUsTUFBTSxHQUFHLFVBQVUsQ0FBQztRQUUvQyxJQUFJLENBQUMsT0FBTyxHQUFHO1lBQ2IsUUFBUTtZQUNSLFdBQVcsRUFBRSxRQUFRO1lBQ3JCLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQ3hCLFdBQVc7WUFDWCxNQUFNO1lBQ04sU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO1NBQ3BDLENBQUM7UUFFRixJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0MsQ0FBQztJQUNILENBQUM7SUFFTSxVQUFVO1FBQ2YsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7Q0FDRjtBQW5FRCxrREFtRUM7QUFFWSxRQUFBLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDLFdBQVcsRUFBRSxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXE5ldXJhbEhlYWx0aFNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoTWV0cmljcyB7XG4gIGNwdVVzYWdlOiBudW1iZXI7XG4gIG1lbW9yeVVzYWdlOiBudW1iZXI7XG4gIHVwdGltZTogbnVtYmVyO1xuICBzYW5pdHlTY29yZTogbnVtYmVyO1xuICBzdGF0dXM6ICdPUFRJTUFMJyB8ICdERUdSQURFRCcgfCAnQ1JJVElDQUwnO1xuICB0aW1lc3RhbXA6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIE5ldXJhbEhlYWx0aFNlcnZpY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogTmV1cmFsSGVhbHRoU2VydmljZTtcbiAgcHJpdmF0ZSBtZXRyaWNzOiBIZWFsdGhNZXRyaWNzO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1ldHJpY3MgPSB0aGlzLmNhbGN1bGF0ZUluaXRpYWxNZXRyaWNzKCk7XG4gICAgdGhpcy5zdGFydE1vbml0b3JpbmcoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogTmV1cmFsSGVhbHRoU2VydmljZSB7XG4gICAgaWYgKCFOZXVyYWxIZWFsdGhTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICBOZXVyYWxIZWFsdGhTZXJ2aWNlLmluc3RhbmNlID0gbmV3IE5ldXJhbEhlYWx0aFNlcnZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIE5ldXJhbEhlYWx0aFNlcnZpY2UuaW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUluaXRpYWxNZXRyaWNzKCk6IEhlYWx0aE1ldHJpY3Mge1xuICAgIHJldHVybiB7XG4gICAgICBjcHVVc2FnZTogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAwLFxuICAgICAgdXB0aW1lOiBwcm9jZXNzLnVwdGltZSgpLFxuICAgICAgc2FuaXR5U2NvcmU6IDEwMCxcbiAgICAgIHN0YXR1czogJ09QVElNQUwnLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRNb25pdG9yaW5nKCkge1xuICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWV0cmljcygpO1xuICAgICAgdGhpcy5lbWl0KCdoZWFsdGhVcGRhdGUnLCB0aGlzLm1ldHJpY3MpO1xuICAgIH0sIDUwMDApO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVNZXRyaWNzKCkge1xuICAgIGNvbnN0IHRvdGFsTWVtID0gb3MudG90YWxtZW0oKTtcbiAgICBjb25zdCBmcmVlTWVtID0gb3MuZnJlZW1lbSgpO1xuICAgIGNvbnN0IG1lbVVzYWdlID0gKCh0b3RhbE1lbSAtIGZyZWVNZW0pIC8gdG90YWxNZW0pICogMTAwO1xuXG4gICAgLy8gU2ltdWxhY2nDs24gZGUgY2FyZ2EgZGUgQ1BVIChiYXNhZGEgZW4gZWwgbsO6bWVybyBkZSBwcm9jZXNvcyBhY3Rpdm9zIGVuIGVsIHNpc3RlbWEpXG4gICAgY29uc3QgY3B1VXNhZ2UgPSBNYXRoLnJhbmRvbSgpICogMjA7IC8vIEVuIHVuIGVudG9ybm8gcmVhbCB1c2Fyw61hbW9zIGxpYnJlcsOtYXMgY29tbyAnbm9kZS1vcy11dGlscydcblxuICAgIGxldCBzYW5pdHlTY29yZSA9IDEwMCAtIGNwdVVzYWdlICogMC41IC0gbWVtVXNhZ2UgKiAwLjM7XG4gICAgc2FuaXR5U2NvcmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHNhbml0eVNjb3JlKSk7XG5cbiAgICBsZXQgc3RhdHVzOiAnT1BUSU1BTCcgfCAnREVHUkFERUQnIHwgJ0NSSVRJQ0FMJyA9ICdPUFRJTUFMJztcbiAgICBpZiAoc2FuaXR5U2NvcmUgPCAzMCkgc3RhdHVzID0gJ0NSSVRJQ0FMJztcbiAgICBlbHNlIGlmIChzYW5pdHlTY29yZSA8IDcwKSBzdGF0dXMgPSAnREVHUkFERUQnO1xuXG4gICAgdGhpcy5tZXRyaWNzID0ge1xuICAgICAgY3B1VXNhZ2UsXG4gICAgICBtZW1vcnlVc2FnZTogbWVtVXNhZ2UsXG4gICAgICB1cHRpbWU6IHByb2Nlc3MudXB0aW1lKCksXG4gICAgICBzYW5pdHlTY29yZSxcbiAgICAgIHN0YXR1cyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICBpZiAoc3RhdHVzICE9PSAnT1BUSU1BTCcpIHtcbiAgICAgIHRoaXMuZW1pdCgnaGVhbHRoV2FybmluZycsIHRoaXMubWV0cmljcyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldE1ldHJpY3MoKTogSGVhbHRoTWV0cmljcyB7XG4gICAgcmV0dXJuIHRoaXMubWV0cmljcztcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbmV1cmFsSGVhbHRoU2VydmljZSA9IE5ldXJhbEhlYWx0aFNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiJdLCJ2ZXJzaW9uIjozfQ==