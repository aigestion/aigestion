{"file":"C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\SovereignHealingService.ts","mappings":"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","names":[],"sources":["C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\SovereignHealingService.ts"],"sourcesContent":["import { injectable, inject } from 'inversify';\r\nimport { TYPES } from '../types';\r\nimport { MonitoringService } from './monitoring.service';\r\nimport { logger } from '../utils/logger';\r\nimport { VaultService } from './vault.service';\r\nimport { IMissionRepository } from '../infrastructure/repository/MissionRepository';\r\nimport { MissionStatus, Mission } from '../models/Mission';\r\nimport { deriveMissionKey } from '../utils/secrets';\r\nimport crypto from 'node:crypto';\r\n\r\nexport enum HealingAction {\r\n  RESTART_CONTAINER = 'RESTART_CONTAINER',\r\n  PRUNE_CACHE = 'PRUNE_CACHE',\r\n  SCALE_INSTANCES = 'SCALE_INSTANCES',\r\n  REBOOT_SYSTEM = 'REBOOT_SYSTEM'\r\n}\r\n\r\nexport interface HealingProposal {\r\n  id: string;\r\n  condition: string;\r\n  action: HealingAction;\r\n  target: string;\r\n  impact: 'low' | 'medium' | 'high';\r\n  status: 'pending' | 'approved' | 'rejected' | 'executed';\r\n  createdAt: Date;\r\n}\r\n\r\n@injectable()\r\nexport class SovereignHealingService {\r\n  constructor(\r\n    @inject(TYPES.MonitoringService) private monitoringService: MonitoringService,\r\n    @inject(TYPES.VaultService) private vaultService: VaultService,\r\n    @inject(TYPES.MissionRepository) private missionRepo: IMissionRepository\r\n  ) {\r\n    // Start monitoring loop\r\n    if (process.env.NODE_ENV !== 'test') {\r\n       this.startHealingMonitor();\r\n    }\r\n  }\r\n\r\n  private startHealingMonitor() {\r\n    setInterval(() => {\r\n      this.auditSystemHealth();\r\n    }, 60000); // Audit every minute\r\n  }\r\n\r\n  public async auditSystemHealth() {\r\n    try {\r\n      const overview = await this.monitoringService.getMetricsOverview();\r\n      const alerts = await this.monitoringService.getRecentAlerts(20);\r\n\r\n      const activeCriticalAlerts = alerts.filter(a => !a.resolved && a.severity === 'critical');\r\n\r\n      for (const alert of activeCriticalAlerts) {\r\n        await this.generateHealingProposal(alert);\r\n      }\r\n    } catch (error) {\r\n      logger.error('[SovereignHealing] Health audit failed:', error);\r\n    }\r\n  }\r\n\r\n  private async generateHealingProposal(alert: any) {\r\n    const proposalId = `heal_${crypto.randomBytes(4).toString('hex')}`;\r\n    \r\n    // Logic to determine action based on alert name/metadata\r\n    let action: HealingAction = HealingAction.PRUNE_CACHE;\r\n    let target = 'system';\r\n    let impact: 'low' | 'medium' | 'high' = 'low';\r\n\r\n    if (alert.name.includes('memory')) {\r\n        action = HealingAction.PRUNE_CACHE;\r\n        target = 'redis/node-heap';\r\n        impact = 'low';\r\n    } else if (alert.name.includes('cpu')) {\r\n        action = HealingAction.RESTART_CONTAINER;\r\n        target = alert.metadata?.container || 'backend-api';\r\n        impact = 'medium';\r\n    }\r\n\r\n    logger.info({ proposalId, alert: alert.name }, '[SovereignHealing] Generating repair proposal');\r\n\r\n    // Create a special \"Healing Mission\" to store the proposal\r\n    // This allows us to use the existing E2EE infrastructure\r\n    const masterSeed = process.env.JWT_SECRET || 'SOVEREIGN_REPAIR_SEED';\r\n    const missionKey = await deriveMissionKey(masterSeed, proposalId, 'SYSTEM');\r\n\r\n    const proposal: HealingProposal = {\r\n      id: proposalId,\r\n      condition: alert.message,\r\n      action,\r\n      target,\r\n      impact,\r\n      status: 'pending',\r\n      createdAt: new Date()\r\n    };\r\n\r\n    const encryptedProposal = await this.vaultService.encrypt(\r\n        JSON.stringify(proposal), \r\n        missionKey.toString('hex')\r\n    );\r\n\r\n    await this.missionRepo.create({\r\n      id: proposalId,\r\n      objective: `[AUTO-HEAL] ${action} on ${target}`,\r\n      status: MissionStatus.PLANNING, // PLANNING means it's awaiting approval\r\n      userId: 'SYSTEM',\r\n      isEncrypted: true,\r\n      result: encryptedProposal.ciphertext,\r\n      vaultIV: encryptedProposal.iv,\r\n      vaultTag: encryptedProposal.tag,\r\n      metadata: { \r\n          isHealingProposal: true,\r\n          originalAlertId: alert.id\r\n      }\r\n    });\r\n\r\n    logger.warn({ proposalId }, '[SovereignHealing] Repair proposal stored. Awaiting approval.');\r\n  }\r\n\r\n  public async executeRepair(proposalId: string, approved: boolean) {\r\n      if (!approved) {\r\n          await this.missionRepo.update(proposalId, { status: MissionStatus.FAILED, error: 'Authorization Denied' });\r\n          return;\r\n      }\r\n\r\n      // In Phase 12, we'd trigger actual infrastructure commands here\r\n      logger.info({ proposalId }, '[SovereignHealing] Executing authorized repair...');\r\n      \r\n      // Update mission to COMPLETED\r\n      await this.missionRepo.update(proposalId, { status: MissionStatus.COMPLETED });\r\n  }\r\n}\r\n"],"version":3}