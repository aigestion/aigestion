b0cbb4bd9bb8e6942efc5f28e132b755
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('node-fetch', () => jest.fn());
// Mock the env configuration
jest.mock('../config/env.schema', () => ({
    env: {
        MCP_SERVER_URL: 'http://dummy-mcp.local',
    },
}));
const node_fetch_1 = __importDefault(require("node-fetch"));
const supertest_1 = __importDefault(require("supertest"));
const app_1 = require("../app");
const { Response } = jest.requireActual('node-fetch');
describe('MCP health route', () => {
    beforeAll(() => {
        process.env.MCP_SERVER_URL = 'http://dummy-mcp.local';
    });
    it('should return ok when MCP server responds', async () => {
        node_fetch_1.default.mockResolvedValue(new Response(JSON.stringify({ status: 'ok' }), { status: 200 }));
        const response = await (0, supertest_1.default)(app_1.app).get('/mcp/health');
        expect(response.status).toBe(200);
        expect(response.body).toHaveProperty('status', 'ok');
        expect(response.body).toHaveProperty('mcp');
        expect(response.body.mcp).toHaveProperty('status', 'ok');
    });
    it('should return 502 when MCP server is unreachable', async () => {
        node_fetch_1.default.mockRejectedValue(new Error('Network error'));
        const response = await (0, supertest_1.default)(app_1.app).get('/mcp/health');
        expect(response.status).toBe(502);
        expect(response.body).toHaveProperty('error', 'Failed to reach MCP server');
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxfX3Rlc3RzX19cXG1jcC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBS0EsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFHekMsNkJBQTZCO0FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUN2QyxHQUFHLEVBQUU7UUFDSCxjQUFjLEVBQUUsd0JBQXdCO0tBQ3pDO0NBQ0YsQ0FBQyxDQUFDLENBQUM7QUFiSiw0REFBK0I7QUFDL0IsMERBQWdDO0FBRWhDLGdDQUE2QjtBQUc3QixNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQVN0RCxRQUFRLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFO0lBQ2hDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDYixPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsR0FBRyx3QkFBd0IsQ0FBQztJQUN4RCxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQywyQ0FBMkMsRUFBRSxLQUFLLElBQUksRUFBRTtRQUN4RCxvQkFBMkMsQ0FBQyxpQkFBaUIsQ0FDNUQsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQ2hFLENBQUM7UUFDRixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUEsbUJBQU8sRUFBQyxTQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3JELE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDM0QsQ0FBQyxDQUFDLENBQUM7SUFFSCxFQUFFLENBQUMsa0RBQWtELEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDL0Qsb0JBQTJDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztRQUMzRixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUEsbUJBQU8sRUFBQyxTQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLDRCQUE0QixDQUFDLENBQUM7SUFDOUUsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFsZWphbmRyb1xcQUlHZXN0aW9uXFxiYWNrZW5kXFxzcmNcXF9fdGVzdHNfX1xcbWNwLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSAnc3VwZXJ0ZXN0JztcblxuaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuamVzdC5tb2NrKCdub2RlLWZldGNoJywgKCkgPT4gamVzdC5mbigpKTtcbmNvbnN0IHsgUmVzcG9uc2UgfSA9IGplc3QucmVxdWlyZUFjdHVhbCgnbm9kZS1mZXRjaCcpO1xuXG4vLyBNb2NrIHRoZSBlbnYgY29uZmlndXJhdGlvblxuamVzdC5tb2NrKCcuLi9jb25maWcvZW52LnNjaGVtYScsICgpID0+ICh7XG4gIGVudjoge1xuICAgIE1DUF9TRVJWRVJfVVJMOiAnaHR0cDovL2R1bW15LW1jcC5sb2NhbCcsXG4gIH0sXG59KSk7XG5cbmRlc2NyaWJlKCdNQ1AgaGVhbHRoIHJvdXRlJywgKCkgPT4ge1xuICBiZWZvcmVBbGwoKCkgPT4ge1xuICAgIHByb2Nlc3MuZW52Lk1DUF9TRVJWRVJfVVJMID0gJ2h0dHA6Ly9kdW1teS1tY3AubG9jYWwnO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBvayB3aGVuIE1DUCBzZXJ2ZXIgcmVzcG9uZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgKGZldGNoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGZldGNoPikubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBzdGF0dXM6ICdvaycgfSksIHsgc3RhdHVzOiAyMDAgfSksXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoYXBwKS5nZXQoJy9tY3AvaGVhbHRoJyk7XG4gICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgIGV4cGVjdChyZXNwb25zZS5ib2R5KS50b0hhdmVQcm9wZXJ0eSgnc3RhdHVzJywgJ29rJyk7XG4gICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvSGF2ZVByb3BlcnR5KCdtY3AnKTtcbiAgICBleHBlY3QocmVzcG9uc2UuYm9keS5tY3ApLnRvSGF2ZVByb3BlcnR5KCdzdGF0dXMnLCAnb2snKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gNTAyIHdoZW4gTUNQIHNlcnZlciBpcyB1bnJlYWNoYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAoZmV0Y2ggYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZmV0Y2g+KS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGFwcCkuZ2V0KCcvbWNwL2hlYWx0aCcpO1xuICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAyKTtcbiAgICBleHBlY3QocmVzcG9uc2UuYm9keSkudG9IYXZlUHJvcGVydHkoJ2Vycm9yJywgJ0ZhaWxlZCB0byByZWFjaCBNQ1Agc2VydmVyJyk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=