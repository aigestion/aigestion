3f9124dbc7c06c52e5b0507110dc3c94
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const inversify_1 = require("inversify");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const crypto_1 = __importDefault(require("crypto"));
const RegisterUserUseCase_1 = require("../application/usecases/RegisterUserUseCase");
const Verify2FALoginUseCase_1 = require("../application/usecases/Verify2FALoginUseCase");
const LoginUserUseCase_1 = require("../application/usecases/LoginUserUseCase");
const types_1 = require("../types");
const config_1 = require("../config");
const VerifyEmailUseCase_1 = require("../application/usecases/VerifyEmailUseCase");
const UpdateUserRoleUseCase_1 = require("../application/usecases/UpdateUserRoleUseCase");
const UpdateSubscriptionUseCase_1 = require("../application/usecases/UpdateSubscriptionUseCase");
let AuthService = class AuthService {
    userRepository;
    registerUseCase;
    loginUseCase;
    verify2FALoginUseCase;
    verifyEmailUseCase;
    updateUserRoleUseCase;
    updateSubscriptionUseCase;
    constructor(userRepository, registerUseCase, loginUseCase, verify2FALoginUseCase, verifyEmailUseCase, updateUserRoleUseCase, updateSubscriptionUseCase) {
        this.userRepository = userRepository;
        this.registerUseCase = registerUseCase;
        this.loginUseCase = loginUseCase;
        this.verify2FALoginUseCase = verify2FALoginUseCase;
        this.verifyEmailUseCase = verifyEmailUseCase;
        this.updateUserRoleUseCase = updateUserRoleUseCase;
        this.updateSubscriptionUseCase = updateSubscriptionUseCase;
    }
    /**
     * Register a new user
     */
    async register(data) {
        // Delegate to RegisterUserUseCase
        return this.registerUseCase.execute(data);
    }
    /**
     * Login user
     */
    async login(data) {
        // Delegate to LoginUserUseCase
        return this.loginUseCase.execute(data);
    }
    /**
     * Verify email with code
     */
    async verifyEmail(userId, code) {
        return this.verifyEmailUseCase.execute(userId, code);
    }
    /**
     * Update user role (Family/Professional)
     */
    async updateUserRole(userId, role) {
        return this.updateUserRoleUseCase.execute(userId, role);
    }
    /**
     * Update user subscription plan
     */
    async updateSubscription(userId, plan) {
        return this.updateSubscriptionUseCase.execute(userId, plan);
    }
    /**
     * Verify 2FA and complete login
     */
    async verifyLogin2FA(data) {
        return this.verify2FALoginUseCase.execute(data);
    }
    /**
     * Get user profile
     */
    async getUserProfile(userId) {
        return this.userRepository.findById(userId);
    }
    /**
     * Refresh Token
     */
    async refreshToken(token, ip, userAgent) {
        const user = await this.userRepository.findOne({ 'refreshTokens.token': token });
        if (!user) {
            // REUSE DETECTION: If we can't find the token, it might have been rotated already.
            // If we decode it and find a valid familyId, we must invalidate the whole family.
            try {
                const decoded = jsonwebtoken_1.default.verify(token, config_1.config.jwt.secret);
                if (decoded.familyId) {
                    // This is a "Reused Token"! Danger!
                    // Find the user who owns this familyId
                    const compromisedUser = await this.userRepository.findOne({
                        'refreshTokens.familyId': decoded.familyId,
                    });
                    if (compromisedUser) {
                        // Invalidate ALL tokens for this family
                        const newRefreshTokens = compromisedUser.refreshTokens.filter(t => t.familyId !== decoded.familyId);
                        await this.userRepository.update(compromisedUser.id, {
                            refreshTokens: newRefreshTokens,
                        });
                        throw new Error('REFRESH_TOKEN_REUSE_DETECTED');
                    }
                }
            }
            catch (err) {
                if (err.message === 'REFRESH_TOKEN_REUSE_DETECTED') {
                    throw err;
                }
                // Ignore verify errors, just throw invalid
            }
            throw new Error('INVALID_REFRESH_TOKEN');
        }
        // Token found. Verify it's valid and not expired.
        const currentToken = user.refreshTokens.find(t => t.token === token);
        if (!currentToken) {
            throw new Error('INVALID_REFRESH_TOKEN'); // Should not happen given query
        }
        // Check expiry
        if (new Date() > currentToken.expires) {
            // Remove expired token
            await this.userRepository.removeRefreshToken(token);
            throw new Error('REFRESH_TOKEN_EXPIRED');
        }
        // Rotate: Replace old token with new one in the same family
        const newFamilyId = currentToken.familyId; // Keep family ID
        const newRefreshToken = this.generateRefreshTokenString(user, newFamilyId);
        // Remove used token and add new one
        // Note: We can't easily rely on atomic operations here if we want to replace ONE token and push ANOTHER.
        // We already have the user object. Let's manipulate the array and save.
        // However, concurrency might be an issue?
        // User object in memory `user.refreshTokens` is outdated compared to DB?
        // `this.userRepository.findOne` fetches fresh.
        const validTokens = user.refreshTokens.filter(t => t.token !== token);
        validTokens.push({
            token: newRefreshToken,
            expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
            familyId: newFamilyId,
            ip,
            userAgent,
            createdAt: new Date(),
        }); // Cast to any to avoid strict checking on subdoc methods? Or interface matches?
        // Clean up old tokens (limit 50)
        let finalTokens = validTokens;
        if (validTokens.length > 50) {
            finalTokens = validTokens.slice(-50);
        }
        // Update user
        await this.userRepository.update(user.id, { refreshTokens: finalTokens });
        // Fetch updated user to ensure consistency? Not needed, just return access token.
        const accessToken = this.generateToken(user, { ip, userAgent });
        return { user, accessToken, refreshToken: newRefreshToken };
    }
    generateToken(user, fingerprint) {
        const payload = {
            id: user._id ?? user.id, // Handle both id and _id
            email: user.email,
            role: user.role,
        };
        if (fingerprint) {
            payload.fingerprint = {
                ip: fingerprint.ip || 'unknown',
                userAgent: fingerprint.userAgent || 'unknown',
            };
        }
        return jsonwebtoken_1.default.sign(payload, config_1.config.jwt.secret, { expiresIn: config_1.config.jwt.expiresIn });
    }
    generateRefreshTokenString(user, familyId) {
        const payload = {
            id: user._id ?? user.id,
            familyId: familyId || crypto_1.default.randomUUID(), // New family if not provided
            type: 'refresh',
            nonce: crypto_1.default.randomUUID(), // Ensure uniqueness even if signed in the same second
        };
        return jsonwebtoken_1.default.sign(payload, config_1.config.jwt.secret, { expiresIn: '7d' });
    }
    async logout(refreshToken) {
        await this.userRepository.removeRefreshToken(refreshToken);
    }
};
exports.AuthService = AuthService;
exports.AuthService = AuthService = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.UserRepository)),
    __param(1, (0, inversify_1.inject)(types_1.TYPES.RegisterUserUseCase)),
    __param(2, (0, inversify_1.inject)(types_1.TYPES.LoginUserUseCase)),
    __param(3, (0, inversify_1.inject)(types_1.TYPES.Verify2FALoginUseCase)),
    __param(4, (0, inversify_1.inject)(types_1.TYPES.VerifyEmailUseCase)),
    __param(5, (0, inversify_1.inject)(types_1.TYPES.UpdateUserRoleUseCase)),
    __param(6, (0, inversify_1.inject)(types_1.TYPES.UpdateSubscriptionUseCase)),
    __metadata("design:paramtypes", [Object, typeof (_a = typeof RegisterUserUseCase_1.RegisterUserUseCase !== "undefined" && RegisterUserUseCase_1.RegisterUserUseCase) === "function" ? _a : Object, typeof (_b = typeof LoginUserUseCase_1.LoginUserUseCase !== "undefined" && LoginUserUseCase_1.LoginUserUseCase) === "function" ? _b : Object, typeof (_c = typeof Verify2FALoginUseCase_1.Verify2FALoginUseCase !== "undefined" && Verify2FALoginUseCase_1.Verify2FALoginUseCase) === "function" ? _c : Object, typeof (_d = typeof VerifyEmailUseCase_1.VerifyEmailUseCase !== "undefined" && VerifyEmailUseCase_1.VerifyEmailUseCase) === "function" ? _d : Object, typeof (_e = typeof UpdateUserRoleUseCase_1.UpdateUserRoleUseCase !== "undefined" && UpdateUserRoleUseCase_1.UpdateUserRoleUseCase) === "function" ? _e : Object, typeof (_f = typeof UpdateSubscriptionUseCase_1.UpdateSubscriptionUseCase !== "undefined" && UpdateSubscriptionUseCase_1.UpdateSubscriptionUseCase) === "function" ? _f : Object])
], AuthService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcYXV0aC5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBK0M7QUFDL0MsZ0VBQStCO0FBQy9CLG9EQUE0QjtBQUM1QixxRkFBa0Y7QUFDbEYseUZBQXNGO0FBQ3RGLCtFQUE0RTtBQUc1RSxvQ0FBaUM7QUFDakMsc0NBQW1DO0FBRW5DLG1GQUFnRjtBQUNoRix5RkFBc0Y7QUFDdEYsaUdBQThGO0FBR3ZGLElBQU0sV0FBVyxHQUFqQixNQUFNLFdBQVc7SUFFa0I7SUFDSztJQUNIO0lBQ0s7SUFDSDtJQUNHO0lBRXJDO0lBUlYsWUFDd0MsY0FBK0IsRUFDMUIsZUFBb0MsRUFDdkMsWUFBOEIsRUFDekIscUJBQTRDLEVBQy9DLGtCQUFzQyxFQUNuQyxxQkFBNEMsRUFFakYseUJBQW9EO1FBUHRCLG1CQUFjLEdBQWQsY0FBYyxDQUFpQjtRQUMxQixvQkFBZSxHQUFmLGVBQWUsQ0FBcUI7UUFDdkMsaUJBQVksR0FBWixZQUFZLENBQWtCO1FBQ3pCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBdUI7UUFDL0MsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUNuQywwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBRWpGLDhCQUF5QixHQUF6Qix5QkFBeUIsQ0FBMkI7SUFDM0QsQ0FBQztJQUVKOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUlkO1FBQ0Msa0NBQWtDO1FBQ2xDLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUtYO1FBQ0MsK0JBQStCO1FBQy9CLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFjLEVBQUUsSUFBWTtRQUM1QyxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxjQUFjLENBQUMsTUFBYyxFQUFFLElBQStCO1FBQ2xFLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE1BQWMsRUFBRSxJQUFZO1FBQ25ELE9BQU8sSUFBSSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLGNBQWMsQ0FBQyxJQUF3RTtRQUMzRixPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFjO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFlBQVksQ0FDaEIsS0FBYSxFQUNiLEVBQVUsRUFDVixTQUFpQjtRQUVqQixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUUscUJBQXFCLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUVqRixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDVixtRkFBbUY7WUFDbkYsa0ZBQWtGO1lBQ2xGLElBQUksQ0FBQztnQkFDSCxNQUFNLE9BQU8sR0FBUSxzQkFBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsZUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDMUQsSUFBSSxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ3JCLG9DQUFvQztvQkFDcEMsdUNBQXVDO29CQUN2QyxNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO3dCQUN4RCx3QkFBd0IsRUFBRSxPQUFPLENBQUMsUUFBUTtxQkFDM0MsQ0FBQyxDQUFDO29CQUNILElBQUksZUFBZSxFQUFFLENBQUM7d0JBQ3BCLHdDQUF3Qzt3QkFDeEMsTUFBTSxnQkFBZ0IsR0FBRyxlQUFlLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FDM0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLE9BQU8sQ0FBQyxRQUFRLENBQ3JDLENBQUM7d0JBQ0YsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsRUFBRSxFQUFFOzRCQUNuRCxhQUFhLEVBQUUsZ0JBQWdCO3lCQUNoQyxDQUFDLENBQUM7d0JBQ0gsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO29CQUNsRCxDQUFDO2dCQUNILENBQUM7WUFDSCxDQUFDO1lBQUMsT0FBTyxHQUFRLEVBQUUsQ0FBQztnQkFDbEIsSUFBSSxHQUFHLENBQUMsT0FBTyxLQUFLLDhCQUE4QixFQUFFLENBQUM7b0JBQ25ELE1BQU0sR0FBRyxDQUFDO2dCQUNaLENBQUM7Z0JBQ0QsMkNBQTJDO1lBQzdDLENBQUM7WUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUVELGtEQUFrRDtRQUNsRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDLENBQUM7UUFFckUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLGdDQUFnQztRQUM1RSxDQUFDO1FBRUQsZUFBZTtRQUNmLElBQUksSUFBSSxJQUFJLEVBQUUsR0FBRyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDdEMsdUJBQXVCO1lBQ3ZCLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUVELDREQUE0RDtRQUM1RCxNQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsaUJBQWlCO1FBQzVELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFFM0Usb0NBQW9DO1FBQ3BDLHlHQUF5RztRQUN6Ryx3RUFBd0U7UUFDeEUsMENBQTBDO1FBQzFDLHlFQUF5RTtRQUN6RSwrQ0FBK0M7UUFFL0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxDQUFDO1FBRXRFLFdBQVcsQ0FBQyxJQUFJLENBQUM7WUFDZixLQUFLLEVBQUUsZUFBZTtZQUN0QixPQUFPLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxTQUFTO1lBQ2xFLFFBQVEsRUFBRSxXQUFXO1lBQ3JCLEVBQUU7WUFDRixTQUFTO1lBQ1QsU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFO1NBQ2YsQ0FBQyxDQUFDLENBQUMsZ0ZBQWdGO1FBRTNGLGlDQUFpQztRQUNqQyxJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDOUIsSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRSxDQUFDO1lBQzVCLFdBQVcsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUVELGNBQWM7UUFDZCxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUUxRSxrRkFBa0Y7UUFFbEYsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQztRQUNoRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLENBQUM7SUFDOUQsQ0FBQztJQUVPLGFBQWEsQ0FBQyxJQUFXLEVBQUUsV0FBaUQ7UUFDbEYsTUFBTSxPQUFPLEdBQVE7WUFDbkIsRUFBRSxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUUsRUFBRSx5QkFBeUI7WUFDbEQsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1lBQ2pCLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtTQUNoQixDQUFDO1FBRUYsSUFBSSxXQUFXLEVBQUUsQ0FBQztZQUNoQixPQUFPLENBQUMsV0FBVyxHQUFHO2dCQUNwQixFQUFFLEVBQUUsV0FBVyxDQUFDLEVBQUUsSUFBSSxTQUFTO2dCQUMvQixTQUFTLEVBQUUsV0FBVyxDQUFDLFNBQVMsSUFBSSxTQUFTO2FBQzlDLENBQUM7UUFDSixDQUFDO1FBRUQsT0FBTyxzQkFBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsZUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsZUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFnQixFQUFFLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQsMEJBQTBCLENBQUMsSUFBVyxFQUFFLFFBQWlCO1FBQ3ZELE1BQU0sT0FBTyxHQUFHO1lBQ2QsRUFBRSxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUU7WUFDdkIsUUFBUSxFQUFFLFFBQVEsSUFBSSxnQkFBTSxDQUFDLFVBQVUsRUFBRSxFQUFFLDZCQUE2QjtZQUN4RSxJQUFJLEVBQUUsU0FBUztZQUNmLEtBQUssRUFBRSxnQkFBTSxDQUFDLFVBQVUsRUFBRSxFQUFFLHNEQUFzRDtTQUNuRixDQUFDO1FBQ0YsT0FBTyxzQkFBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsZUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxZQUFvQjtRQUMvQixNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDN0QsQ0FBQztDQUNGLENBQUE7QUFsTVksa0NBQVc7c0JBQVgsV0FBVztJQUR2QixJQUFBLHNCQUFVLEdBQUU7SUFHUixXQUFBLElBQUEsa0JBQU0sRUFBQyxhQUFLLENBQUMsY0FBYyxDQUFDLENBQUE7SUFDNUIsV0FBQSxJQUFBLGtCQUFNLEVBQUMsYUFBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7SUFDakMsV0FBQSxJQUFBLGtCQUFNLEVBQUMsYUFBSyxDQUFDLGdCQUFnQixDQUFDLENBQUE7SUFDOUIsV0FBQSxJQUFBLGtCQUFNLEVBQUMsYUFBSyxDQUFDLHFCQUFxQixDQUFDLENBQUE7SUFDbkMsV0FBQSxJQUFBLGtCQUFNLEVBQUMsYUFBSyxDQUFDLGtCQUFrQixDQUFDLENBQUE7SUFDaEMsV0FBQSxJQUFBLGtCQUFNLEVBQUMsYUFBSyxDQUFDLHFCQUFxQixDQUFDLENBQUE7SUFDbkMsV0FBQSxJQUFBLGtCQUFNLEVBQUMsYUFBSyxDQUFDLHlCQUF5QixDQUFDLENBQUE7aUVBTG9CLHlDQUFtQixvQkFBbkIseUNBQW1CLG9EQUN6QixtQ0FBZ0Isb0JBQWhCLG1DQUFnQixvREFDRiw2Q0FBcUIsb0JBQXJCLDZDQUFxQixvREFDM0IsdUNBQWtCLG9CQUFsQix1Q0FBa0Isb0RBQ1osNkNBQXFCLG9CQUFyQiw2Q0FBcUIsb0RBRXRELHFEQUF5QixvQkFBekIscURBQXlCO0dBVG5ELFdBQVcsQ0FrTXZCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXGF1dGguc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tICdpbnZlcnNpZnknO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgUmVnaXN0ZXJVc2VyVXNlQ2FzZSB9IGZyb20gJy4uL2FwcGxpY2F0aW9uL3VzZWNhc2VzL1JlZ2lzdGVyVXNlclVzZUNhc2UnO1xuaW1wb3J0IHsgVmVyaWZ5MkZBTG9naW5Vc2VDYXNlIH0gZnJvbSAnLi4vYXBwbGljYXRpb24vdXNlY2FzZXMvVmVyaWZ5MkZBTG9naW5Vc2VDYXNlJztcbmltcG9ydCB7IExvZ2luVXNlclVzZUNhc2UgfSBmcm9tICcuLi9hcHBsaWNhdGlvbi91c2VjYXNlcy9Mb2dpblVzZXJVc2VDYXNlJztcbmltcG9ydCB0eXBlIHsgSVVzZXJSZXBvc2l0b3J5IH0gZnJvbSAnLi4vaW5mcmFzdHJ1Y3R1cmUvcmVwb3NpdG9yeS9Vc2VyUmVwb3NpdG9yeSc7XG5pbXBvcnQgdHlwZSB7IElVc2VyIH0gZnJvbSAnLi4vbW9kZWxzL1VzZXInO1xuaW1wb3J0IHsgVFlQRVMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQgeyBWZXJpZnlFbWFpbFVzZUNhc2UgfSBmcm9tICcuLi9hcHBsaWNhdGlvbi91c2VjYXNlcy9WZXJpZnlFbWFpbFVzZUNhc2UnO1xuaW1wb3J0IHsgVXBkYXRlVXNlclJvbGVVc2VDYXNlIH0gZnJvbSAnLi4vYXBwbGljYXRpb24vdXNlY2FzZXMvVXBkYXRlVXNlclJvbGVVc2VDYXNlJztcbmltcG9ydCB7IFVwZGF0ZVN1YnNjcmlwdGlvblVzZUNhc2UgfSBmcm9tICcuLi9hcHBsaWNhdGlvbi91c2VjYXNlcy9VcGRhdGVTdWJzY3JpcHRpb25Vc2VDYXNlJztcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF1dGhTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQGluamVjdChUWVBFUy5Vc2VyUmVwb3NpdG9yeSkgcHJpdmF0ZSB1c2VyUmVwb3NpdG9yeTogSVVzZXJSZXBvc2l0b3J5LFxuICAgIEBpbmplY3QoVFlQRVMuUmVnaXN0ZXJVc2VyVXNlQ2FzZSkgcHJpdmF0ZSByZWdpc3RlclVzZUNhc2U6IFJlZ2lzdGVyVXNlclVzZUNhc2UsXG4gICAgQGluamVjdChUWVBFUy5Mb2dpblVzZXJVc2VDYXNlKSBwcml2YXRlIGxvZ2luVXNlQ2FzZTogTG9naW5Vc2VyVXNlQ2FzZSxcbiAgICBAaW5qZWN0KFRZUEVTLlZlcmlmeTJGQUxvZ2luVXNlQ2FzZSkgcHJpdmF0ZSB2ZXJpZnkyRkFMb2dpblVzZUNhc2U6IFZlcmlmeTJGQUxvZ2luVXNlQ2FzZSxcbiAgICBAaW5qZWN0KFRZUEVTLlZlcmlmeUVtYWlsVXNlQ2FzZSkgcHJpdmF0ZSB2ZXJpZnlFbWFpbFVzZUNhc2U6IFZlcmlmeUVtYWlsVXNlQ2FzZSxcbiAgICBAaW5qZWN0KFRZUEVTLlVwZGF0ZVVzZXJSb2xlVXNlQ2FzZSkgcHJpdmF0ZSB1cGRhdGVVc2VyUm9sZVVzZUNhc2U6IFVwZGF0ZVVzZXJSb2xlVXNlQ2FzZSxcbiAgICBAaW5qZWN0KFRZUEVTLlVwZGF0ZVN1YnNjcmlwdGlvblVzZUNhc2UpXG4gICAgcHJpdmF0ZSB1cGRhdGVTdWJzY3JpcHRpb25Vc2VDYXNlOiBVcGRhdGVTdWJzY3JpcHRpb25Vc2VDYXNlLFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbmV3IHVzZXJcbiAgICovXG4gIGFzeW5jIHJlZ2lzdGVyKGRhdGE6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICBwYXNzd29yZDogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx7IHVzZXI6IElVc2VyOyB0b2tlbjogc3RyaW5nOyByZWZyZXNoVG9rZW46IHN0cmluZyB9PiB7XG4gICAgLy8gRGVsZWdhdGUgdG8gUmVnaXN0ZXJVc2VyVXNlQ2FzZVxuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyVXNlQ2FzZS5leGVjdXRlKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ2luIHVzZXJcbiAgICovXG4gIGFzeW5jIGxvZ2luKGRhdGE6IHtcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gICAgaXA/OiBzdHJpbmc7XG4gICAgdXNlckFnZW50Pzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx7IHVzZXI6IElVc2VyOyB0b2tlbj86IHN0cmluZzsgcmVmcmVzaFRva2VuPzogc3RyaW5nOyBtZmFSZXF1aXJlZD86IGJvb2xlYW4gfT4ge1xuICAgIC8vIERlbGVnYXRlIHRvIExvZ2luVXNlclVzZUNhc2VcbiAgICByZXR1cm4gdGhpcy5sb2dpblVzZUNhc2UuZXhlY3V0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgZW1haWwgd2l0aCBjb2RlXG4gICAqL1xuICBhc3luYyB2ZXJpZnlFbWFpbCh1c2VySWQ6IHN0cmluZywgY29kZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyaWZ5RW1haWxVc2VDYXNlLmV4ZWN1dGUodXNlcklkLCBjb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdXNlciByb2xlIChGYW1pbHkvUHJvZmVzc2lvbmFsKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVXNlclJvbGUodXNlcklkOiBzdHJpbmcsIHJvbGU6ICdmYW1pbHknIHwgJ3Byb2Zlc3Npb25hbCcpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVVc2VyUm9sZVVzZUNhc2UuZXhlY3V0ZSh1c2VySWQsIHJvbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB1c2VyIHN1YnNjcmlwdGlvbiBwbGFuXG4gICAqL1xuICBhc3luYyB1cGRhdGVTdWJzY3JpcHRpb24odXNlcklkOiBzdHJpbmcsIHBsYW46IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvblVzZUNhc2UuZXhlY3V0ZSh1c2VySWQsIHBsYW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSAyRkEgYW5kIGNvbXBsZXRlIGxvZ2luXG4gICAqL1xuICBhc3luYyB2ZXJpZnlMb2dpbjJGQShkYXRhOiB7IHVzZXJJZDogc3RyaW5nOyB0b2tlbjogc3RyaW5nOyBpcD86IHN0cmluZzsgdXNlckFnZW50Pzogc3RyaW5nIH0pIHtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnkyRkFMb2dpblVzZUNhc2UuZXhlY3V0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlciBwcm9maWxlXG4gICAqL1xuICBhc3luYyBnZXRVc2VyUHJvZmlsZSh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8SVVzZXIgfCBudWxsPiB7XG4gICAgcmV0dXJuIHRoaXMudXNlclJlcG9zaXRvcnkuZmluZEJ5SWQodXNlcklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIFRva2VuXG4gICAqL1xuICBhc3luYyByZWZyZXNoVG9rZW4oXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBpcDogc3RyaW5nLFxuICAgIHVzZXJBZ2VudDogc3RyaW5nLFxuICApOiBQcm9taXNlPHsgdXNlcjogSVVzZXI7IGFjY2Vzc1Rva2VuOiBzdHJpbmc7IHJlZnJlc2hUb2tlbjogc3RyaW5nIH0+IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5maW5kT25lKHsgJ3JlZnJlc2hUb2tlbnMudG9rZW4nOiB0b2tlbiB9KTtcblxuICAgIGlmICghdXNlcikge1xuICAgICAgLy8gUkVVU0UgREVURUNUSU9OOiBJZiB3ZSBjYW4ndCBmaW5kIHRoZSB0b2tlbiwgaXQgbWlnaHQgaGF2ZSBiZWVuIHJvdGF0ZWQgYWxyZWFkeS5cbiAgICAgIC8vIElmIHdlIGRlY29kZSBpdCBhbmQgZmluZCBhIHZhbGlkIGZhbWlseUlkLCB3ZSBtdXN0IGludmFsaWRhdGUgdGhlIHdob2xlIGZhbWlseS5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQ6IGFueSA9IGp3dC52ZXJpZnkodG9rZW4sIGNvbmZpZy5qd3Quc2VjcmV0KTtcbiAgICAgICAgaWYgKGRlY29kZWQuZmFtaWx5SWQpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgXCJSZXVzZWQgVG9rZW5cIiEgRGFuZ2VyIVxuICAgICAgICAgIC8vIEZpbmQgdGhlIHVzZXIgd2hvIG93bnMgdGhpcyBmYW1pbHlJZFxuICAgICAgICAgIGNvbnN0IGNvbXByb21pc2VkVXNlciA9IGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkuZmluZE9uZSh7XG4gICAgICAgICAgICAncmVmcmVzaFRva2Vucy5mYW1pbHlJZCc6IGRlY29kZWQuZmFtaWx5SWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNvbXByb21pc2VkVXNlcikge1xuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBBTEwgdG9rZW5zIGZvciB0aGlzIGZhbWlseVxuICAgICAgICAgICAgY29uc3QgbmV3UmVmcmVzaFRva2VucyA9IGNvbXByb21pc2VkVXNlci5yZWZyZXNoVG9rZW5zLmZpbHRlcihcbiAgICAgICAgICAgICAgdCA9PiB0LmZhbWlseUlkICE9PSBkZWNvZGVkLmZhbWlseUlkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkudXBkYXRlKGNvbXByb21pc2VkVXNlci5pZCwge1xuICAgICAgICAgICAgICByZWZyZXNoVG9rZW5zOiBuZXdSZWZyZXNoVG9rZW5zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JFRlJFU0hfVE9LRU5fUkVVU0VfREVURUNURUQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ1JFRlJFU0hfVE9LRU5fUkVVU0VfREVURUNURUQnKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSB2ZXJpZnkgZXJyb3JzLCBqdXN0IHRocm93IGludmFsaWRcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9SRUZSRVNIX1RPS0VOJyk7XG4gICAgfVxuXG4gICAgLy8gVG9rZW4gZm91bmQuIFZlcmlmeSBpdCdzIHZhbGlkIGFuZCBub3QgZXhwaXJlZC5cbiAgICBjb25zdCBjdXJyZW50VG9rZW4gPSB1c2VyLnJlZnJlc2hUb2tlbnMuZmluZCh0ID0+IHQudG9rZW4gPT09IHRva2VuKTtcblxuICAgIGlmICghY3VycmVudFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVkFMSURfUkVGUkVTSF9UT0tFTicpOyAvLyBTaG91bGQgbm90IGhhcHBlbiBnaXZlbiBxdWVyeVxuICAgIH1cblxuICAgIC8vIENoZWNrIGV4cGlyeVxuICAgIGlmIChuZXcgRGF0ZSgpID4gY3VycmVudFRva2VuLmV4cGlyZXMpIHtcbiAgICAgIC8vIFJlbW92ZSBleHBpcmVkIHRva2VuXG4gICAgICBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LnJlbW92ZVJlZnJlc2hUb2tlbih0b2tlbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JFRlJFU0hfVE9LRU5fRVhQSVJFRCcpO1xuICAgIH1cblxuICAgIC8vIFJvdGF0ZTogUmVwbGFjZSBvbGQgdG9rZW4gd2l0aCBuZXcgb25lIGluIHRoZSBzYW1lIGZhbWlseVxuICAgIGNvbnN0IG5ld0ZhbWlseUlkID0gY3VycmVudFRva2VuLmZhbWlseUlkOyAvLyBLZWVwIGZhbWlseSBJRFxuICAgIGNvbnN0IG5ld1JlZnJlc2hUb2tlbiA9IHRoaXMuZ2VuZXJhdGVSZWZyZXNoVG9rZW5TdHJpbmcodXNlciwgbmV3RmFtaWx5SWQpO1xuXG4gICAgLy8gUmVtb3ZlIHVzZWQgdG9rZW4gYW5kIGFkZCBuZXcgb25lXG4gICAgLy8gTm90ZTogV2UgY2FuJ3QgZWFzaWx5IHJlbHkgb24gYXRvbWljIG9wZXJhdGlvbnMgaGVyZSBpZiB3ZSB3YW50IHRvIHJlcGxhY2UgT05FIHRva2VuIGFuZCBwdXNoIEFOT1RIRVIuXG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSB1c2VyIG9iamVjdC4gTGV0J3MgbWFuaXB1bGF0ZSB0aGUgYXJyYXkgYW5kIHNhdmUuXG4gICAgLy8gSG93ZXZlciwgY29uY3VycmVuY3kgbWlnaHQgYmUgYW4gaXNzdWU/XG4gICAgLy8gVXNlciBvYmplY3QgaW4gbWVtb3J5IGB1c2VyLnJlZnJlc2hUb2tlbnNgIGlzIG91dGRhdGVkIGNvbXBhcmVkIHRvIERCP1xuICAgIC8vIGB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRPbmVgIGZldGNoZXMgZnJlc2guXG5cbiAgICBjb25zdCB2YWxpZFRva2VucyA9IHVzZXIucmVmcmVzaFRva2Vucy5maWx0ZXIodCA9PiB0LnRva2VuICE9PSB0b2tlbik7XG5cbiAgICB2YWxpZFRva2Vucy5wdXNoKHtcbiAgICAgIHRva2VuOiBuZXdSZWZyZXNoVG9rZW4sXG4gICAgICBleHBpcmVzOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLCAvLyA3IGRheXNcbiAgICAgIGZhbWlseUlkOiBuZXdGYW1pbHlJZCxcbiAgICAgIGlwLFxuICAgICAgdXNlckFnZW50LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH0gYXMgYW55KTsgLy8gQ2FzdCB0byBhbnkgdG8gYXZvaWQgc3RyaWN0IGNoZWNraW5nIG9uIHN1YmRvYyBtZXRob2RzPyBPciBpbnRlcmZhY2UgbWF0Y2hlcz9cblxuICAgIC8vIENsZWFuIHVwIG9sZCB0b2tlbnMgKGxpbWl0IDUwKVxuICAgIGxldCBmaW5hbFRva2VucyA9IHZhbGlkVG9rZW5zO1xuICAgIGlmICh2YWxpZFRva2Vucy5sZW5ndGggPiA1MCkge1xuICAgICAgZmluYWxUb2tlbnMgPSB2YWxpZFRva2Vucy5zbGljZSgtNTApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB1c2VyXG4gICAgYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS51cGRhdGUodXNlci5pZCwgeyByZWZyZXNoVG9rZW5zOiBmaW5hbFRva2VucyB9KTtcblxuICAgIC8vIEZldGNoIHVwZGF0ZWQgdXNlciB0byBlbnN1cmUgY29uc2lzdGVuY3k/IE5vdCBuZWVkZWQsIGp1c3QgcmV0dXJuIGFjY2VzcyB0b2tlbi5cblxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5nZW5lcmF0ZVRva2VuKHVzZXIsIHsgaXAsIHVzZXJBZ2VudCB9KTtcbiAgICByZXR1cm4geyB1c2VyLCBhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuOiBuZXdSZWZyZXNoVG9rZW4gfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVUb2tlbih1c2VyOiBJVXNlciwgZmluZ2VycHJpbnQ/OiB7IGlwPzogc3RyaW5nOyB1c2VyQWdlbnQ/OiBzdHJpbmcgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgcGF5bG9hZDogYW55ID0ge1xuICAgICAgaWQ6IHVzZXIuX2lkID8/IHVzZXIuaWQsIC8vIEhhbmRsZSBib3RoIGlkIGFuZCBfaWRcbiAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgcm9sZTogdXNlci5yb2xlLFxuICAgIH07XG5cbiAgICBpZiAoZmluZ2VycHJpbnQpIHtcbiAgICAgIHBheWxvYWQuZmluZ2VycHJpbnQgPSB7XG4gICAgICAgIGlwOiBmaW5nZXJwcmludC5pcCB8fCAndW5rbm93bicsXG4gICAgICAgIHVzZXJBZ2VudDogZmluZ2VycHJpbnQudXNlckFnZW50IHx8ICd1bmtub3duJyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIGNvbmZpZy5qd3Quc2VjcmV0LCB7IGV4cGlyZXNJbjogY29uZmlnLmp3dC5leHBpcmVzSW4gYXMgYW55IH0pO1xuICB9XG5cbiAgZ2VuZXJhdGVSZWZyZXNoVG9rZW5TdHJpbmcodXNlcjogSVVzZXIsIGZhbWlseUlkPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgaWQ6IHVzZXIuX2lkID8/IHVzZXIuaWQsXG4gICAgICBmYW1pbHlJZDogZmFtaWx5SWQgfHwgY3J5cHRvLnJhbmRvbVVVSUQoKSwgLy8gTmV3IGZhbWlseSBpZiBub3QgcHJvdmlkZWRcbiAgICAgIHR5cGU6ICdyZWZyZXNoJyxcbiAgICAgIG5vbmNlOiBjcnlwdG8ucmFuZG9tVVVJRCgpLCAvLyBFbnN1cmUgdW5pcXVlbmVzcyBldmVuIGlmIHNpZ25lZCBpbiB0aGUgc2FtZSBzZWNvbmRcbiAgICB9O1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBjb25maWcuand0LnNlY3JldCwgeyBleHBpcmVzSW46ICc3ZCcgfSk7XG4gIH1cblxuICBhc3luYyBsb2dvdXQocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LnJlbW92ZVJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pO1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=