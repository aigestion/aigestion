b56e7b3d1736902491688606c554e819
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dynamicRateLimiter = void 0;
const express_rate_limit_1 = __importDefault(require("express-rate-limit"));
const config_1 = require("../config/config");
const logger_1 = require("../utils/logger");
/**
 * Dynamic Rate Limiter
 *
 * Applies different rate limits based on user plan/role.
 * Requires user to be authenticated (prop req.user populated).
 * Falls back to IP-based limiting if not authenticated (should be used on protected routes).
 * God/Admin roles bypass rate limiting entirely via the `skip` option.
 */
exports.dynamicRateLimiter = (0, express_rate_limit_1.default)({
    windowMs: 15 * 60 * 1000, // Default 15 minutes
    skip: (req) => {
        const user = req.user;
        // God and Admin roles bypass rate limiting entirely
        return user && (user.role === 'god' || user.role === 'admin');
    },
    max: (req) => {
        const user = req.user;
        if (!user) {
            return config_1.config.rateLimit.plans.default.max;
        }
        const plan = user.subscriptionPlan?.toLowerCase();
        switch (plan) {
            case 'pro':
            case 'premium':
                return config_1.config.rateLimit.plans.pro.max;
            case 'free':
            default:
                return config_1.config.rateLimit.plans.free.max;
        }
    },
    keyGenerator: (req) => {
        const user = req.user;
        return user ? `user:${user.id}` : `ip:${req.ip}`;
    },
    handler: (req, res, _next, options) => {
        const user = req.user;
        logger_1.logger.warn(`Rate limit exceeded for ${user ? `user ${user.id} (${user.role})` : `IP ${req.ip}`}`);
        res.status(options.statusCode).json({
            status: 'error',
            message: 'Too many requests, please try again later.',
            retryAfter: Math.ceil(options.windowMs / 1000),
        });
    },
    standardHeaders: true,
    legacyHeaders: false,
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxtaWRkbGV3YXJlXFxyYXRlLWxpbWl0Lm1pZGRsZXdhcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNEVBQTJDO0FBRTNDLDZDQUEwQztBQUMxQyw0Q0FBeUM7QUFFekM7Ozs7Ozs7R0FPRztBQUNVLFFBQUEsa0JBQWtCLEdBQUcsSUFBQSw0QkFBUyxFQUFDO0lBQzFDLFFBQVEsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksRUFBRSxxQkFBcUI7SUFDL0MsSUFBSSxFQUFFLENBQUMsR0FBa0IsRUFBRSxFQUFFO1FBQzNCLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDdEIsb0RBQW9EO1FBQ3BELE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBQ0QsR0FBRyxFQUFFLENBQUMsR0FBa0IsRUFBRSxFQUFFO1FBQzFCLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1YsT0FBTyxlQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQzVDLENBQUM7UUFDRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLENBQUM7UUFDbEQsUUFBUSxJQUFJLEVBQUUsQ0FBQztZQUNiLEtBQUssS0FBSyxDQUFDO1lBQ1gsS0FBSyxTQUFTO2dCQUNaLE9BQU8sZUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUN4QyxLQUFLLE1BQU0sQ0FBQztZQUNaO2dCQUNFLE9BQU8sZUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUMzQyxDQUFDO0lBQ0gsQ0FBQztJQUNELFlBQVksRUFBRSxDQUFDLEdBQWtCLEVBQUUsRUFBRTtRQUNuQyxNQUFNLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUNELE9BQU8sRUFBRSxDQUFDLEdBQWtCLEVBQUUsR0FBbUIsRUFBRSxLQUFVLEVBQUUsT0FBWSxFQUFFLEVBQUU7UUFDN0UsTUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUN0QixlQUFNLENBQUMsSUFBSSxDQUNULDJCQUEyQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQ3RGLENBQUM7UUFDRixHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDbEMsTUFBTSxFQUFFLE9BQU87WUFDZixPQUFPLEVBQUUsNENBQTRDO1lBQ3JELFVBQVUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQy9DLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDRCxlQUFlLEVBQUUsSUFBSTtJQUNyQixhQUFhLEVBQUUsS0FBSztDQUNyQixDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxtaWRkbGV3YXJlXFxyYXRlLWxpbWl0Lm1pZGRsZXdhcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJhdGVMaW1pdCBmcm9tICdleHByZXNzLXJhdGUtbGltaXQnO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tICdleHByZXNzJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9jb25maWcnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLyoqXG4gKiBEeW5hbWljIFJhdGUgTGltaXRlclxuICpcbiAqIEFwcGxpZXMgZGlmZmVyZW50IHJhdGUgbGltaXRzIGJhc2VkIG9uIHVzZXIgcGxhbi9yb2xlLlxuICogUmVxdWlyZXMgdXNlciB0byBiZSBhdXRoZW50aWNhdGVkIChwcm9wIHJlcS51c2VyIHBvcHVsYXRlZCkuXG4gKiBGYWxscyBiYWNrIHRvIElQLWJhc2VkIGxpbWl0aW5nIGlmIG5vdCBhdXRoZW50aWNhdGVkIChzaG91bGQgYmUgdXNlZCBvbiBwcm90ZWN0ZWQgcm91dGVzKS5cbiAqIEdvZC9BZG1pbiByb2xlcyBieXBhc3MgcmF0ZSBsaW1pdGluZyBlbnRpcmVseSB2aWEgdGhlIGBza2lwYCBvcHRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBkeW5hbWljUmF0ZUxpbWl0ZXIgPSByYXRlTGltaXQoe1xuICB3aW5kb3dNczogMTUgKiA2MCAqIDEwMDAsIC8vIERlZmF1bHQgMTUgbWludXRlc1xuICBza2lwOiAocmVxOiBSZXF1ZXN0IHwgYW55KSA9PiB7XG4gICAgY29uc3QgdXNlciA9IHJlcS51c2VyO1xuICAgIC8vIEdvZCBhbmQgQWRtaW4gcm9sZXMgYnlwYXNzIHJhdGUgbGltaXRpbmcgZW50aXJlbHlcbiAgICByZXR1cm4gdXNlciAmJiAodXNlci5yb2xlID09PSAnZ29kJyB8fCB1c2VyLnJvbGUgPT09ICdhZG1pbicpO1xuICB9LFxuICBtYXg6IChyZXE6IFJlcXVlc3QgfCBhbnkpID0+IHtcbiAgICBjb25zdCB1c2VyID0gcmVxLnVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICByZXR1cm4gY29uZmlnLnJhdGVMaW1pdC5wbGFucy5kZWZhdWx0Lm1heDtcbiAgICB9XG4gICAgY29uc3QgcGxhbiA9IHVzZXIuc3Vic2NyaXB0aW9uUGxhbj8udG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHBsYW4pIHtcbiAgICAgIGNhc2UgJ3Bybyc6XG4gICAgICBjYXNlICdwcmVtaXVtJzpcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5yYXRlTGltaXQucGxhbnMucHJvLm1heDtcbiAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5yYXRlTGltaXQucGxhbnMuZnJlZS5tYXg7XG4gICAgfVxuICB9LFxuICBrZXlHZW5lcmF0b3I6IChyZXE6IFJlcXVlc3QgfCBhbnkpID0+IHtcbiAgICBjb25zdCB1c2VyID0gcmVxLnVzZXI7XG4gICAgcmV0dXJuIHVzZXIgPyBgdXNlcjoke3VzZXIuaWR9YCA6IGBpcDoke3JlcS5pcH1gO1xuICB9LFxuICBoYW5kbGVyOiAocmVxOiBSZXF1ZXN0IHwgYW55LCByZXM6IFJlc3BvbnNlIHwgYW55LCBfbmV4dDogYW55LCBvcHRpb25zOiBhbnkpID0+IHtcbiAgICBjb25zdCB1c2VyID0gcmVxLnVzZXI7XG4gICAgbG9nZ2VyLndhcm4oXG4gICAgICBgUmF0ZSBsaW1pdCBleGNlZWRlZCBmb3IgJHt1c2VyID8gYHVzZXIgJHt1c2VyLmlkfSAoJHt1c2VyLnJvbGV9KWAgOiBgSVAgJHtyZXEuaXB9YH1gLFxuICAgICk7XG4gICAgcmVzLnN0YXR1cyhvcHRpb25zLnN0YXR1c0NvZGUpLmpzb24oe1xuICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgbWVzc2FnZTogJ1RvbyBtYW55IHJlcXVlc3RzLCBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicsXG4gICAgICByZXRyeUFmdGVyOiBNYXRoLmNlaWwob3B0aW9ucy53aW5kb3dNcyAvIDEwMDApLFxuICAgIH0pO1xuICB9LFxuICBzdGFuZGFyZEhlYWRlcnM6IHRydWUsXG4gIGxlZ2FjeUhlYWRlcnM6IGZhbHNlLFxufSk7XG4iXSwidmVyc2lvbiI6M30=