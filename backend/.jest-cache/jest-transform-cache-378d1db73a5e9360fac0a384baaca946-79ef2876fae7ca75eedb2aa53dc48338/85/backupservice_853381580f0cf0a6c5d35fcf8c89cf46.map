{"file":"C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\backup.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\Alejandro\\AIGestion\\backend\\src\\services\\backup.service.ts"],"sourcesContent":["import crypto from 'crypto';\nimport fs, { promises as fsPromises } from 'fs';\nimport { inject, injectable } from 'inversify';\nimport path from 'path';\n\nimport { logger } from '../utils/logger';\nimport { GoogleDriveService } from './google/google-drive.service';\nconst mime = require('mime-types');\n\n@injectable()\nexport class BackupService {\n  constructor(@inject(GoogleDriveService) private googleDriveService: GoogleDriveService) {}\n\n  /**\n   * Main backup function\n   * @param sourceDir Absolute path to local directory\n   * @param rootTargetFolder Name of the root folder in Drive (e.g. \"Backups\")\n   */\n  async backupDirectory(sourceDir: string, rootTargetFolder = 'AIGestion_Backups') {\n    logger.info(`Starting backup of ${sourceDir} to Drive folder: ${rootTargetFolder}`);\n\n    if (!fs.existsSync(sourceDir)) {\n      throw new Error(`Source directory not found: ${sourceDir}`);\n    }\n\n    try {\n      // Ensure root backup folder exists\n      const rootId = await this.googleDriveService.ensureFolder(rootTargetFolder);\n\n      // Start recursive sync\n      await this.syncMetadata(sourceDir, rootId);\n\n      logger.info('Backup completed successfully');\n    } catch (error) {\n      logger.error('Backup failed:', error);\n      throw error;\n    }\n  }\n\n  private async syncMetadata(localPath: string, parentDriveId: string) {\n    const stats = fs.statSync(localPath);\n\n    if (stats.isDirectory()) {\n      const entries = fs.readdirSync(localPath);\n      for (const entry of entries) {\n        const entryPath = path.join(localPath, entry);\n        // Ignore node_modules, .git, etc\n        if (\n          entry === 'node_modules' ||\n          entry === '.git' ||\n          entry === '.DS_Store' ||\n          entry === 'dist'\n        ) {\n          continue;\n        }\n\n        try {\n          const entryStats = fs.statSync(entryPath);\n          if (entryStats.isDirectory()) {\n            // Ensure subdir exists in Drive\n            const folderId = await this.googleDriveService.ensureFolder(entry, parentDriveId);\n            // Recurse\n            await this.syncMetadata(entryPath, folderId);\n          } else {\n            // It's a file, sync it\n            await this.syncFile(entryPath, entry, parentDriveId);\n          }\n        } catch (err) {\n          logger.warn(`Skipping entry ${entryPath} due to error:`, err);\n        }\n      }\n    }\n  }\n\n  private async syncFile(filePath: string, fileName: string, parentId: string) {\n    try {\n      const hash = await this.calculateHash(filePath);\n      const remoteHash = await this.googleDriveService.getFileHash(fileName, parentId);\n\n      if (hash === remoteHash) {\n        logger.debug(`Skipping ${fileName} (unchanged)`);\n        return;\n      }\n\n      logger.info(`Syncing ${fileName}...`);\n      const mimeType = mime.lookup(filePath) || 'application/octet-stream';\n      await this.googleDriveService.uploadFile(filePath, fileName, parentId, mimeType, hash);\n    } catch (err) {\n      logger.error(`Failed to sync file ${fileName}:`, err);\n    }\n  }\n\n  private calculateHash(filePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const hash = crypto.createHash('sha256');\n      const input = fs.createReadStream(filePath);\n\n      input.on('error', reject);\n      input.on('data', chunk => hash.update(chunk));\n      input.on('close', () => resolve(hash.digest('hex')));\n    });\n  }\n\n  /**\n   * Restore a backup from Drive to local file system\n   * @param targetDir Local directory to restore to\n   * @param rootSourceFolder Name of the root folder in Drive\n   */\n  async restoreDirectory(targetDir: string, rootSourceFolder = 'AIGestion_Backups') {\n    logger.info(`Starting restore from ${rootSourceFolder} to ${targetDir}`);\n\n    if (!fs.existsSync(targetDir)) {\n      await fsPromises.mkdir(targetDir, { recursive: true });\n    }\n\n    try {\n      // Find root backup folder\n      const rootId = await this.googleDriveService.findFolder(rootSourceFolder, 'root');\n      if (!rootId) {\n        throw new Error(`Remote backup folder not found: ${rootSourceFolder}`);\n      }\n\n      await this.downloadMetadata(targetDir, rootId);\n      logger.info('Restore completed successfully');\n    } catch (error) {\n      logger.error('Restore failed:', error);\n      throw error;\n    }\n  }\n\n  private async downloadMetadata(localPath: string, driveFolderId: string) {\n    const contents = await this.googleDriveService.listFolderContents(driveFolderId);\n\n    for (const item of contents) {\n      const localItemPath = path.join(localPath, item.name);\n\n      if (item.mimeType === 'application/vnd.google-apps.folder') {\n        // It's a folder\n        if (!fs.existsSync(localItemPath)) {\n          await fsPromises.mkdir(localItemPath, { recursive: true });\n        }\n        await this.downloadMetadata(localItemPath, item.id);\n      } else {\n        // It's a file\n        await this.restoreFile(localItemPath, item.id, item.localHash);\n      }\n    }\n  }\n\n  private async restoreFile(filePath: string, fileId: string, remoteHash?: string) {\n    try {\n      // Check if local file exists and matches hash\n      if (fs.existsSync(filePath) && remoteHash) {\n        const localHash = await this.calculateHash(filePath);\n        if (localHash === remoteHash) {\n          logger.debug(`Skipping ${filePath} (matching hash)`);\n          return;\n        }\n      }\n\n      logger.info(`Downloading to ${filePath}...`);\n      await this.googleDriveService.downloadFile(fileId, filePath);\n    } catch (err) {\n      logger.error(`Failed to restore file ${filePath}:`, err);\n    }\n  }\n}\n"],"version":3}