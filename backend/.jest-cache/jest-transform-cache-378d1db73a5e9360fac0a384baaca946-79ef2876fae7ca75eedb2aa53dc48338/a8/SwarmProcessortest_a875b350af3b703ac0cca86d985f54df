8e1bf11e2a42b7d4f5549c89fa6f06fb
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Mock logger
jest.mock('../../utils/logger', () => ({
    logger: {
        info: jest.fn(),
        error: jest.fn(),
        warn: jest.fn(),
    },
}));
// Mock secrets utility
jest.mock('../../utils/secrets', () => ({
    deriveMissionKey: jest.fn().mockResolvedValue(Buffer.from('mock-key')),
}));
// Mock container
jest.mock('../../config/inversify.config', () => ({
    container: {
        get: jest.fn(),
    },
}));
require("reflect-metadata");
const SwarmProcessor_1 = require("../../infrastructure/jobs/SwarmProcessor");
const inversify_config_1 = require("../../config/inversify.config");
const types_1 = require("../../types");
const Mission_1 = require("../../models/Mission");
const mockAIService = {
    generateContent: jest.fn(),
};
const mockMissionRepo = {
    update: jest.fn(),
};
const mockSocketService = {
    emitMissionUpdate: jest.fn(),
};
const mockNotificationService = {
    createNotification: jest.fn(),
};
const mockVaultService = {
    encrypt: jest.fn().mockResolvedValue({ iv: 'iv', ciphertext: 'cipher', tag: 'tag' }),
};
const mockSwarmClient = {
    post: jest.fn(),
};
const mockKGService = {
    indexMissionFindings: jest.fn(),
};
describe('SwarmProcessor', () => {
    let mockJob;
    beforeEach(() => {
        jest.clearAllMocks();
        mockJob = {
            id: 'job-123',
            data: {
                objective: 'Test Mission',
                userId: 'user-1',
                missionId: 'mission-1',
                context: {},
            },
        };
        inversify_config_1.container.get.mockImplementation(type => {
            if (type === types_1.TYPES.AIService)
                return mockAIService;
            if (type === types_1.TYPES.MissionRepository)
                return mockMissionRepo;
            if (type === types_1.TYPES.SocketService)
                return mockSocketService;
            if (type === types_1.TYPES.NotificationService)
                return mockNotificationService;
            return {};
        });
    });
    it('should execute mission lifecycle successfully', async () => {
        // Setup mocks
        mockAIService.generateContent
            .mockResolvedValueOnce('Step 1: Plan') // Planning phase
            .mockResolvedValueOnce('Mission Success Report'); // Final report phase
        // Execute
        await SwarmProcessor_1.SwarmProcessor.process(mockJob);
        // Verify Planning Phase
        expect(mockMissionRepo.update).toHaveBeenCalledWith('mission-1', {
            status: Mission_1.MissionStatus.PLANNING,
        });
        expect(mockSocketService.emitMissionUpdate).toHaveBeenCalledWith('mission-1', {
            status: Mission_1.MissionStatus.PLANNING,
        });
        // Verify AI Planning
        expect(mockAIService.generateContent).toHaveBeenNthCalledWith(1, expect.stringContaining('Develop a concise step-by-step strategy'), 'user-1');
        // Verify Executing Phase
        expect(mockMissionRepo.update).toHaveBeenCalledWith('mission-1', {
            plan: 'Step 1: Plan',
            status: Mission_1.MissionStatus.EXECUTING,
        });
        // Verify Final Reporting
        expect(mockAIService.generateContent).toHaveBeenNthCalledWith(2, expect.stringContaining('Generate a final summary'), 'user-1');
        // Verify Completion
        expect(mockMissionRepo.update).toHaveBeenCalledWith('mission-1', expect.objectContaining({
            result: 'Mission Success Report',
            status: Mission_1.MissionStatus.COMPLETED,
            completedAt: expect.any(Date),
        }));
        // Verify Notification — uses positional args:
        // createNotification(userId, type, title, message, metadata)
        expect(mockNotificationService.createNotification).toHaveBeenCalledWith('user-1', expect.anything(), // NotificationType.MISSION_COMPLETED enum value
        expect.any(String), // title
        expect.stringContaining('Test Mission'), // message
        expect.objectContaining({ missionId: 'mission-1' }));
    });
    it('should handle failures and update status to FAILED', async () => {
        const error = new Error('AI Service Down');
        mockAIService.generateContent.mockRejectedValue(error);
        await expect(SwarmProcessor_1.SwarmProcessor.process(mockJob)).rejects.toThrow('AI Service Down');
        // Verify Failure Update
        expect(mockMissionRepo.update).toHaveBeenCalledWith('mission-1', expect.objectContaining({
            status: Mission_1.MissionStatus.FAILED,
            error: 'AI Service Down',
            completedAt: expect.any(Date),
        }));
        // Verify Socket Error Emit
        expect(mockSocketService.emitMissionUpdate).toHaveBeenCalledWith('mission-1', expect.objectContaining({
            status: Mission_1.MissionStatus.FAILED,
            error: 'AI Service Down',
        }));
        // Verify Failure Notification — uses positional args:
        // createNotification(userId, type, title, message, metadata)
        expect(mockNotificationService.createNotification).toHaveBeenCalledWith('user-1', expect.anything(), // NotificationType.MISSION_FAILED enum value
        expect.any(String), // title
        expect.stringContaining('AI Service Down'), // message
        expect.objectContaining({ missionId: 'mission-1' }));
    });
    it('should log error when updating failure status fails', async () => {
        const primaryError = new Error('AI Service Down');
        const secondaryError = new Error('DB Update Failed');
        mockAIService.generateContent.mockRejectedValue(primaryError);
        // First update (planning) succeeds (or we can make AI fail immediately so 1st update is skipped?)
        // The code does:
        // 1. MissionRepo.update(PLANNING)
        // 2. AI Service...
        // If AI Service fails, it goes to catch block.
        // inside catch: MissionRepo.update(FAILED)
        // So we want MissionRepo.update to fail ONLY when called with FAILED status, or just generally fail to simulate the catch-catch block.
        // It's easier if we make it fail on the second call?
        // Actually, let's just make it throw when called with user-1 or something?
        // Or using mockImplementation to throw if status is FAILED.
        mockMissionRepo.update.mockImplementation((id, data) => {
            if (data.status === Mission_1.MissionStatus.FAILED) {
                return Promise.reject(secondaryError);
            }
            return Promise.resolve();
        });
        // We expect the PRIMARY error to be thrown, not the secondary one.
        await expect(SwarmProcessor_1.SwarmProcessor.process(mockJob)).rejects.toThrow('AI Service Down');
        // And we expect the secondary error to be logged
        // We need to import logger to verify this?
        // Or we can rely on console?
        // We mocked logger, let's verify it.
        // We need access to the mocked logger instance.
        // Since we didn't save the mocked logger instance in a variable outside, we can import it.
        const { logger } = require('../../utils/logger');
        expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Failed to update mission failure status'), secondaryError);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxfX3Rlc3RzX19cXHNlcnZpY2VzXFxTd2FybVByb2Nlc3Nvci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBT0EsY0FBYztBQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNyQyxNQUFNLEVBQUU7UUFDTixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2hCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ2hCO0NBQ0YsQ0FBQyxDQUFDLENBQUM7QUFFSix1QkFBdUI7QUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3RDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0NBQ3ZFLENBQUMsQ0FBQyxDQUFDO0FBd0JKLGlCQUFpQjtBQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLCtCQUErQixFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDaEQsU0FBUyxFQUFFO1FBQ1QsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7S0FDZjtDQUNGLENBQUMsQ0FBQyxDQUFDO0FBaERKLDRCQUEwQjtBQUMxQiw2RUFBMEU7QUFFMUUsb0VBQTBEO0FBQzFELHVDQUFvQztBQUNwQyxrREFBcUQ7QUFnQnJELE1BQU0sYUFBYSxHQUFHO0lBQ3BCLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0NBQzNCLENBQUM7QUFDRixNQUFNLGVBQWUsR0FBRztJQUN0QixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUNsQixDQUFDO0FBQ0YsTUFBTSxpQkFBaUIsR0FBRztJQUN4QixpQkFBaUIsRUFBRSxJ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bEMsbUJBQW1CO1FBRW5CLCtDQUErQztRQUMvQywyQ0FBMkM7UUFFM0MsdUlBQXVJO1FBQ3ZJLHFEQUFxRDtRQUNyRCwyRUFBMkU7UUFDM0UsNERBQTREO1FBRTVELGVBQWUsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDckQsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLHVCQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3pDLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUN4QyxDQUFDO1lBQ0QsT0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQUM7UUFFSCxtRUFBbUU7UUFDbkUsTUFBTSxNQUFNLENBQUMsK0JBQWMsQ0FBQyxPQUFPLENBQUMsT0FBYyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFFeEYsaURBQWlEO1FBQ2pELDJDQUEyQztRQUMzQyw2QkFBNkI7UUFDN0IscUNBQXFDO1FBQ3JDLGdEQUFnRDtRQUNoRCwyRkFBMkY7UUFDM0YsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ2pELE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsb0JBQW9CLENBQ3ZDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyx5Q0FBeUMsQ0FBQyxFQUNsRSxjQUFjLENBQ2YsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxfX3Rlc3RzX19cXHNlcnZpY2VzXFxTd2FybVByb2Nlc3Nvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAncmVmbGVjdC1tZXRhZGF0YSc7XG5pbXBvcnQgeyBTd2FybVByb2Nlc3NvciB9IGZyb20gJy4uLy4uL2luZnJhc3RydWN0dXJlL2pvYnMvU3dhcm1Qcm9jZXNzb3InO1xuaW1wb3J0IHsgSm9iIH0gZnJvbSAnYnVsbG1xJztcbmltcG9ydCB7IGNvbnRhaW5lciB9IGZyb20gJy4uLy4uL2NvbmZpZy9pbnZlcnNpZnkuY29uZmlnJztcbmltcG9ydCB7IFRZUEVTIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgTWlzc2lvblN0YXR1cyB9IGZyb20gJy4uLy4uL21vZGVscy9NaXNzaW9uJztcblxuLy8gTW9jayBsb2dnZXJcbmplc3QubW9jaygnLi4vLi4vdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgbG9nZ2VyOiB7XG4gICAgaW5mbzogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICB9LFxufSkpO1xuXG4vLyBNb2NrIHNlY3JldHMgdXRpbGl0eVxuamVzdC5tb2NrKCcuLi8uLi91dGlscy9zZWNyZXRzJywgKCkgPT4gKHtcbiAgZGVyaXZlTWlzc2lvbktleTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKEJ1ZmZlci5mcm9tKCdtb2NrLWtleScpKSxcbn0pKTtcblxuY29uc3QgbW9ja0FJU2VydmljZSA9IHtcbiAgZ2VuZXJhdGVDb250ZW50OiBqZXN0LmZuKCksXG59O1xuY29uc3QgbW9ja01pc3Npb25SZXBvID0ge1xuICB1cGRhdGU6IGplc3QuZm4oKSxcbn07XG5jb25zdCBtb2NrU29ja2V0U2VydmljZSA9IHtcbiAgZW1pdE1pc3Npb25VcGRhdGU6IGplc3QuZm4oKSxcbn07XG5jb25zdCBtb2NrTm90aWZpY2F0aW9uU2VydmljZSA9IHtcbiAgY3JlYXRlTm90aWZpY2F0aW9uOiBqZXN0LmZuKCksXG59O1xuY29uc3QgbW9ja1ZhdWx0U2VydmljZSA9IHtcbiAgZW5jcnlwdDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaXY6ICdpdicsIGNpcGhlcnRleHQ6ICdjaXBoZXInLCB0YWc6ICd0YWcnIH0pLFxufTtcbmNvbnN0IG1vY2tTd2FybUNsaWVudCA9IHtcbiAgcG9zdDogamVzdC5mbigpLFxufTtcbmNvbnN0IG1vY2tLR1NlcnZpY2UgPSB7XG4gIGluZGV4TWlzc2lvbkZpbmRpbmdzOiBqZXN0LmZuKCksXG59O1xuXG4vLyBNb2NrIGNvbnRhaW5lclxuamVzdC5tb2NrKCcuLi8uLi9jb25maWcvaW52ZXJzaWZ5LmNvbmZpZycsICgpID0+ICh7XG4gIGNvbnRhaW5lcjoge1xuICAgIGdldDogamVzdC5mbigpLFxuICB9LFxufSkpO1xuXG5kZXNjcmliZSgnU3dhcm1Qcm9jZXNzb3InLCAoKSA9PiB7XG4gIGxldCBtb2NrSm9iOiBQYXJ0aWFsPEpvYj47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG5cbiAgICBtb2NrSm9iID0ge1xuICAgICAgaWQ6ICdqb2ItMTIzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb2JqZWN0aXZlOiAnVGVzdCBNaXNzaW9uJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgbWlzc2lvbklkOiAnbWlzc2lvbi0xJyxcbiAgICAgICAgY29udGV4dDoge30sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICAoY29udGFpbmVyLmdldCBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbih0eXBlID0+IHtcbiAgICAgIGlmICh0eXBlID09PSBUWVBFUy5BSVNlcnZpY2UpIHJldHVybiBtb2NrQUlTZXJ2aWNlO1xuICAgICAgaWYgKHR5cGUgPT09IFRZUEVTLk1pc3Npb25SZXBvc2l0b3J5KSByZXR1cm4gbW9ja01pc3Npb25SZXBvO1xuICAgICAgaWYgKHR5cGUgPT09IFRZUEVTLlNvY2tldFNlcnZpY2UpIHJldHVybiBtb2NrU29ja2V0U2VydmljZTtcbiAgICAgIGlmICh0eXBlID09PSBUWVBFUy5Ob3RpZmljYXRpb25TZXJ2aWNlKSByZXR1cm4gbW9ja05vdGlmaWNhdGlvblNlcnZpY2U7XG4gICAgICByZXR1cm4ge307XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgZXhlY3V0ZSBtaXNzaW9uIGxpZmVjeWNsZSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gU2V0dXAgbW9ja3NcbiAgICBtb2NrQUlTZXJ2aWNlLmdlbmVyYXRlQ29udGVudFxuICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSgnU3RlcCAxOiBQbGFuJykgLy8gUGxhbm5pbmcgcGhhc2VcbiAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoJ01pc3Npb24gU3VjY2VzcyBSZXBvcnQnKTsgLy8gRmluYWwgcmVwb3J0IHBoYXNlXG5cbiAgICAvLyBFeGVjdXRlXG4gICAgYXdhaXQgU3dhcm1Qcm9jZXNzb3IucHJvY2Vzcyhtb2NrSm9iIGFzIEpvYik7XG5cbiAgICAvLyBWZXJpZnkgUGxhbm5pbmcgUGhhc2VcbiAgICBleHBlY3QobW9ja01pc3Npb25SZXBvLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ21pc3Npb24tMScsIHtcbiAgICAgIHN0YXR1czogTWlzc2lvblN0YXR1cy5QTEFOTklORyxcbiAgICB9KTtcbiAgICBleHBlY3QobW9ja1NvY2tldFNlcnZpY2UuZW1pdE1pc3Npb25VcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdtaXNzaW9uLTEnLCB7XG4gICAgICBzdGF0dXM6IE1pc3Npb25TdGF0dXMuUExBTk5JTkcsXG4gICAgfSk7XG5cbiAgICAvLyBWZXJpZnkgQUkgUGxhbm5pbmdcbiAgICBleHBlY3QobW9ja0FJU2VydmljZS5nZW5lcmF0ZUNvbnRlbnQpLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKFxuICAgICAgMSxcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdEZXZlbG9wIGEgY29uY2lzZSBzdGVwLWJ5LXN0ZXAgc3RyYXRlZ3knKSxcbiAgICAgICd1c2VyLTEnLFxuICAgICk7XG5cbiAgICAvLyBWZXJpZnkgRXhlY3V0aW5nIFBoYXNlXG4gICAgZXhwZWN0KG1vY2tNaXNzaW9uUmVwby51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdtaXNzaW9uLTEnLCB7XG4gICAgICBwbGFuOiAnU3RlcCAxOiBQbGFuJyxcbiAgICAgIHN0YXR1czogTWlzc2lvblN0YXR1cy5FWEVDVVRJTkcsXG4gICAgfSk7XG5cbiAgICAvLyBWZXJpZnkgRmluYWwgUmVwb3J0aW5nXG4gICAgZXhwZWN0KG1vY2tBSVNlcnZpY2UuZ2VuZXJhdGVDb250ZW50KS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aChcbiAgICAgIDIsXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnR2VuZXJhdGUgYSBmaW5hbCBzdW1tYXJ5JyksXG4gICAgICAndXNlci0xJyxcbiAgICApO1xuXG4gICAgLy8gVmVyaWZ5IENvbXBsZXRpb25cbiAgICBleHBlY3QobW9ja01pc3Npb25SZXBvLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAnbWlzc2lvbi0xJyxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgcmVzdWx0OiAnTWlzc2lvbiBTdWNjZXNzIFJlcG9ydCcsXG4gICAgICAgIHN0YXR1czogTWlzc2lvblN0YXR1cy5DT01QTEVURUQsXG4gICAgICAgIGNvbXBsZXRlZEF0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgfSksXG4gICAgKTtcblxuICAgIC8vIFZlcmlmeSBOb3RpZmljYXRpb24g4oCUIHVzZXMgcG9zaXRpb25hbCBhcmdzOlxuICAgIC8vIGNyZWF0ZU5vdGlmaWNhdGlvbih1c2VySWQsIHR5cGUsIHRpdGxlLCBtZXNzYWdlLCBtZXRhZGF0YSlcbiAgICBleHBlY3QobW9ja05vdGlmaWNhdGlvblNlcnZpY2UuY3JlYXRlTm90aWZpY2F0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICd1c2VyLTEnLFxuICAgICAgZXhwZWN0LmFueXRoaW5nKCksIC8vIE5vdGlmaWNhdGlvblR5cGUuTUlTU0lPTl9DT01QTEVURUQgZW51bSB2YWx1ZVxuICAgICAgZXhwZWN0LmFueShTdHJpbmcpLCAvLyB0aXRsZVxuICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1Rlc3QgTWlzc2lvbicpLCAvLyBtZXNzYWdlXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IG1pc3Npb25JZDogJ21pc3Npb24tMScgfSksIC8vIG1ldGFkYXRhXG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZmFpbHVyZXMgYW5kIHVwZGF0ZSBzdGF0dXMgdG8gRkFJTEVEJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdBSSBTZXJ2aWNlIERvd24nKTtcbiAgICBtb2NrQUlTZXJ2aWNlLmdlbmVyYXRlQ29udGVudC5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG5cbiAgICBhd2FpdCBleHBlY3QoU3dhcm1Qcm9jZXNzb3IucHJvY2Vzcyhtb2NrSm9iIGFzIEpvYikpLnJlamVjdHMudG9UaHJvdygnQUkgU2VydmljZSBEb3duJyk7XG5cbiAgICAvLyBWZXJpZnkgRmFpbHVyZSBVcGRhdGVcbiAgICBleHBlY3QobW9ja01pc3Npb25SZXBvLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAnbWlzc2lvbi0xJyxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgc3RhdHVzOiBNaXNzaW9uU3RhdHVzLkZBSUxFRCxcbiAgICAgICAgZXJyb3I6ICdBSSBTZXJ2aWNlIERvd24nLFxuICAgICAgICBjb21wbGV0ZWRBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICAvLyBWZXJpZnkgU29ja2V0IEVycm9yIEVtaXRcbiAgICBleHBlY3QobW9ja1NvY2tldFNlcnZpY2UuZW1pdE1pc3Npb25VcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgJ21pc3Npb24tMScsXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIHN0YXR1czogTWlzc2lvblN0YXR1cy5GQUlMRUQsXG4gICAgICAgIGVycm9yOiAnQUkgU2VydmljZSBEb3duJyxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICAvLyBWZXJpZnkgRmFpbHVyZSBOb3RpZmljYXRpb24g4oCUIHVzZXMgcG9zaXRpb25hbCBhcmdzOlxuICAgIC8vIGNyZWF0ZU5vdGlmaWNhdGlvbih1c2VySWQsIHR5cGUsIHRpdGxlLCBtZXNzYWdlLCBtZXRhZGF0YSlcbiAgICBleHBlY3QobW9ja05vdGlmaWNhdGlvblNlcnZpY2UuY3JlYXRlTm90aWZpY2F0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICd1c2VyLTEnLFxuICAgICAgZXhwZWN0LmFueXRoaW5nKCksIC8vIE5vdGlmaWNhdGlvblR5cGUuTUlTU0lPTl9GQUlMRUQgZW51bSB2YWx1ZVxuICAgICAgZXhwZWN0LmFueShTdHJpbmcpLCAvLyB0aXRsZVxuICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0FJIFNlcnZpY2UgRG93bicpLCAvLyBtZXNzYWdlXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IG1pc3Npb25JZDogJ21pc3Npb24tMScgfSksIC8vIG1ldGFkYXRhXG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBsb2cgZXJyb3Igd2hlbiB1cGRhdGluZyBmYWlsdXJlIHN0YXR1cyBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBwcmltYXJ5RXJyb3IgPSBuZXcgRXJyb3IoJ0FJIFNlcnZpY2UgRG93bicpO1xuICAgIGNvbnN0IHNlY29uZGFyeUVycm9yID0gbmV3IEVycm9yKCdEQiBVcGRhdGUgRmFpbGVkJyk7XG5cbiAgICBtb2NrQUlTZXJ2aWNlLmdlbmVyYXRlQ29udGVudC5tb2NrUmVqZWN0ZWRWYWx1ZShwcmltYXJ5RXJyb3IpO1xuICAgIC8vIEZpcnN0IHVwZGF0ZSAocGxhbm5pbmcpIHN1Y2NlZWRzIChvciB3ZSBjYW4gbWFrZSBBSSBmYWlsIGltbWVkaWF0ZWx5IHNvIDFzdCB1cGRhdGUgaXMgc2tpcHBlZD8pXG4gICAgLy8gVGhlIGNvZGUgZG9lczpcbiAgICAvLyAxLiBNaXNzaW9uUmVwby51cGRhdGUoUExBTk5JTkcpXG4gICAgLy8gMi4gQUkgU2VydmljZS4uLlxuXG4gICAgLy8gSWYgQUkgU2VydmljZSBmYWlscywgaXQgZ29lcyB0byBjYXRjaCBibG9jay5cbiAgICAvLyBpbnNpZGUgY2F0Y2g6IE1pc3Npb25SZXBvLnVwZGF0ZShGQUlMRUQpXG5cbiAgICAvLyBTbyB3ZSB3YW50IE1pc3Npb25SZXBvLnVwZGF0ZSB0byBmYWlsIE9OTFkgd2hlbiBjYWxsZWQgd2l0aCBGQUlMRUQgc3RhdHVzLCBvciBqdXN0IGdlbmVyYWxseSBmYWlsIHRvIHNpbXVsYXRlIHRoZSBjYXRjaC1jYXRjaCBibG9jay5cbiAgICAvLyBJdCdzIGVhc2llciBpZiB3ZSBtYWtlIGl0IGZhaWwgb24gdGhlIHNlY29uZCBjYWxsP1xuICAgIC8vIEFjdHVhbGx5LCBsZXQncyBqdXN0IG1ha2UgaXQgdGhyb3cgd2hlbiBjYWxsZWQgd2l0aCB1c2VyLTEgb3Igc29tZXRoaW5nP1xuICAgIC8vIE9yIHVzaW5nIG1vY2tJbXBsZW1lbnRhdGlvbiB0byB0aHJvdyBpZiBzdGF0dXMgaXMgRkFJTEVELlxuXG4gICAgbW9ja01pc3Npb25SZXBvLnVwZGF0ZS5tb2NrSW1wbGVtZW50YXRpb24oKGlkLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZGF0YS5zdGF0dXMgPT09IE1pc3Npb25TdGF0dXMuRkFJTEVEKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChzZWNvbmRhcnlFcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBXZSBleHBlY3QgdGhlIFBSSU1BUlkgZXJyb3IgdG8gYmUgdGhyb3duLCBub3QgdGhlIHNlY29uZGFyeSBvbmUuXG4gICAgYXdhaXQgZXhwZWN0KFN3YXJtUHJvY2Vzc29yLnByb2Nlc3MobW9ja0pvYiBhcyBKb2IpKS5yZWplY3RzLnRvVGhyb3coJ0FJIFNlcnZpY2UgRG93bicpO1xuXG4gICAgLy8gQW5kIHdlIGV4cGVjdCB0aGUgc2Vjb25kYXJ5IGVycm9yIHRvIGJlIGxvZ2dlZFxuICAgIC8vIFdlIG5lZWQgdG8gaW1wb3J0IGxvZ2dlciB0byB2ZXJpZnkgdGhpcz9cbiAgICAvLyBPciB3ZSBjYW4gcmVseSBvbiBjb25zb2xlP1xuICAgIC8vIFdlIG1vY2tlZCBsb2dnZXIsIGxldCdzIHZlcmlmeSBpdC5cbiAgICAvLyBXZSBuZWVkIGFjY2VzcyB0byB0aGUgbW9ja2VkIGxvZ2dlciBpbnN0YW5jZS5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3Qgc2F2ZSB0aGUgbW9ja2VkIGxvZ2dlciBpbnN0YW5jZSBpbiBhIHZhcmlhYmxlIG91dHNpZGUsIHdlIGNhbiBpbXBvcnQgaXQuXG4gICAgY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuICAgIGV4cGVjdChsb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0ZhaWxlZCB0byB1cGRhdGUgbWlzc2lvbiBmYWlsdXJlIHN0YXR1cycpLFxuICAgICAgc2Vjb25kYXJ5RXJyb3IsXG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==