{"file":"C:\\Users\\Alejandro\\AIGestion\\backend\\src\\controllers\\SovereignHandshakeController.ts","mappings":"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","names":[],"sources":["C:\\Users\\Alejandro\\AIGestion\\backend\\src\\controllers\\SovereignHandshakeController.ts"],"sourcesContent":["import { Request, Response } from 'express';\r\nimport { inject } from 'inversify';\r\nimport { controller, httpGet, httpPost, request, response } from 'inversify-express-utils';\r\nimport { TYPES } from '../types';\r\nimport { PQCCommService } from '../services/pqc-comm.service';\r\nimport { logger } from '../utils/logger';\r\nimport { setCache, getCache } from '../cache/redis';\r\nimport crypto from 'node:crypto';\r\n\r\n@controller('/auth/sovereign')\r\nexport class SovereignHandshakeController {\r\n  constructor(@inject(TYPES.PQCCommService) private pqcService: PQCCommService) {}\r\n\r\n  /**\r\n   * ðŸŒŒ Step 1: Initiate Handshake\r\n   * Server provides its public hybrid keys.\r\n   */\r\n  @httpGet('/handshake/init')\r\n  public async initHandshake(@request() req: Request, @response() res: Response) {\r\n    try {\r\n      const handshakeId = crypto.randomUUID();\r\n      const keys = await this.pqcService.generateHandshakeKeys();\r\n\r\n      // Store private keys in Redis (transient) for the session\r\n      await setCache(`pqc:handshake:${handshakeId}`, JSON.stringify(keys), 300); // 5 min TTL\r\n\r\n      return res.json({\r\n        success: true,\r\n        handshakeId,\r\n        publicKey: {\r\n          classic: keys.classic.public,\r\n          pqc: keys.pqc.public,\r\n        },\r\n      });\r\n    } catch (error: any) {\r\n      logger.error('[SovereignHandshake] Init failed:', error);\r\n      return res.status(500).json({ error: 'Handshake initialization failed' });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ðŸŒŒ Step 2: Finalize Handshake\r\n   * Receive client keys, derive symmetric secret.\r\n   */\r\n  @httpPost('/handshake/finalize')\r\n  public async finalizeHandshake(@request() req: Request, @response() res: Response) {\r\n    try {\r\n      const { handshakeId, clientPublicKey, clientCiphertext } = req.body;\r\n\r\n      const cachedKeysStr = await getCache(`pqc:handshake:${handshakeId}`);\r\n      if (!cachedKeysStr) {\r\n        return res.status(400).json({ error: 'Handshake session expired or invalid' });\r\n      }\r\n\r\n      const myKeys = JSON.parse(cachedKeysStr);\r\n\r\n      // Derive Symmetric Key\r\n      const symmetricKey = await this.pqcService.deriveSymmetricKey(\r\n        myKeys.classic.private,\r\n        clientPublicKey.classic,\r\n        myKeys.pqc.private,\r\n        clientCiphertext, // Client should have encapsulated for us\r\n      );\r\n\r\n      // Store the final session secret for this Sovereign Session\r\n      const sessionToken = crypto.randomUUID();\r\n      await setCache(`sovereign:session:${sessionToken}`, symmetricKey, 3600); // 1 hour TTL\r\n\r\n      return res.json({\r\n        success: true,\r\n        sessionToken,\r\n        // The client already knows the symmetric key if they encapsulated correctly\r\n        message: 'Sovereign channel established.',\r\n      });\r\n    } catch (error: any) {\r\n      logger.error('[SovereignHandshake] Finalization failed:', error);\r\n      return res.status(500).json({ error: 'Handshake finalization failed' });\r\n    }\r\n  }\r\n}\r\n"],"version":3}