99469110940739b90b87407b775129fd
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RagService = void 0;
const axios_1 = __importDefault(require("axios"));
const child_process_1 = require("child_process");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const inversify_1 = require("inversify");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
const logger_1 = require("../utils/logger");
const pinecone_service_1 = require("./pinecone.service");
const supabase_service_1 = require("./supabase.service");
const types_1 = require("../types");
const SovereignVaultService_1 = require("./SovereignVaultService");
let RagService = class RagService {
    vault;
    rootDir;
    maxContextSize = 100000; // ~25k tokens (safe limit)
    cacheTTL = 5 * 60 * 1000; // 5 minutes
    cache = null;
    fileCache = null;
    ignoredDirs = new Set([
        'node_modules',
        'dist',
        'build',
        '.git',
        '.turbo',
        'coverage',
        'logs',
        '.trunk',
        '.vscode',
        '.idea',
    ]);
    ignoredExtensions = new Set([
        '.lock',
        '.png',
        '.jpg',
        '.jpeg',
        '.gif',
        '.svg',
        '.ico',
        '.pdf',
        '.zip',
        '.map',
        '.mp4',
        '.mp3',
    ]);
    constructor(vault) {
        this.vault = vault;
        this.rootDir = path_1.default.resolve(__dirname, '../../../');
    }
    /**
     * Scans the codebase and returns a formatted string of the context.
     * Uses in-memory caching and prepends an ASCII tree of the project structure.
     * If query is provided, performs a Hybrid Search simulation to prioritize relevant files.
     * ALSO queries the Sovereign Vault service for documentation context.
     */
    async getProjectContext(query) {
        try {
            logger_1.logger.info(`[RagService] Getting context${query ? ` for query: "${query}"` : ' (full)'}...`);
            let context = '';
            // 1. Run File Scan and Database Query in parallel
            const [files, vaultResults] = await Promise.all([
                this.getAllFiles(),
                query && query.trim().length > 0 ? this.vault.query(query) : Promise.resolve(null),
            ]);
            // 2. Generate ASCII Tree (always useful for structure)
            const filePaths = files.map(f => f.path);
            const asciiTree = this.generateAsciiTree(filePaths);
            context += `Project Structure:\n${asciiTree}\n\n`;
            let sortedFiles = files;
            // [GOD MODE] Use Rust-powered rag-core if query is provided
            if (query && query.trim().length > 0) {
                context += `[Code Context optimized for query: "${query}"]\n\n`;
                try {
                    const rustResults = await this.queryRustCore(query);
                    if (rustResults && rustResults.length > 0) {
                        logger_1.logger.info(`[RagService] Rust RagCore provided ${rustResults.length} optimized results.`);
                        sortedFiles = rustResults;
                    }
                    else {
                        sortedFiles = this.rankFiles(files, query);
                    }
                }
                catch (err) {
                    logger_1.logger.warn(`[RagService] Rust RagCore failed, falling back to JS ranking: ${err}`);
                    sortedFiles = this.rankFiles(files, query);
                }
                // Append Sovereign Vault Context (Unified Memory)
                if (vaultResults && vaultResults.length > 0) {
                    context += `[Sovereign Vault - Unified Memory Banks]\n`;
                    vaultResults.forEach((res, i) => {
                        context += `--- Memory Item ${i + 1} [Source: ${res.source.toUpperCase()}] ---\n${res.content}\n\n`;
                    });
                }
                const localContext = await this.queryLocalMemory(query);
                if (localContext) {
                    context += `[Local Neural Memory (NeuroCore)]\n${localContext}\n\n`;
                }
            }
            else {
                context += `[Full Context - No Query Provided]\n\n`;
                // Default sort by path if no query to maintain stability
                sortedFiles.sort((a, b) => a.path.localeCompare(b.path));
            }
            context += `Here is the codebase context:\n\n`;
            let currentSize = context.length;
            // 4. Context Stuffing with Limit
            let includedCount = 0;
            for (const file of sortedFiles) {
                const fileBlock = `<file path="${file.path}">\n${file.content}\n</file>\n\n`;
                if (currentSize + fileBlock.length > this.maxContextSize) {
                    context += `\n<!-- Context truncated due to size limit (${this.maxContextSize} chars). Included ${includedCount} of ${sortedFiles.length} files. -->`;
                    break;
                }
                context += fileBlock;
                currentSize += fileBlock.length;
                includedCount++;
            }
            return context;
        }
        catch (error) {
            logger_1.logger.error(error, 'Error in RagService:');
            return ''; // Fail gracefully
        }
    }
    /**
     * Public interface to query the knowledge base (Vector DB documentation).
     * Migrated to SovereignVaultService for unified discovery.
     */
    async queryKnowledgeBase(query) {
        const results = await this.vault.query(query);
        if (!results || results.length === 0)
            return null;
        return results
            .map((res, i) => `[Source: ${res.source.toUpperCase()} | Score: ${res.score.toFixed(2)}]\n${res.content}`)
            .join('\n\n');
    }
    /**
     * Ingests a new document into the Sovereign Vault.
     */
    async ingestDocument(filename, content, tags = []) {
        logger_1.logger.info(`[RagService] Forwarding ingestion to SovereignVault: ${filename}`);
        await this.vault.ingest(filename, content, tags);
    }
    /**
     * Specifically archives data to the local NeuroCore ML service.
     */
    async archiveToLocalMemory(content, filename, tags = []) {
        try {
            const mlServiceUrl = process.env.ML_SERVICE_URL || 'http://ml-service:5000';
            await axios_1.default.post(`${mlServiceUrl}/archive`, {
                content,
                source: filename,
                tags,
            });
            logger_1.logger.info(`[RagService] Document archived to local NeuroCore: ${filename}`);
        }
        catch (error) {
            logger_1.logger.warn(`[RagService] Failed to archive to local NeuroCore: ${error.message}`);
        }
    }
    /**
     * Queries the local NeuroCore ML service for neural embeddings search.
     */
    async queryLocalMemory(query) {
        try {
            const mlServiceUrl = process.env.ML_SERVICE_URL || 'http://ml-service:5000';
            const response = await axios_1.default.post(`${mlServiceUrl}/recall`, { query, limit: 3 });
            const results = response.data.results;
            if (results && results.length > 0) {
                return results
                    .map((res, i) => `[Local Match ${i + 1}] Source: ${res.metadata.source}\n${res.content}`)
                    .join('\n\n');
            }
            return null;
        }
        catch (error) {
            logger_1.logger.warn(`[RagService] Failed to query local NeuroCore: ${error.message}`);
            return null;
        }
    }
    /**
     * Queries the direct Pinecone Vector DB for relevant documentation.
     */
    async queryVectorDb(query) {
        try {
            logger_1.logger.info(`[RagService] Querying Pinecone Vector DB for: "${query}"`);
            const results = await pinecone_service_1.pineconeService.search(query, 3);
            if (results && results.length > 0) {
                let docStr = '';
                results.forEach((res, index) => {
                    const filename = res.metadata?.filename || 'unknown';
                    const content = res.metadata?.text || '';
                    docStr += `--- Document ${index + 1} (${filename}) ---\n${content}\n\n`;
                });
                return docStr.trim();
            }
            return null;
        }
        catch (error) {
            // Log but don't crash
            logger_1.logger.warn(`[RagService] Failed to query Pinecone Vector DB: ${error.message}`);
            return `<!-- Failed to retrieve documentation context from Pinecone: ${error.message} -->`;
        }
    }
    async getAllFiles() {
        if (this.fileCache && Date.now() - this.fileCache.timestamp < this.cacheTTL) {
            return this.fileCache.files;
        }
        const files = await this.scanDirectory(this.rootDir);
        this.fileCache = {
            files,
            timestamp: Date.now(),
        };
        return files;
    }
    /**
     * Ranks files using a simulated Hybrid Search (Keyword + Structural).
     * Calculates a simple score based on:
     * 1. Path/Filename match (Structural/Semantic proxy)
     * 2. Content keyword frequency (TF proxy)
     */
    rankFiles(files, query) {
        const terms = query
            .toLowerCase()
            .split(/\s+/)
            .filter(t => t.length > 2);
        if (terms.length === 0)
            return files;
        const results = files.map(file => {
            let keywordScore = 0;
            let semanticScore = 0;
            const matches = [];
            const contentLower = file.content.toLowerCase();
            const pathLower = file.path.toLowerCase();
            terms.forEach(term => {
                // Structural Score: Filename matches are high signal
                if (pathLower.includes(term)) {
                    semanticScore += 10;
                    matches.push(`path:${term}`);
                }
                // Keyword Score: Simple frequency count in content
                const regex = new RegExp(this.escapeRegExp(term), 'g');
                const count = (contentLower.match(regex) || []).length;
                if (count > 0) {
                    keywordScore += count;
                }
            });
            const finalKeywordScore = keywordScore > 0 ? Math.log(1 + keywordScore) : 0;
            const totalScore = semanticScore * 2 + finalKeywordScore;
            return {
                file,
                score: totalScore,
                metadata: { keywordScore: finalKeywordScore, semanticScore, matches },
            };
        });
        const relevantFiles = results
            .filter(r => r.score > 0)
            .sort((a, b) => b.score - a.score)
            .map(r => r.file);
        const otherFiles = files.filter(f => !relevantFiles.includes(f));
        return [...relevantFiles, ...otherFiles];
    }
    escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    async scanDirectory(dir) {
        let results = [];
        try {
            const entries = await promises_1.default.readdir(dir, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path_1.default.join(dir, entry.name);
                const relativePath = path_1.default.relative(this.rootDir, fullPath);
                if (entry.isDirectory()) {
                    if (!this.ignoredDirs.has(entry.name)) {
                        const subResults = await this.scanDirectory(fullPath);
                        results = results.concat(subResults);
                    }
                }
                else if (entry.isFile()) {
                    const ext = path_1.default.extname(entry.name).toLowerCase();
                    if (!this.ignoredExtensions.has(ext)) {
                        try {
                            const content = await promises_1.default.readFile(fullPath, 'utf-8');
                            results.push({
                                path: relativePath,
                                content: content,
                                size: content.length,
                            });
                        }
                        catch (err) {
                            logger_1.logger.warn(`Could not read file ${fullPath}: ${err.message}`);
                        }
                    }
                }
            }
        }
        catch (error) {
            logger_1.logger.error(error, `Failed to scan dir ${dir}:`);
        }
        return results;
    }
    /**
     * Generates a simple ASCII tree from a list of relative file paths.
     */
    generateAsciiTree(paths) {
        const tree = {};
        for (const p of paths) {
            const parts = p.split(path_1.default.sep);
            let current = tree;
            for (const part of parts) {
                current[part] = current[part] || {};
                current = current[part];
            }
        }
        return this.printTree(tree);
    }
    printTree(node, prefix = '') {
        const keys = Object.keys(node).sort();
        let result = '';
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const isLast = i === keys.length - 1;
            const connector = isLast ? '└── ' : '├── ';
            result += `${prefix}${connector}${key}\n`;
            const children = node[key];
            if (Object.keys(children).length > 0) {
                const childPrefix = prefix + (isLast ? '    ' : '│   ');
                result += this.printTree(children, childPrefix);
            }
        }
        return result;
    }
    /**
     * [GOD MODE] Invokes the Rust RagCore binary for extreme performance.
     */
    async queryRustCore(query) {
        const binPath = path_1.default.resolve(__dirname, '../../rag-core/target/release/rag-core.exe');
        const rootPath = this.rootDir;
        const cmd = `"${binPath}" --root "${rootPath}" --query "${query}" --limit 25`;
        const { stdout } = await execAsync(cmd, { maxBuffer: 10 * 1024 * 1024 });
        const results = JSON.parse(stdout);
        return results.map((res) => ({
            path: res.path,
            content: res.content,
            size: res.content.length,
        }));
    }
    /**
     * Queries the sovereign Supabase Hybrid Search knowledge base.
     */
    async querySupabaseKnowledge(query) {
        try {
            logger_1.logger.info(`[RagService] Querying Supabase Sovereign DB for: "${query}"`);
            // Mock embedding (768d) - In production you would use gemini or openai here
            const mockEmbedding = new Array(768).fill(0).map(() => Math.random());
            const results = await supabase_service_1.supabaseService.hybridSearch(undefined, // All projects
            query, mockEmbedding, 0.3, 3);
            if (results && results.length > 0) {
                return results
                    .map((res, i) => `[Sovereign Match ${i + 1}] Title: ${res.title}\n${res.content}`)
                    .join('\n\n');
            }
            return null;
        }
        catch (error) {
            logger_1.logger.warn(`[RagService] Failed to query Supabase Sovereign DB: ${error.message}`);
            return null;
        }
    }
};
exports.RagService = RagService;
exports.RagService = RagService = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.SovereignVaultService)),
    __metadata("design:paramtypes", [typeof (_a = typeof SovereignVaultService_1.SovereignVaultService !== "undefined" && SovereignVaultService_1.SovereignVaultService) === "function" ? _a : Object])
], RagService);
// REMOVED manual instantiation to break circular dependency and support constructor injection via Inversify
// export const ragService = new RagService();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xccmFnLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUEwQjtBQUMxQixpREFBcUM7QUFDckMsMkRBQTZCO0FBQzdCLGdEQUF3QjtBQUN4QiwrQkFBaUM7QUFDakMseUNBQStDO0FBRS9DLE1BQU0sU0FBUyxHQUFHLElBQUEsZ0JBQVMsRUFBQyxvQkFBSSxDQUFDLENBQUM7QUFFbEMsNENBQXlDO0FBQ3pDLHlEQUFxRDtBQUNyRCx5REFBcUQ7QUFDckQsb0NBQWlDO0FBQ2pDLG1FQUFnRTtBQWtDekQsSUFBTSxVQUFVLEdBQWhCLE1BQU0sVUFBVTtJQW1DNkM7SUFsQ2pELE9BQU8sQ0FBUztJQUNoQixjQUFjLEdBQVcsTUFBTSxDQUFDLENBQUMsMkJBQTJCO0lBQzVELFFBQVEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLFlBQVk7SUFDL0MsS0FBSyxHQUErQyxJQUFJLENBQUM7SUFDekQsU0FBUyxHQUF1RCxJQUFJLENBQUM7SUFFNUQsV0FBVyxHQUFHLElBQUksR0FBRyxDQUFDO1FBQ3JDLGNBQWM7UUFDZCxNQUFNO1FBQ04sT0FBTztRQUNQLE1BQU07UUFDTixRQUFRO1FBQ1IsVUFBVTtRQUNWLE1BQU07UUFDTixRQUFRO1FBQ1IsU0FBUztRQUNULE9BQU87S0FDUixDQUFDLENBQUM7SUFFYyxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsQ0FBQztRQUMzQyxPQUFPO1FBQ1AsTUFBTTtRQUNOLE1BQU07UUFDTixPQUFPO1FBQ1AsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07S0FDUCxDQUFDLENBQUM7SUFFSCxZQUFrRSxLQUE0QjtRQUE1QixVQUFLLEdBQUwsS0FBSyxDQUF1QjtRQUM1RixJQUFJLENBQUMsT0FBTyxHQUFHLGNB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SSxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDbEMsT0FBTyxPQUFPO3FCQUNYLEdBQUcsQ0FDRixDQUFDLEdBQVEsRUFBRSxDQUFTLEVBQUUsRUFBRSxDQUN0QixvQkFBb0IsQ0FBQyxHQUFHLENBQUMsWUFBWSxHQUFHLENBQUMsS0FBSyxLQUFLLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FDbkU7cUJBQ0EsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xCLENBQUM7WUFDRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFBQyxPQUFPLEtBQVUsRUFBRSxDQUFDO1lBQ3BCLGVBQU0sQ0FBQyxJQUFJLENBQUMsdURBQXVELEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ3BGLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7Q0FDRixDQUFBO0FBcmFZLGdDQUFVO3FCQUFWLFVBQVU7SUFEdEIsSUFBQSxzQkFBVSxHQUFFO0lBb0NFLFdBQUEsSUFBQSxrQkFBTSxFQUFDLGFBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO3lEQUF5Qiw2Q0FBcUIsb0JBQXJCLDZDQUFxQjtHQW5DbkYsVUFBVSxDQXFhdEI7QUFFRCw0R0FBNEc7QUFDNUcsOENBQThDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXHJhZy5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMvcHJvbWlzZXMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICd1dGlsJztcbmltcG9ydCB7IGluamVjdGFibGUsIGluamVjdCB9IGZyb20gJ2ludmVyc2lmeSc7XG5cbmNvbnN0IGV4ZWNBc3luYyA9IHByb21pc2lmeShleGVjKTtcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IHBpbmVjb25lU2VydmljZSB9IGZyb20gJy4vcGluZWNvbmUuc2VydmljZSc7XG5pbXBvcnQgeyBzdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuL3N1cGFiYXNlLnNlcnZpY2UnO1xuaW1wb3J0IHsgVFlQRVMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBTb3ZlcmVpZ25WYXVsdFNlcnZpY2UgfSBmcm9tICcuL1NvdmVyZWlnblZhdWx0U2VydmljZSc7XG5cbmludGVyZmFjZSBGaWxlQ29udGV4dCB7XG4gIHBhdGg6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBzaXplOiBudW1iZXI7XG59XG5cbi8vIEJhc2ljIHNpbXVsYXRpb24gb2YgVEYtSURGIC8gQk0yNSBjb21wb25lbnRzXG5pbnRlcmZhY2UgU2VhcmNoUmVzdWx0IHtcbiAgZmlsZTogRmlsZUNvbnRleHQ7XG4gIHNjb3JlOiBudW1iZXI7XG4gIG1ldGFkYXRhOiB7XG4gICAga2V5d29yZFNjb3JlOiBudW1iZXI7XG4gICAgc2VtYW50aWNTY29yZTogbnVtYmVyO1xuICAgIG1hdGNoZXM6IHN0cmluZ1tdO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgUmFnU2VhcmNoUmVzdWx0IHtcbiAgcXVlcnk6IHN0cmluZztcbiAgcmVzdWx0czogQXJyYXk8e1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBtZXRhZGF0YToge1xuICAgICAgc291cmNlOiBzdHJpbmc7XG4gICAgICBmaWxlbmFtZTogc3RyaW5nO1xuICAgICAgdHlwZTogc3RyaW5nO1xuICAgICAgW2tleTogc3RyaW5nXTogYW55O1xuICAgIH07XG4gICAgZGlzdGFuY2U/OiBudW1iZXI7XG4gIH0+O1xufVxuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUmFnU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcm9vdERpcjogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IG1heENvbnRleHRTaXplOiBudW1iZXIgPSAxMDAwMDA7IC8vIH4yNWsgdG9rZW5zIChzYWZlIGxpbWl0KVxuICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlVFRMID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXG4gIHByaXZhdGUgY2FjaGU6IHsgZGF0YTogc3RyaW5nOyB0aW1lc3RhbXA6IG51bWJlciB9IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZmlsZUNhY2hlOiB7IGZpbGVzOiBGaWxlQ29udGV4dFtdOyB0aW1lc3RhbXA6IG51bWJlciB9IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpZ25vcmVkRGlycyA9IG5ldyBTZXQoW1xuICAgICdub2RlX21vZHVsZXMnLFxuICAgICdkaXN0JyxcbiAgICAnYnVpbGQnLFxuICAgICcuZ2l0JyxcbiAgICAnLnR1cmJvJyxcbiAgICAnY292ZXJhZ2UnLFxuICAgICdsb2dzJyxcbiAgICAnLnRydW5rJyxcbiAgICAnLnZzY29kZScsXG4gICAgJy5pZGVhJyxcbiAgXSk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpZ25vcmVkRXh0ZW5zaW9ucyA9IG5ldyBTZXQoW1xuICAgICcubG9jaycsXG4gICAgJy5wbmcnLFxuICAgICcuanBnJyxcbiAgICAnLmpwZWcnLFxuICAgICcuZ2lmJyxcbiAgICAnLnN2ZycsXG4gICAgJy5pY28nLFxuICAgICcucGRmJyxcbiAgICAnLnppcCcsXG4gICAgJy5tYXAnLFxuICAgICcubXA0JyxcbiAgICAnLm1wMycsXG4gIF0pO1xuXG4gIGNvbnN0cnVjdG9yKEBpbmplY3QoVFlQRVMuU292ZXJlaWduVmF1bHRTZXJ2aWNlKSBwcml2YXRlIHJlYWRvbmx5IHZhdWx0OiBTb3ZlcmVpZ25WYXVsdFNlcnZpY2UpIHtcbiAgICB0aGlzLnJvb3REaXIgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vLi4vLi4vJyk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbnMgdGhlIGNvZGViYXNlIGFuZCByZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyBvZiB0aGUgY29udGV4dC5cbiAgICogVXNlcyBpbi1tZW1vcnkgY2FjaGluZyBhbmQgcHJlcGVuZHMgYW4gQVNDSUkgdHJlZSBvZiB0aGUgcHJvamVjdCBzdHJ1Y3R1cmUuXG4gICAqIElmIHF1ZXJ5IGlzIHByb3ZpZGVkLCBwZXJmb3JtcyBhIEh5YnJpZCBTZWFyY2ggc2ltdWxhdGlvbiB0byBwcmlvcml0aXplIHJlbGV2YW50IGZpbGVzLlxuICAgKiBBTFNPIHF1ZXJpZXMgdGhlIFNvdmVyZWlnbiBWYXVsdCBzZXJ2aWNlIGZvciBkb2N1bWVudGF0aW9uIGNvbnRleHQuXG4gICAqL1xuICBhc3luYyBnZXRQcm9qZWN0Q29udGV4dChxdWVyeT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5pbmZvKGBbUmFnU2VydmljZV0gR2V0dGluZyBjb250ZXh0JHtxdWVyeSA/IGAgZm9yIHF1ZXJ5OiBcIiR7cXVlcnl9XCJgIDogJyAoZnVsbCknfS4uLmApO1xuXG4gICAgICBsZXQgY29udGV4dCA9ICcnO1xuXG4gICAgICAvLyAxLiBSdW4gRmlsZSBTY2FuIGFuZCBEYXRhYmFzZSBRdWVyeSBpbiBwYXJhbGxlbFxuICAgICAgY29uc3QgW2ZpbGVzLCB2YXVsdFJlc3VsdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmdldEFsbEZpbGVzKCksXG4gICAgICAgIHF1ZXJ5ICYmIHF1ZXJ5LnRyaW0oKS5sZW5ndGggPiAwID8gdGhpcy52YXVsdC5xdWVyeShxdWVyeSkgOiBQcm9taXNlLnJlc29sdmUobnVsbCksXG4gICAgICBdKTtcblxuICAgICAgLy8gMi4gR2VuZXJhdGUgQVNDSUkgVHJlZSAoYWx3YXlzIHVzZWZ1bCBmb3Igc3RydWN0dXJlKVxuICAgICAgY29uc3QgZmlsZVBhdGhzID0gZmlsZXMubWFwKGYgPT4gZi5wYXRoKTtcbiAgICAgIGNvbnN0IGFzY2lpVHJlZSA9IHRoaXMuZ2VuZXJhdGVBc2NpaVRyZWUoZmlsZVBhdGhzKTtcblxuICAgICAgY29udGV4dCArPSBgUHJvamVjdCBTdHJ1Y3R1cmU6XFxuJHthc2NpaVRyZWV9XFxuXFxuYDtcblxuICAgICAgbGV0IHNvcnRlZEZpbGVzID0gZmlsZXM7XG5cbiAgICAgIC8vIFtHT0QgTU9ERV0gVXNlIFJ1c3QtcG93ZXJlZCByYWctY29yZSBpZiBxdWVyeSBpcyBwcm92aWRlZFxuICAgICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQgKz0gYFtDb2RlIENvbnRleHQgb3B0aW1pemVkIGZvciBxdWVyeTogXCIke3F1ZXJ5fVwiXVxcblxcbmA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBydXN0UmVzdWx0cyA9IGF3YWl0IHRoaXMucXVlcnlSdXN0Q29yZShxdWVyeSk7XG4gICAgICAgICAgaWYgKHJ1c3RSZXN1bHRzICYmIHJ1c3RSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICBgW1JhZ1NlcnZpY2VdIFJ1c3QgUmFnQ29yZSBwcm92aWRlZCAke3J1c3RSZXN1bHRzLmxlbmd0aH0gb3B0aW1pemVkIHJlc3VsdHMuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzb3J0ZWRGaWxlcyA9IHJ1c3RSZXN1bHRzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0ZWRGaWxlcyA9IHRoaXMucmFua0ZpbGVzKGZpbGVzLCBxdWVyeSEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYFtSYWdTZXJ2aWNlXSBSdXN0IFJhZ0NvcmUgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlMgcmFua2luZzogJHtlcnJ9YCk7XG4gICAgICAgICAgc29ydGVkRmlsZXMgPSB0aGlzLnJhbmtGaWxlcyhmaWxlcywgcXVlcnkhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBTb3ZlcmVpZ24gVmF1bHQgQ29udGV4dCAoVW5pZmllZCBNZW1vcnkpXG4gICAgICAgIGlmICh2YXVsdFJlc3VsdHMgJiYgdmF1bHRSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0ICs9IGBbU292ZXJlaWduIFZhdWx0IC0gVW5pZmllZCBNZW1vcnkgQmFua3NdXFxuYDtcbiAgICAgICAgICB2YXVsdFJlc3VsdHMuZm9yRWFjaCgocmVzLCBpKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0ICs9IGAtLS0gTWVtb3J5IEl0ZW0gJHtpICsgMX0gW1NvdXJjZTogJHtyZXMuc291cmNlLnRvVXBwZXJDYXNlKCl9XSAtLS1cXG4ke1xuICAgICAgICAgICAgICByZXMuY29udGVudFxuICAgICAgICAgICAgfVxcblxcbmA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbENvbnRleHQgPSBhd2FpdCB0aGlzLnF1ZXJ5TG9jYWxNZW1vcnkocXVlcnkhKTtcbiAgICAgICAgaWYgKGxvY2FsQ29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQgKz0gYFtMb2NhbCBOZXVyYWwgTWVtb3J5IChOZXVyb0NvcmUpXVxcbiR7bG9jYWxDb250ZXh0fVxcblxcbmA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQgKz0gYFtGdWxsIENvbnRleHQgLSBObyBRdWVyeSBQcm92aWRlZF1cXG5cXG5gO1xuICAgICAgICAvLyBEZWZhdWx0IHNvcnQgYnkgcGF0aCBpZiBubyBxdWVyeSB0byBtYWludGFpbiBzdGFiaWxpdHlcbiAgICAgICAgc29ydGVkRmlsZXMuc29ydCgoYSwgYikgPT4gYS5wYXRoLmxvY2FsZUNvbXBhcmUoYi5wYXRoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQgKz0gYEhlcmUgaXMgdGhlIGNvZGViYXNlIGNvbnRleHQ6XFxuXFxuYDtcbiAgICAgIGxldCBjdXJyZW50U2l6ZSA9IGNvbnRleHQubGVuZ3RoO1xuXG4gICAgICAvLyA0LiBDb250ZXh0IFN0dWZmaW5nIHdpdGggTGltaXRcbiAgICAgIGxldCBpbmNsdWRlZENvdW50ID0gMDtcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBzb3J0ZWRGaWxlcykge1xuICAgICAgICBjb25zdCBmaWxlQmxvY2sgPSBgPGZpbGUgcGF0aD1cIiR7ZmlsZS5wYXRofVwiPlxcbiR7ZmlsZS5jb250ZW50fVxcbjwvZmlsZT5cXG5cXG5gO1xuXG4gICAgICAgIGlmIChjdXJyZW50U2l6ZSArIGZpbGVCbG9jay5sZW5ndGggPiB0aGlzLm1heENvbnRleHRTaXplKSB7XG4gICAgICAgICAgY29udGV4dCArPSBgXFxuPCEtLSBDb250ZXh0IHRydW5jYXRlZCBkdWUgdG8gc2l6ZSBsaW1pdCAoJHt0aGlzLm1heENvbnRleHRTaXplfSBjaGFycykuIEluY2x1ZGVkICR7aW5jbHVkZWRDb3VudH0gb2YgJHtzb3J0ZWRGaWxlcy5sZW5ndGh9IGZpbGVzLiAtLT5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dCArPSBmaWxlQmxvY2s7XG4gICAgICAgIGN1cnJlbnRTaXplICs9IGZpbGVCbG9jay5sZW5ndGg7XG4gICAgICAgIGluY2x1ZGVkQ291bnQrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvciwgJ0Vycm9yIGluIFJhZ1NlcnZpY2U6Jyk7XG4gICAgICByZXR1cm4gJyc7IC8vIEZhaWwgZ3JhY2VmdWxseVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgaW50ZXJmYWNlIHRvIHF1ZXJ5IHRoZSBrbm93bGVkZ2UgYmFzZSAoVmVjdG9yIERCIGRvY3VtZW50YXRpb24pLlxuICAgKiBNaWdyYXRlZCB0byBTb3ZlcmVpZ25WYXVsdFNlcnZpY2UgZm9yIHVuaWZpZWQgZGlzY292ZXJ5LlxuICAgKi9cbiAgYXN5bmMgcXVlcnlLbm93bGVkZ2VCYXNlKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy52YXVsdC5xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAoIXJlc3VsdHMgfHwgcmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgICAgIC5tYXAoXG4gICAgICAgIChyZXMsIGkpID0+XG4gICAgICAgICAgYFtTb3VyY2U6ICR7cmVzLnNvdXJjZS50b1VwcGVyQ2FzZSgpfSB8IFNjb3JlOiAke3Jlcy5zY29yZS50b0ZpeGVkKDIpfV1cXG4ke3Jlcy5jb250ZW50fWAsXG4gICAgICApXG4gICAgICAuam9pbignXFxuXFxuJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5nZXN0cyBhIG5ldyBkb2N1bWVudCBpbnRvIHRoZSBTb3ZlcmVpZ24gVmF1bHQuXG4gICAqL1xuICBhc3luYyBpbmdlc3REb2N1bWVudChmaWxlbmFtZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIHRhZ3M6IHN0cmluZ1tdID0gW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIuaW5mbyhgW1JhZ1NlcnZpY2VdIEZvcndhcmRpbmcgaW5nZXN0aW9uIHRvIFNvdmVyZWlnblZhdWx0OiAke2ZpbGVuYW1lfWApO1xuICAgIGF3YWl0IHRoaXMudmF1bHQuaW5nZXN0KGZpbGVuYW1lLCBjb250ZW50LCB0YWdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZpY2FsbHkgYXJjaGl2ZXMgZGF0YSB0byB0aGUgbG9jYWwgTmV1cm9Db3JlIE1MIHNlcnZpY2UuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGFyY2hpdmVUb0xvY2FsTWVtb3J5KFxuICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICBmaWxlbmFtZTogc3RyaW5nLFxuICAgIHRhZ3M6IHN0cmluZ1tdID0gW10sXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtbFNlcnZpY2VVcmwgPSBwcm9jZXNzLmVudi5NTF9TRVJWSUNFX1VSTCB8fCAnaHR0cDovL21sLXNlcnZpY2U6NTAwMCc7XG4gICAgICBhd2FpdCBheGlvcy5wb3N0KGAke21sU2VydmljZVVybH0vYXJjaGl2ZWAsIHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgc291cmNlOiBmaWxlbmFtZSxcbiAgICAgICAgdGFncyxcbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLmluZm8oYFtSYWdTZXJ2aWNlXSBEb2N1bWVudCBhcmNoaXZlZCB0byBsb2NhbCBOZXVyb0NvcmU6ICR7ZmlsZW5hbWV9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgbG9nZ2VyLndhcm4oYFtSYWdTZXJ2aWNlXSBGYWlsZWQgdG8gYXJjaGl2ZSB0byBsb2NhbCBOZXVyb0NvcmU6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVlcmllcyB0aGUgbG9jYWwgTmV1cm9Db3JlIE1MIHNlcnZpY2UgZm9yIG5ldXJhbCBlbWJlZGRpbmdzIHNlYXJjaC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcXVlcnlMb2NhbE1lbW9yeShxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1sU2VydmljZVVybCA9IHByb2Nlc3MuZW52Lk1MX1NFUlZJQ0VfVVJMIHx8ICdodHRwOi8vbWwtc2VydmljZTo1MDAwJztcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHttbFNlcnZpY2VVcmx9L3JlY2FsbGAsIHsgcXVlcnksIGxpbWl0OiAzIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gcmVzcG9uc2UuZGF0YS5yZXN1bHRzO1xuICAgICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzXG4gICAgICAgICAgLm1hcChcbiAgICAgICAgICAgIChyZXM6IGFueSwgaTogbnVtYmVyKSA9PlxuICAgICAgICAgICAgICBgW0xvY2FsIE1hdGNoICR7aSArIDF9XSBTb3VyY2U6ICR7cmVzLm1ldGFkYXRhLnNvdXJjZX1cXG4ke3Jlcy5jb250ZW50fWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIC5qb2luKCdcXG5cXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBbUmFnU2VydmljZV0gRmFpbGVkIHRvIHF1ZXJ5IGxvY2FsIE5ldXJvQ29yZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgdGhlIGRpcmVjdCBQaW5lY29uZSBWZWN0b3IgREIgZm9yIHJlbGV2YW50IGRvY3VtZW50YXRpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHF1ZXJ5VmVjdG9yRGIocXVlcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuaW5mbyhgW1JhZ1NlcnZpY2VdIFF1ZXJ5aW5nIFBpbmVjb25lIFZlY3RvciBEQiBmb3I6IFwiJHtxdWVyeX1cImApO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGluZWNvbmVTZXJ2aWNlLnNlYXJjaChxdWVyeSwgMyk7XG5cbiAgICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgZG9jU3RyID0gJyc7XG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcmVzLm1ldGFkYXRhPy5maWxlbmFtZSB8fCAndW5rbm93bic7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IHJlcy5tZXRhZGF0YT8udGV4dCB8fCAnJztcbiAgICAgICAgICBkb2NTdHIgKz0gYC0tLSBEb2N1bWVudCAke2luZGV4ICsgMX0gKCR7ZmlsZW5hbWV9KSAtLS1cXG4ke2NvbnRlbnR9XFxuXFxuYDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkb2NTdHIudHJpbSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgLy8gTG9nIGJ1dCBkb24ndCBjcmFzaFxuICAgICAgbG9nZ2VyLndhcm4oYFtSYWdTZXJ2aWNlXSBGYWlsZWQgdG8gcXVlcnkgUGluZWNvbmUgVmVjdG9yIERCOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gYDwhLS0gRmFpbGVkIHRvIHJldHJpZXZlIGRvY3VtZW50YXRpb24gY29udGV4dCBmcm9tIFBpbmVjb25lOiAke2Vycm9yLm1lc3NhZ2V9IC0tPmA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRBbGxGaWxlcygpOiBQcm9taXNlPEZpbGVDb250ZXh0W10+IHtcbiAgICBpZiAodGhpcy5maWxlQ2FjaGUgJiYgRGF0ZS5ub3coKSAtIHRoaXMuZmlsZUNhY2hlLnRpbWVzdGFtcCA8IHRoaXMuY2FjaGVUVEwpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGVDYWNoZS5maWxlcztcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMuc2NhbkRpcmVjdG9yeSh0aGlzLnJvb3REaXIpO1xuICAgIHRoaXMuZmlsZUNhY2hlID0ge1xuICAgICAgZmlsZXMsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfTtcbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cblxuICAvKipcbiAgICogUmFua3MgZmlsZXMgdXNpbmcgYSBzaW11bGF0ZWQgSHlicmlkIFNlYXJjaCAoS2V5d29yZCArIFN0cnVjdHVyYWwpLlxuICAgKiBDYWxjdWxhdGVzIGEgc2ltcGxlIHNjb3JlIGJhc2VkIG9uOlxuICAgKiAxLiBQYXRoL0ZpbGVuYW1lIG1hdGNoIChTdHJ1Y3R1cmFsL1NlbWFudGljIHByb3h5KVxuICAgKiAyLiBDb250ZW50IGtleXdvcmQgZnJlcXVlbmN5IChURiBwcm94eSlcbiAgICovXG4gIHByaXZhdGUgcmFua0ZpbGVzKGZpbGVzOiBGaWxlQ29udGV4dFtdLCBxdWVyeTogc3RyaW5nKTogRmlsZUNvbnRleHRbXSB7XG4gICAgY29uc3QgdGVybXMgPSBxdWVyeVxuICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAuZmlsdGVyKHQgPT4gdC5sZW5ndGggPiAyKTtcbiAgICBpZiAodGVybXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmlsZXM7XG5cbiAgICBjb25zdCByZXN1bHRzOiBTZWFyY2hSZXN1bHRbXSA9IGZpbGVzLm1hcChmaWxlID0+IHtcbiAgICAgIGxldCBrZXl3b3JkU2NvcmUgPSAwO1xuICAgICAgbGV0IHNlbWFudGljU2NvcmUgPSAwO1xuICAgICAgY29uc3QgbWF0Y2hlczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGNvbnN0IGNvbnRlbnRMb3dlciA9IGZpbGUuY29udGVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgcGF0aExvd2VyID0gZmlsZS5wYXRoLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHRlcm1zLmZvckVhY2godGVybSA9PiB7XG4gICAgICAgIC8vIFN0cnVjdHVyYWwgU2NvcmU6IEZpbGVuYW1lIG1hdGNoZXMgYXJlIGhpZ2ggc2lnbmFsXG4gICAgICAgIGlmIChwYXRoTG93ZXIuaW5jbHVkZXModGVybSkpIHtcbiAgICAgICAgICBzZW1hbnRpY1Njb3JlICs9IDEwO1xuICAgICAgICAgIG1hdGNoZXMucHVzaChgcGF0aDoke3Rlcm19YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZXl3b3JkIFNjb3JlOiBTaW1wbGUgZnJlcXVlbmN5IGNvdW50IGluIGNvbnRlbnRcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHRoaXMuZXNjYXBlUmVnRXhwKHRlcm0pLCAnZycpO1xuICAgICAgICBjb25zdCBjb3VudCA9IChjb250ZW50TG93ZXIubWF0Y2gocmVnZXgpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICBrZXl3b3JkU2NvcmUgKz0gY291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmaW5hbEtleXdvcmRTY29yZSA9IGtleXdvcmRTY29yZSA+IDAgPyBNYXRoLmxvZygxICsga2V5d29yZFNjb3JlKSA6IDA7XG4gICAgICBjb25zdCB0b3RhbFNjb3JlID0gc2VtYW50aWNTY29yZSAqIDIgKyBmaW5hbEtleXdvcmRTY29yZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZSxcbiAgICAgICAgc2NvcmU6IHRvdGFsU2NvcmUsXG4gICAgICAgIG1ldGFkYXRhOiB7IGtleXdvcmRTY29yZTogZmluYWxLZXl3b3JkU2NvcmUsIHNlbWFudGljU2NvcmUsIG1hdGNoZXMgfSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCByZWxldmFudEZpbGVzID0gcmVzdWx0c1xuICAgICAgLmZpbHRlcihyID0+IHIuc2NvcmUgPiAwKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgLm1hcChyID0+IHIuZmlsZSk7XG5cbiAgICBjb25zdCBvdGhlckZpbGVzID0gZmlsZXMuZmlsdGVyKGYgPT4gIXJlbGV2YW50RmlsZXMuaW5jbHVkZXMoZikpO1xuICAgIHJldHVybiBbLi4ucmVsZXZhbnRGaWxlcywgLi4ub3RoZXJGaWxlc107XG4gIH1cblxuICBwcml2YXRlIGVzY2FwZVJlZ0V4cChzdHJpbmc6IHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2NhbkRpcmVjdG9yeShkaXI6IHN0cmluZyk6IFByb21pc2U8RmlsZUNvbnRleHRbXT4ge1xuICAgIGxldCByZXN1bHRzOiBGaWxlQ29udGV4dFtdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IGZzLnJlYWRkaXIoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGVudHJ5Lm5hbWUpO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHRoaXMucm9vdERpciwgZnVsbFBhdGgpO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlnbm9yZWREaXJzLmhhcyhlbnRyeS5uYW1lKSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViUmVzdWx0cyA9IGF3YWl0IHRoaXMuc2NhbkRpcmVjdG9yeShmdWxsUGF0aCk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoc3ViUmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRmlsZSgpKSB7XG4gICAgICAgICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKGVudHJ5Lm5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmlnbm9yZWRFeHRlbnNpb25zLmhhcyhleHQpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZnVsbFBhdGgsICd1dGYtOCcpO1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGg6IHJlbGF0aXZlUGF0aCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgIHNpemU6IGNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDb3VsZCBub3QgcmVhZCBmaWxlICR7ZnVsbFBhdGh9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IsIGBGYWlsZWQgdG8gc2NhbiBkaXIgJHtkaXJ9OmApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNpbXBsZSBBU0NJSSB0cmVlIGZyb20gYSBsaXN0IG9mIHJlbGF0aXZlIGZpbGUgcGF0aHMuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlQXNjaWlUcmVlKHBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgdHJlZTogYW55ID0ge307XG4gICAgZm9yIChjb25zdCBwIG9mIHBhdGhzKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHAuc3BsaXQocGF0aC5zZXApO1xuICAgICAgbGV0IGN1cnJlbnQgPSB0cmVlO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGN1cnJlbnRbcGFydF0gPSBjdXJyZW50W3BhcnRdIHx8IHt9O1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcmludFRyZWUodHJlZSk7XG4gIH1cblxuICBwcml2YXRlIHByaW50VHJlZShub2RlOiBhbnksIHByZWZpeCA9ICcnKTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobm9kZSkuc29ydCgpO1xuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IGNvbm5lY3RvciA9IGlzTGFzdCA/ICfilJTilIDilIAgJyA6ICfilJzilIDilIAgJztcblxuICAgICAgcmVzdWx0ICs9IGAke3ByZWZpeH0ke2Nvbm5lY3Rvcn0ke2tleX1cXG5gO1xuXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGVba2V5XTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhjaGlsZHJlbikubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjaGlsZFByZWZpeCA9IHByZWZpeCArIChpc0xhc3QgPyAnICAgICcgOiAn4pSCICAgJyk7XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLnByaW50VHJlZShjaGlsZHJlbiwgY2hpbGRQcmVmaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFtHT0QgTU9ERV0gSW52b2tlcyB0aGUgUnVzdCBSYWdDb3JlIGJpbmFyeSBmb3IgZXh0cmVtZSBwZXJmb3JtYW5jZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcXVlcnlSdXN0Q29yZShxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxGaWxlQ29udGV4dFtdPiB7XG4gICAgY29uc3QgYmluUGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi9yYWctY29yZS90YXJnZXQvcmVsZWFzZS9yYWctY29yZS5leGUnKTtcbiAgICBjb25zdCByb290UGF0aCA9IHRoaXMucm9vdERpcjtcblxuICAgIGNvbnN0IGNtZCA9IGBcIiR7YmluUGF0aH1cIiAtLXJvb3QgXCIke3Jvb3RQYXRofVwiIC0tcXVlcnkgXCIke3F1ZXJ5fVwiIC0tbGltaXQgMjVgO1xuICAgIGNvbnN0IHsgc3Rkb3V0IH0gPSBhd2FpdCBleGVjQXN5bmMoY21kLCB7IG1heEJ1ZmZlcjogMTAgKiAxMDI0ICogMTAyNCB9KTtcbiAgICBjb25zdCByZXN1bHRzID0gSlNPTi5wYXJzZShzdGRvdXQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXM6IGFueSkgPT4gKHtcbiAgICAgIHBhdGg6IHJlcy5wYXRoLFxuICAgICAgY29udGVudDogcmVzLmNvbnRlbnQsXG4gICAgICBzaXplOiByZXMuY29udGVudC5sZW5ndGgsXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgdGhlIHNvdmVyZWlnbiBTdXBhYmFzZSBIeWJyaWQgU2VhcmNoIGtub3dsZWRnZSBiYXNlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBxdWVyeVN1cGFiYXNlS25vd2xlZGdlKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmluZm8oYFtSYWdTZXJ2aWNlXSBRdWVyeWluZyBTdXBhYmFzZSBTb3ZlcmVpZ24gREIgZm9yOiBcIiR7cXVlcnl9XCJgKTtcblxuICAgICAgLy8gTW9jayBlbWJlZGRpbmcgKDc2OGQpIC0gSW4gcHJvZHVjdGlvbiB5b3Ugd291bGQgdXNlIGdlbWluaSBvciBvcGVuYWkgaGVyZVxuICAgICAgY29uc3QgbW9ja0VtYmVkZGluZyA9IG5ldyBBcnJheSg3NjgpLmZpbGwoMCkubWFwKCgpID0+IE1hdGgucmFuZG9tKCkpO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwYWJhc2VTZXJ2aWNlLmh5YnJpZFNlYXJjaChcbiAgICAgICAgdW5kZWZpbmVkLCAvLyBBbGwgcHJvamVjdHNcbiAgICAgICAgcXVlcnksXG4gICAgICAgIG1vY2tFbWJlZGRpbmcsXG4gICAgICAgIDAuMyxcbiAgICAgICAgMyxcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0c1xuICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAocmVzOiBhbnksIGk6IG51bWJlcikgPT5cbiAgICAgICAgICAgICAgYFtTb3ZlcmVpZ24gTWF0Y2ggJHtpICsgMX1dIFRpdGxlOiAke3Jlcy50aXRsZX1cXG4ke3Jlcy5jb250ZW50fWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIC5qb2luKCdcXG5cXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBbUmFnU2VydmljZV0gRmFpbGVkIHRvIHF1ZXJ5IFN1cGFiYXNlIFNvdmVyZWlnbiBEQjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8vIFJFTU9WRUQgbWFudWFsIGluc3RhbnRpYXRpb24gdG8gYnJlYWsgY2lyY3VsYXIgZGVwZW5kZW5jeSBhbmQgc3VwcG9ydCBjb25zdHJ1Y3RvciBpbmplY3Rpb24gdmlhIEludmVyc2lmeVxuLy8gZXhwb3J0IGNvbnN0IHJhZ1NlcnZpY2UgPSBuZXcgUmFnU2VydmljZSgpO1xuIl0sInZlcnNpb24iOjN9