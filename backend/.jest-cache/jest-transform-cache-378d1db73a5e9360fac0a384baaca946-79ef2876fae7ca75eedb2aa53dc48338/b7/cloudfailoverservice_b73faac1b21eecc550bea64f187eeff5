5fd6b2d43796af84bd19ea015375fc4e
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudFailoverService = exports.CloudProvider = void 0;
const inversify_1 = require("inversify");
const CircuitBreakerFactory_1 = require("../infrastructure/resilience/CircuitBreakerFactory");
const logger_1 = require("../utils/logger");
var CloudProvider;
(function (CloudProvider) {
    CloudProvider["GCP"] = "gcp";
    CloudProvider["AWS"] = "aws";
})(CloudProvider || (exports.CloudProvider = CloudProvider = {}));
let CloudFailoverService = class CloudFailoverService {
    currentProvider = CloudProvider.GCP;
    breaker;
    constructor() {
        // Circuit Breaker monitors GCP health. If it opens, we failover.
        this.breaker = CircuitBreakerFactory_1.CircuitBreakerFactory.create(async () => this.checkGCPHealth(), {
            name: 'GCP-Health-Check',
            errorThresholdPercentage: 50,
            resetTimeout: 30000,
        });
        this.breaker.on('open', () => this.triggerFailover(CloudProvider.AWS));
        this.breaker.on('close', () => this.triggerFailover(CloudProvider.GCP));
    }
    /**
     * returns the current active cloud provider.
     */
    getCurrentProvider() {
        return this.currentProvider;
    }
    /**
     * Executes a critical operation with automatic failover logic.
     * @param gcpFn Function to execute on GCP
     * @param awsFn Function to execute on AWS
     */
    async execute(gcpFn, awsFn) {
        if (this.currentProvider === CloudProvider.AWS) {
            return awsFn();
        }
        try {
            // Attempt GCP via breaker
            return await this.breaker.fire();
        }
        catch (error) {
            logger_1.logger.warn(`[Failover] GCP call failed, attempting fallback to AWS. Error: ${error}`);
            // Force failover state? Maybe not for single error, but breaker handles state.
            // For now, simple fallback execution:
            return awsFn();
        }
    }
    async checkGCPHealth() {
        // In a real app, ping a GCP metadata server or health endpoint.
        // Simulation: Random failure chance if enabled?
        // True = Healthy
        return true;
    }
    triggerFailover(to) {
        if (this.currentProvider !== to) {
            logger_1.logger.warn(`[CloudFailover] ðŸš¨ SWITCHING CLOUD PROVIDER: ${this.currentProvider.toUpperCase()} -> ${to.toUpperCase()}`);
            this.currentProvider = to;
        }
    }
};
exports.CloudFailoverService = CloudFailoverService;
exports.CloudFailoverService = CloudFailoverService = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], CloudFailoverService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBbGVqYW5kcm9cXEFJR2VzdGlvblxcYmFja2VuZFxcc3JjXFxzZXJ2aWNlc1xcY2xvdWQtZmFpbG92ZXIuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBdUM7QUFDdkMsOEZBQTJGO0FBQzNGLDRDQUF5QztBQUV6QyxJQUFZLGFBR1g7QUFIRCxXQUFZLGFBQWE7SUFDdkIsNEJBQVcsQ0FBQTtJQUNYLDRCQUFXLENBQUE7QUFDYixDQUFDLEVBSFcsYUFBYSw2QkFBYixhQUFhLFFBR3hCO0FBR00sSUFBTSxvQkFBb0IsR0FBMUIsTUFBTSxvQkFBb0I7SUFDdkIsZUFBZSxHQUFrQixhQUFhLENBQUMsR0FBRyxDQUFDO0lBQ25ELE9BQU8sQ0FBTTtJQUVyQjtRQUNFLGlFQUFpRTtRQUNqRSxJQUFJLENBQUMsT0FBTyxHQUFHLDZDQUFxQixDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRTtZQUM3RSxJQUFJLEVBQUUsa0JBQWtCO1lBQ3hCLHdCQUF3QixFQUFFLEVBQUU7WUFDNUIsWUFBWSxFQUFFLEtBQUs7U0FDcEIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdkUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksa0JBQWtCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEtBQUssQ0FBQyxPQUFPLENBQUksS0FBdUIsRUFBRSxLQUF1QjtRQUN0RSxJQUFJLElBQUksQ0FBQyxlQUFlLEtBQUssYUFBYSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQy9DLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDakIsQ0FBQztRQUVELElBQUksQ0FBQztZQUNILDBCQUEwQjtZQUMxQixPQUFPLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNuQyxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLGVBQU0sQ0FBQyxJQUFJLENBQUMsa0VBQWtFLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDdkYsK0VBQStFO1lBQy9FLHNDQUFzQztZQUN0QyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2pCLENBQUM7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLGNBQWM7UUFDMUIsZ0VBQWdFO1FBQ2hFLGdEQUFnRDtRQUNoRCxpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU8sZUFBZSxDQUFDLEVBQWlCO1FBQ3ZDLElBQUksSUFBSSxDQUFDLGVBQWUsS0FBSyxFQUFFLEVBQUUsQ0FBQztZQUNoQyxlQUFNLENBQUMsSUFBSSxDQUNULGdEQUFnRCxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUM1RyxDQUFDO1lBQ0YsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7UUFDNUIsQ0FBQztJQUNILENBQUM7Q0FDRixDQUFBO0FBM0RZLG9EQUFvQjsrQkFBcEIsb0JBQW9CO0lBRGhDLElBQUEsc0JBQVUsR0FBRTs7R0FDQSxvQkFBb0IsQ0EyRGhDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWxlamFuZHJvXFxBSUdlc3Rpb25cXGJhY2tlbmRcXHNyY1xcc2VydmljZXNcXGNsb3VkLWZhaWxvdmVyLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0YWJsZSB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyBDaXJjdWl0QnJlYWtlckZhY3RvcnkgfSBmcm9tICcuLi9pbmZyYXN0cnVjdHVyZS9yZXNpbGllbmNlL0NpcmN1aXRCcmVha2VyRmFjdG9yeSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgZW51bSBDbG91ZFByb3ZpZGVyIHtcbiAgR0NQID0gJ2djcCcsXG4gIEFXUyA9ICdhd3MnLFxufVxuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ2xvdWRGYWlsb3ZlclNlcnZpY2Uge1xuICBwcml2YXRlIGN1cnJlbnRQcm92aWRlcjogQ2xvdWRQcm92aWRlciA9IENsb3VkUHJvdmlkZXIuR0NQO1xuICBwcml2YXRlIGJyZWFrZXI6IGFueTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBDaXJjdWl0IEJyZWFrZXIgbW9uaXRvcnMgR0NQIGhlYWx0aC4gSWYgaXQgb3BlbnMsIHdlIGZhaWxvdmVyLlxuICAgIHRoaXMuYnJlYWtlciA9IENpcmN1aXRCcmVha2VyRmFjdG9yeS5jcmVhdGUoYXN5bmMgKCkgPT4gdGhpcy5jaGVja0dDUEhlYWx0aCgpLCB7XG4gICAgICBuYW1lOiAnR0NQLUhlYWx0aC1DaGVjaycsXG4gICAgICBlcnJvclRocmVzaG9sZFBlcmNlbnRhZ2U6IDUwLFxuICAgICAgcmVzZXRUaW1lb3V0OiAzMDAwMCxcbiAgICB9KTtcblxuICAgIHRoaXMuYnJlYWtlci5vbignb3BlbicsICgpID0+IHRoaXMudHJpZ2dlckZhaWxvdmVyKENsb3VkUHJvdmlkZXIuQVdTKSk7XG4gICAgdGhpcy5icmVha2VyLm9uKCdjbG9zZScsICgpID0+IHRoaXMudHJpZ2dlckZhaWxvdmVyKENsb3VkUHJvdmlkZXIuR0NQKSk7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgY3VycmVudCBhY3RpdmUgY2xvdWQgcHJvdmlkZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0Q3VycmVudFByb3ZpZGVyKCk6IENsb3VkUHJvdmlkZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRQcm92aWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGNyaXRpY2FsIG9wZXJhdGlvbiB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlciBsb2dpYy5cbiAgICogQHBhcmFtIGdjcEZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gR0NQXG4gICAqIEBwYXJhbSBhd3NGbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIEFXU1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGV4ZWN1dGU8VD4oZ2NwRm46ICgpID0+IFByb21pc2U8VD4sIGF3c0ZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgaWYgKHRoaXMuY3VycmVudFByb3ZpZGVyID09PSBDbG91ZFByb3ZpZGVyLkFXUykge1xuICAgICAgcmV0dXJuIGF3c0ZuKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEF0dGVtcHQgR0NQIHZpYSBicmVha2VyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5icmVha2VyLmZpcmUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLndhcm4oYFtGYWlsb3Zlcl0gR0NQIGNhbGwgZmFpbGVkLCBhdHRlbXB0aW5nIGZhbGxiYWNrIHRvIEFXUy4gRXJyb3I6ICR7ZXJyb3J9YCk7XG4gICAgICAvLyBGb3JjZSBmYWlsb3ZlciBzdGF0ZT8gTWF5YmUgbm90IGZvciBzaW5nbGUgZXJyb3IsIGJ1dCBicmVha2VyIGhhbmRsZXMgc3RhdGUuXG4gICAgICAvLyBGb3Igbm93LCBzaW1wbGUgZmFsbGJhY2sgZXhlY3V0aW9uOlxuICAgICAgcmV0dXJuIGF3c0ZuKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0dDUEhlYWx0aCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCBwaW5nIGEgR0NQIG1ldGFkYXRhIHNlcnZlciBvciBoZWFsdGggZW5kcG9pbnQuXG4gICAgLy8gU2ltdWxhdGlvbjogUmFuZG9tIGZhaWx1cmUgY2hhbmNlIGlmIGVuYWJsZWQ/XG4gICAgLy8gVHJ1ZSA9IEhlYWx0aHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgdHJpZ2dlckZhaWxvdmVyKHRvOiBDbG91ZFByb3ZpZGVyKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFByb3ZpZGVyICE9PSB0bykge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBbQ2xvdWRGYWlsb3Zlcl0g8J+aqCBTV0lUQ0hJTkcgQ0xPVUQgUFJPVklERVI6ICR7dGhpcy5jdXJyZW50UHJvdmlkZXIudG9VcHBlckNhc2UoKX0gLT4gJHt0by50b1VwcGVyQ2FzZSgpfWAsXG4gICAgICApO1xuICAgICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSB0bztcbiAgICB9XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==